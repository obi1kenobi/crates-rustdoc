{"root":"0:0:1716","crate_version":"4.3.2","includes_private":true,"index":{"0:11:1847":{"id":"0:11:1847","crate_id":0,"name":"escaped_positional_derive","span":{"filename":"src/_cookbook/escaped_positional_derive.rs","begin":[1,0],"end":[7,69]},"visibility":"public","docs":"# Example (Derive API)\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)] // requires `derive` feature\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[arg(short = 'f')]\n    eff: bool,\n\n    #[arg(short = 'p', value_name = \"PEAR\")]\n    pea: Option<String>,\n\n    #[arg(last = true)]\n    slop: Vec<String>,\n}\n\nfn main() {\n    let args = Cli::parse();\n\n    // This is what will happen with `myprog -f -p=bob -- sloppy slop slop`...\n    println!(\"-f used: {:?}\", args.eff); // -f used: true\n    println!(\"-p's value: {:?}\", args.pea); // -p's value: Some(\"bob\")\n    println!(\"'slops' values: {:?}\", args.slop); // 'slops' values: Some([\"sloppy\", \"slop\", \"slop\"])\n\n    // Continued program logic goes here...\n}\n```\n\n**This requires enabling the [`derive` feature flag][crate::_features].**\n\nYou can use `--` to escape further arguments.\n\nLet's see what this looks like in the help:\n```console\n$ escaped-positional-derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: escaped-positional-derive[EXE] [OPTIONS] [-- <SLOP>...]\n\nArguments:\n  [SLOP]...  \n\nOptions:\n  -f             \n  -p <PEAR>      \n  -h, --help     Print help\n  -V, --version  Print version\n\n```\n\nHere is a baseline without any arguments:\n```console\n$ escaped-positional-derive\n-f used: false\n-p's value: None\n'slops' values: []\n\n```\n\nNotice that we can't pass positional arguments before `--`:\n```console\n$ escaped-positional-derive foo bar\n? failed\nerror: unexpected argument 'foo' found\n\nUsage: escaped-positional-derive[EXE] [OPTIONS] [-- <SLOP>...]\n\nFor more information, try '--help'.\n\n```\n\nBut you can after:\n```console\n$ escaped-positional-derive -f -p=bob -- sloppy slop slop\n-f used: true\n-p's value: Some(\"bob\")\n'slops' values: [\"sloppy\", \"slop\", \"slop\"]\n\n```\n\nAs mentioned, the parser will directly pass everything through:\n```console\n$ escaped-positional-derive -- -f -p=bob sloppy slop slop\n-f used: false\n-p's value: None\n'slops' values: [\"-f\", \"-p=bob\", \"sloppy\", \"slop\", \"slop\"]\n\n```","links":{"crate::_features":"0:24:1712"},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12131:28317":{"id":"2:12131:28317","crate_id":2,"name":"as_ascii","span":null,"visibility":"public","docs":"If this string slice [`is_ascii`](Self::is_ascii), returns it as a slice\nof [ASCII characters](`ascii::Char`), otherwise returns `None`.","links":{"`ascii::Char`":"2:39552:28312","Self::is_ascii":"2:12130:27697"},"attrs":["#[unstable(feature = \"ascii_char\", issue = \"110998\")]","#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"slice":{"resolved_path":{"name":"AsciiChar","id":"2:39552:28312","args":{"angle_bracketed":{"args":[],"bindings":[]}}}}}}}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:21:1713":{"id":"0:21:1713","crate_id":0,"name":"_tutorial","span":{"filename":"src/_derive/_tutorial.rs","begin":[10,0],"end":[229,7]},"visibility":"public","docs":"# Documentation: Derive Tutorial\n\n1. [Quick Start](#quick-start)\n2. [Configuring the Parser](#configuring-the-parser)\n3. [Adding Arguments](#adding-arguments)\n    1. [Positionals](#positionals)\n    2. [Options](#options)\n    3. [Flags](#flags)\n    4. [Subcommands](#subcommands)\n    5. [Defaults](#defaults)\n4. Validation\n    1. [Enumerated values](#enumerated-values)\n    2. [Validated values](#validated-values)\n    3. [Argument Relations](#argument-relations)\n    4. [Custom Validation](#custom-validation)\n5. [Testing](#testing)\n\nSee also\n- [FAQ: When should I use the builder vs derive APIs?][crate::_faq#when-should-i-use-the-builder-vs-derive-apis]\n- The [cookbook][crate::_cookbook] for more application-focused examples\n\n## Quick Start\n\nYou can create an application declaratively with a `struct` and some\nattributes.  **This requires enabling the [`derive` feature flag][crate::_features].**\n\n```rust\nuse std::path::PathBuf;\n\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    /// Optional name to operate on\n    name: Option<String>,\n\n    /// Sets a custom config file\n    #[arg(short, long, value_name = \"FILE\")]\n    config: Option<PathBuf>,\n\n    /// Turn debugging information on\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    debug: u8,\n\n    #[command(subcommand)]\n    command: Option<Commands>,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// does testing things\n    Test {\n        /// lists test values\n        #[arg(short, long)]\n        list: bool,\n    },\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // You can check the value provided by positional arguments, or option arguments\n    if let Some(name) = cli.name.as_deref() {\n        println!(\"Value for name: {name}\");\n    }\n\n    if let Some(config_path) = cli.config.as_deref() {\n        println!(\"Value for config: {}\", config_path.display());\n    }\n\n    // You can see how many times a particular flag or argument occurred\n    // Note, only flags can have multiple occurrences\n    match cli.debug {\n        0 => println!(\"Debug mode is off\"),\n        1 => println!(\"Debug mode is kind of on\"),\n        2 => println!(\"Debug mode is on\"),\n        _ => println!(\"Don't be crazy\"),\n    }\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match &cli.command {\n        Some(Commands::Test { list }) => {\n            if *list {\n                println!(\"Printing testing lists...\");\n            } else {\n                println!(\"Not printing testing lists...\");\n            }\n        }\n        None => {}\n    }\n\n    // Continued program logic goes here...\n}\n```\n\n```console\n$ 01_quick_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 01_quick_derive[EXE] [OPTIONS] [NAME] [COMMAND]\n\nCommands:\n  test  does testing things\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  [NAME]  Optional name to operate on\n\nOptions:\n  -c, --config <FILE>  Sets a custom config file\n  -d, --debug...       Turn debugging information on\n  -h, --help           Print help\n  -V, --version        Print version\n\n```\n\nBy default, the program does nothing:\n```console\n$ 01_quick_derive\nDebug mode is off\n\n```\n\nBut you can mix and match the various features\n```console\n$ 01_quick_derive -dd test\nDebug mode is on\nNot printing testing lists...\n\n```\n\n## Configuring the Parser\n\nYou use derive [`Parser`][crate::Parser] to start building a parser.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(name = \"MyApp\")]\n#[command(author = \"Kevin K. <kbknapp@gmail.com>\")]\n#[command(version = \"1.0\")]\n#[command(about = \"Does awesome things\", long_about = None)]\nstruct Cli {\n    #[arg(long)]\n    two: String,\n    #[arg(long)]\n    one: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"two: {:?}\", cli.two);\n    println!(\"one: {:?}\", cli.one);\n}\n```\n\n```console\n$ 02_apps_derive --help\nDoes awesome things\n\nUsage: 02_apps_derive[EXE] --two <TWO> --one <ONE>\n\nOptions:\n      --two <TWO>  \n      --one <ONE>  \n  -h, --help       Print help\n  -V, --version    Print version\n\n$ 02_apps_derive --version\nMyApp 1.0\n\n```\n\nYou can use `#[command(author, version, about)]` attribute defaults to fill these fields in from your `Cargo.toml` file.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)] // Read from `Cargo.toml`\nstruct Cli {\n    #[arg(long)]\n    two: String,\n    #[arg(long)]\n    one: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"two: {:?}\", cli.two);\n    println!(\"one: {:?}\", cli.one);\n}\n```\n```console\n$ 02_crate_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_crate_derive[EXE] --two <TWO> --one <ONE>\n\nOptions:\n      --two <TWO>  \n      --one <ONE>  \n  -h, --help       Print help\n  -V, --version    Print version\n\n$ 02_crate_derive --version\nclap [..]\n\n```\n\nYou can use attributes to change the application level behavior of clap.  Any [`Command`][crate::Command] builder function can be used as an attribute.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\n#[command(next_line_help = true)]\nstruct Cli {\n    #[arg(long)]\n    two: String,\n    #[arg(long)]\n    one: String,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"two: {:?}\", cli.two);\n    println!(\"one: {:?}\", cli.one);\n}\n```\n```console\n$ 02_app_settings_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_app_settings_derive[EXE] --two <TWO> --one <ONE>\n\nOptions:\n      --two <TWO>\n          \n      --one <ONE>\n          \n  -h, --help\n          Print help\n  -V, --version\n          Print version\n\n```\n\n## Adding Arguments\n\n### Positionals\n\nYou can have users specify values by their position on the command-line:\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    name: Option<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name.as_deref());\n}\n```\n```console\n$ 03_03_positional_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional_derive[EXE] [NAME]\n\nArguments:\n  [NAME]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional_derive\nname: None\n\n$ 03_03_positional_derive bob\nname: Some(\"bob\")\n\n```\n\nNote that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To\naccept multiple values, use [`Append`][crate::ArgAction::Append] via `Vec`:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    name: Vec<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name);\n}\n```\n```console\n$ 03_03_positional_mult_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional_mult_derive[EXE] [NAME]...\n\nArguments:\n  [NAME]...  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional_mult_derive\nname: []\n\n$ 03_03_positional_mult_derive bob\nname: [\"bob\"]\n\n$ 03_03_positional_mult_derive bob john\nname: [\"bob\", \"john\"]\n\n```\n\n### Options\n\nYou can name your arguments with a flag:\n- Order doesn't matter\n- They can be optional\n- Intent is clearer\n\nThe `#[arg(short = 'n')]` and `#[arg(long = \"name\")]` attributes that define\nthe flags are [`Arg`][crate::Args] methods that are derived from the field name when no value\nis specified (`#[arg(short)]` and `#[arg(long)]`).\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long)]\n    name: Option<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name.as_deref());\n}\n```\n```console\n$ 03_02_option_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option_derive[EXE] [OPTIONS]\n\nOptions:\n  -n, --name <NAME>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option_derive\nname: None\n\n$ 03_02_option_derive --name bob\nname: Some(\"bob\")\n\n$ 03_02_option_derive --name=bob\nname: Some(\"bob\")\n\n$ 03_02_option_derive -n bob\nname: Some(\"bob\")\n\n$ 03_02_option_derive -n=bob\nname: Some(\"bob\")\n\n$ 03_02_option_derive -nbob\nname: Some(\"bob\")\n\n```\n\nNote that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To\naccept multiple occurrences, use [`Append`][crate::ArgAction::Append] via `Vec`:\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long)]\n    name: Vec<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"name: {:?}\", cli.name);\n}\n```\n```console\n$ 03_02_option_mult_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option_mult_derive[EXE] [OPTIONS]\n\nOptions:\n  -n, --name <NAME>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option_mult_derive\nname: []\n\n$ 03_02_option_mult_derive --name bob\nname: [\"bob\"]\n\n$ 03_02_option_mult_derive --name=bob\nname: [\"bob\"]\n\n$ 03_02_option_mult_derive -n bob\nname: [\"bob\"]\n\n$ 03_02_option_mult_derive -n=bob\nname: [\"bob\"]\n\n$ 03_02_option_mult_derive -nbob\nname: [\"bob\"]\n\n```\n\n### Flags\n\nFlags can also be switches that can be on/off.  This is enabled via the\n`#[arg(action = ArgAction::SetTrue)]` attribute though this is implied when the field is a\n`bool`.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long)]\n    verbose: bool,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"verbose: {:?}\", cli.verbose);\n}\n```\n```console\n$ 03_01_flag_bool_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_bool_derive[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose  \n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_01_flag_bool_derive\nverbose: false\n\n$ 03_01_flag_bool_derive --verbose\nverbose: true\n\n$ 03_01_flag_bool_derive --verbose --verbose\n? failed\nerror: the argument '--verbose' cannot be used multiple times\n\nUsage: 03_01_flag_bool_derive[EXE] [OPTIONS]\n\nFor more information, try '--help'.\n\n```\n\nNote that the default [`ArgAction`][crate::ArgAction] for a `bool` field is\n[`SetTrue`][crate::ArgAction::SetTrue].  To accept multiple flags, use\n[`Count`][crate::ArgAction::Count]:\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[arg(short, long, action = clap::ArgAction::Count)]\n    verbose: u8,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"verbose: {:?}\", cli.verbose);\n}\n```\n```console\n$ 03_01_flag_count_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_count_derive[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose...  \n  -h, --help        Print help\n  -V, --version     Print version\n\n$ 03_01_flag_count_derive\nverbose: 0\n\n$ 03_01_flag_count_derive --verbose\nverbose: 1\n\n$ 03_01_flag_count_derive --verbose --verbose\nverbose: 2\n\n```\n\n### Subcommands\n\nSubcommands are derived with `#[derive(Subcommand)]` and be added via `#[command(subcommand)]` attribute. Each\ninstance of a [Subcommand][crate::Subcommand] can have its own version, author(s), Args, and even its own\nsubcommands.\n\n```rust\nuse clap::{Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\n#[command(propagate_version = true)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Adds files to myapp\n    Add { name: Option<String> },\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match &cli.command {\n        Commands::Add { name } => {\n            println!(\"'myapp add' was used, name is: {name:?}\")\n        }\n    }\n}\n```\nWe used a struct-variant to define the `add` subcommand.\nAlternatively, you can use a struct for your subcommand's arguments:\n```rust\nuse clap::{Args, Parser, Subcommand};\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\n#[command(propagate_version = true)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Subcommand)]\nenum Commands {\n    /// Adds files to myapp\n    Add(AddArgs),\n}\n\n#[derive(Args)]\nstruct AddArgs {\n    name: Option<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    match &cli.command {\n        Commands::Add(name) => {\n            println!(\"'myapp add' was used, name is: {:?}\", name.name)\n        }\n    }\n}\n```\n\n```console\n$ 03_04_subcommands_derive help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands_derive[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands_derive help add\nAdds files to myapp\n\nUsage: 03_04_subcommands_derive[EXE] add [NAME]\n\nArguments:\n  [NAME]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands_derive add bob\n'myapp add' was used, name is: Some(\"bob\")\n\n```\n\nBecause we used `command: Commands` instead of `command: Option<Commands>`:\n```console\n$ 03_04_subcommands_derive\n? failed\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands_derive[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n```\n\nBecause we added `#[command(propagate_version = true)]`:\n```console\n$ 03_04_subcommands_derive --version\nclap [..]\n\n$ 03_04_subcommands_derive add --version\nclap-add [..]\n\n```\n\n### Defaults\n\nWe've previously showed that arguments can be [`required`][crate::Arg::required] or optional.\nWhen optional, you work with a `Option` and can `unwrap_or`.  Alternatively, you can\nset `#[arg(default_value_t)]`.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[arg(default_value_t = 2020)]\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"port: {:?}\", cli.port);\n}\n```\n```console\n$ 03_05_default_values_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_05_default_values_derive[EXE] [PORT]\n\nArguments:\n  [PORT]  [default: 2020]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_05_default_values_derive\nport: 2020\n\n$ 03_05_default_values_derive 22\nport: 22\n\n```\n\n## Validation\n\nAn appropriate default parser/validator will be selected for the field's type.  See\n[`value_parser!`][crate::value_parser!] for more details.\n\n### Enumerated values\n\nFor example, if you have arguments of specific values you want to test for, you can derive\n[`ValueEnum`][crate::ValueEnum].\n\nThis allows you specify the valid values for that argument. If the user does not use one of\nthose specific values, they will receive a graceful exit with error message informing them\nof the mistake, and what the possible valid values are\n\n```rust\nuse clap::{Parser, ValueEnum};\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    /// What mode to run the program in\n    #[arg(value_enum)]\n    mode: Mode,\n}\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, ValueEnum)]\nenum Mode {\n    /// Run swiftly\n    Fast,\n    /// Crawl slowly but steadily\n    ///\n    /// This paragraph is ignored because there is no long help text for possible values.\n    Slow,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    match cli.mode {\n        Mode::Fast => {\n            println!(\"Hare\");\n        }\n        Mode::Slow => {\n            println!(\"Tortoise\");\n        }\n    }\n}\n```\n```console\n$ 04_01_enum_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum_derive[EXE] <MODE>\n\nArguments:\n  <MODE>\n          What mode to run the program in\n\n          Possible values:\n          - fast: Run swiftly\n          - slow: Crawl slowly but steadily\n\nOptions:\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n\n$ 04_01_enum_derive -h\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum_derive[EXE] <MODE>\n\nArguments:\n  <MODE>  What mode to run the program in [possible values: fast, slow]\n\nOptions:\n  -h, --help     Print help (see more with '--help')\n  -V, --version  Print version\n\n$ 04_01_enum_derive fast\nHare\n\n$ 04_01_enum_derive slow\nTortoise\n\n$ 04_01_enum_derive medium\n? failed\nerror: invalid value 'medium' for '<MODE>'\n  [possible values: fast, slow]\n\nFor more information, try '--help'.\n\n```\n\n### Validated values\n\nMore generally, you can validate and parse into any data type.\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    /// Network port to use\n    #[arg(value_parser = clap::value_parser!(u16).range(1..))]\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"PORT = {}\", cli.port);\n}\n```\n```console\n$ 04_02_parse_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_parse_derive[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_parse_derive 22\nPORT = 22\n\n$ 04_02_parse_derive foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': invalid digit found in string\n\nFor more information, try '--help'.\n\n$ 04_02_parse_derive 0\n? failed\nerror: invalid value '0' for '<PORT>': 0 is not in 1..=65535\n\nFor more information, try '--help'.\n\n```\n\nA custom parser can be used to improve the error messages or provide additional validation:\n\n```rust\nuse std::ops::RangeInclusive;\n\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    /// Network port to use\n    #[arg(value_parser = port_in_range)]\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"PORT = {}\", cli.port);\n}\n\nconst PORT_RANGE: RangeInclusive<usize> = 1..=65535;\n\nfn port_in_range(s: &str) -> Result<u16, String> {\n    let port: usize = s\n        .parse()\n        .map_err(|_| format!(\"`{s}` isn't a port number\"))?;\n    if PORT_RANGE.contains(&port) {\n        Ok(port as u16)\n    } else {\n        Err(format!(\n            \"port not in range {}-{}\",\n            PORT_RANGE.start(),\n            PORT_RANGE.end()\n        ))\n    }\n}\n```\n```console\n$ 04_02_validate_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_validate_derive[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_validate_derive 22\nPORT = 22\n\n$ 04_02_validate_derive foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': `foobar` isn't a port number\n\nFor more information, try '--help'.\n\n$ 04_02_validate_derive 0\n? failed\nerror: invalid value '0' for '<PORT>': port not in range 1-65535\n\nFor more information, try '--help'.\n\n```\n\nSee [`Arg::value_parser`][crate::Arg::value_parser] for more details.\n\n### Argument Relations\n\nYou can declare dependencies or conflicts between [`Arg`][crate::Arg]s or even\n[`ArgGroup`][crate::ArgGroup]s.\n\n[`ArgGroup`][crate::ArgGroup]s  make it easier to declare relations instead of having to list\neach individually, or when you want a rule to apply \"any but not all\" arguments.\n\nPerhaps the most common use of [`ArgGroup`][crate::ArgGroup]s is to require one and *only* one\nargument to be present out of a given set. Imagine that you had multiple arguments, and you\nwant one of them to be required, but making all of them required isn't feasible because perhaps\nthey conflict with each other.\n\n[`ArgGroup`][crate::ArgGroup]s are automatically created for a `struct` with its\n[`ArgGroup::id`][crate::ArgGroup::id] being the struct's name.\n\n```rust\nuse clap::{Args, Parser};\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    #[command(flatten)]\n    vers: Vers,\n\n    /// some regular input\n    #[arg(group = \"input\")]\n    input_file: Option<String>,\n\n    /// some special input argument\n    #[arg(long, group = \"input\")]\n    spec_in: Option<String>,\n\n    #[arg(short, requires = \"input\")]\n    config: Option<String>,\n}\n\n#[derive(Args)]\n#[group(required = true, multiple = false)]\nstruct Vers {\n    /// set version manually\n    #[arg(long, value_name = \"VER\")]\n    set_ver: Option<String>,\n\n    /// auto inc major\n    #[arg(long)]\n    major: bool,\n\n    /// auto inc minor\n    #[arg(long)]\n    minor: bool,\n\n    /// auto inc patch\n    #[arg(long)]\n    patch: bool,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set_ver was used to set the version manually\n    let vers = &cli.vers;\n    let version = if let Some(ver) = vers.set_ver.as_deref() {\n        ver.to_string()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (vers.major, vers.minor, vers.patch);\n        match (maj, min, pat) {\n            (true, _, _) => major += 1,\n            (_, true, _) => minor += 1,\n            (_, _, true) => patch += 1,\n            _ => unreachable!(),\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if let Some(config) = cli.config.as_deref() {\n        let input = cli\n            .input_file\n            .as_deref()\n            .unwrap_or_else(|| cli.spec_in.as_deref().unwrap());\n        println!(\"Doing work using input {input} and config {config}\");\n    }\n}\n```\n```console\n$ 04_03_relations_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_03_relations_derive[EXE] [OPTIONS] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_03_relations_derive\n? failed\nerror: the following required arguments were not provided:\n  <--set-ver <VER>|--major|--minor|--patch>\n\nUsage: 04_03_relations_derive[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations_derive --major\nVersion: 2.2.3\n\n$ 04_03_relations_derive --major --minor\n? failed\nerror: the argument '--major' cannot be used with '--minor'\n\nUsage: 04_03_relations_derive[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations_derive --major -c config.toml\n? failed\nerror: the following required arguments were not provided:\n  <INPUT_FILE|--spec-in <SPEC_IN>>\n\nUsage: 04_03_relations_derive[EXE] -c <CONFIG> <--set-ver <VER>|--major|--minor|--patch> <INPUT_FILE|--spec-in <SPEC_IN>>\n\nFor more information, try '--help'.\n\n$ 04_03_relations_derive --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n### Custom Validation\n\nAs a last resort, you can create custom errors with the basics of clap's formatting.\n\n```rust\nuse clap::error::ErrorKind;\nuse clap::{CommandFactory, Parser};\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    /// set version manually\n    #[arg(long, value_name = \"VER\")]\n    set_ver: Option<String>,\n\n    /// auto inc major\n    #[arg(long)]\n    major: bool,\n\n    /// auto inc minor\n    #[arg(long)]\n    minor: bool,\n\n    /// auto inc patch\n    #[arg(long)]\n    patch: bool,\n\n    /// some regular input\n    input_file: Option<String>,\n\n    /// some special input argument\n    #[arg(long)]\n    spec_in: Option<String>,\n\n    #[arg(short)]\n    config: Option<String>,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set-ver was used to set the version manually\n    let version = if let Some(ver) = cli.set_ver.as_deref() {\n        if cli.major || cli.minor || cli.patch {\n            let mut cmd = Cli::command();\n            cmd.error(\n                ErrorKind::ArgumentConflict,\n                \"Can't do relative and absolute version change\",\n            )\n            .exit();\n        }\n        ver.to_string()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (cli.major, cli.minor, cli.patch);\n        match (maj, min, pat) {\n            (true, false, false) => major += 1,\n            (false, true, false) => minor += 1,\n            (false, false, true) => patch += 1,\n            _ => {\n                let mut cmd = Cli::command();\n                cmd.error(\n                    ErrorKind::ArgumentConflict,\n                    \"Can only modify one version field\",\n                )\n                .exit();\n            }\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if let Some(config) = cli.config.as_deref() {\n        let input = cli\n            .input_file\n            .as_deref()\n            // 'or' is preferred to 'or_else' here since `Option::as_deref` is 'const'\n            .or(cli.spec_in.as_deref())\n            .unwrap_or_else(|| {\n                let mut cmd = Cli::command();\n                cmd.error(\n                    ErrorKind::MissingRequiredArgument,\n                    \"INPUT_FILE or --spec-in is required when using --config\",\n                )\n                .exit()\n            });\n        println!(\"Doing work using input {input} and config {config}\");\n    }\n}\n```\n```console\n$ 04_04_custom_derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_04_custom_derive[EXE] [OPTIONS] [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_04_custom_derive\n? failed\nerror: Can only modify one version field\n\nUsage: clap [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom_derive --major\nVersion: 2.2.3\n\n$ 04_04_custom_derive --major --minor\n? failed\nerror: Can only modify one version field\n\nUsage: clap [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom_derive --major -c config.toml\n? failed\nVersion: 2.2.3\nerror: INPUT_FILE or --spec-in is required when using --config\n\nUsage: clap [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom_derive --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n## Testing\n\nclap reports most development errors as `debug_assert!`s.  Rather than checking every\nsubcommand, you should have a test that calls\n[`Command::debug_assert`][crate::Command::debug_assert]:\n```rust,no_run\nuse clap::Parser;\n\n#[derive(Parser)]\n#[command(author, version, about, long_about = None)]\nstruct Cli {\n    /// Network port to use\n    port: u16,\n}\n\nfn main() {\n    let cli = Cli::parse();\n\n    println!(\"PORT = {}\", cli.port);\n}\n\n#[test]\nfn verify_cli() {\n    use clap::CommandFactory;\n    Cli::command().debug_assert()\n}\n```","links":{"crate::value_parser!":"20:1483:2671","crate::ArgAction::SetTrue":"20:2932:3058","crate::Args":"20:64:2659","crate::ArgAction::Count":"20:2936:110","crate::_features":"0:24:1712","crate::ArgGroup":"20:3364:2655","crate::ValueEnum":"20:72:2664","crate::_cookbook":"0:7:1709","crate::_faq#when-should-i-use-the-builder-vs-derive-apis":"0:23:1711","crate::Parser":"20:41:2662","crate::ArgAction":"20:2927:2651","crate::ArgAction::Set":"20:2928:3056","crate::ArgAction::Append":"20:2930:3057","crate::Command":"20:3650:2652","crate::Subcommand":"20:68:2663","crate::Arg::required":"20:175:3029","crate::Arg":"20:3326:2654","crate::Command::debug_assert":"20:425:2603","crate::ArgGroup::id":"20:338:3007","crate::Arg::value_parser":"20:186:2671"},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12132:27698":{"id":"2:12132:27698","crate_id":2,"name":"eq_ignore_ascii_case","span":null,"visibility":"public","docs":"Checks that two strings are an ASCII case-insensitive match.\n\nSame as `to_ascii_lowercase(a) == to_ascii_lowercase(b)`,\nbut without allocating and copying temporaries.\n\n# Examples\n\n```\nassert!(\"Ferris\".eq_ignore_ascii_case(\"FERRIS\"));\nassert!(\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√∂S\"));\nassert!(!\"Ferr√∂s\".eq_ignore_ascii_case(\"FERR√ñS\"));\n```","links":{},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["other",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}}]],"output":{"primitive":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12072:35635":{"id":"2:12072:35635","crate_id":2,"name":"rsplit_terminator","span":null,"visibility":"public","docs":"An iterator over substrings of `self`, separated by characters\nmatched by a pattern and yielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\nEquivalent to [`split`], except that the trailing substring is\nskipped if empty.\n\n[`split`]: str::split\n\nThis method can be used for string data that is _terminated_,\nrather than _separated_ by a pattern.\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a\nreverse search, and it will be double ended if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`split_terminator`] method can be\nused.\n\n[`split_terminator`]: str::split_terminator\n\n# Examples\n\n```\nlet v: Vec<&str> = \"A.B.\".rsplit_terminator('.').collect();\nassert_eq!(v, [\"B\", \"A\"]);\n\nlet v: Vec<&str> = \"A..B..\".rsplit_terminator(\".\").collect();\nassert_eq!(v, [\"\", \"B\", \"\", \"A\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".rsplit_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"D\", \"C\", \"B\", \"A\"]);\n```","links":{"self::pattern":"2:11712:8907","str::split":"2:12060:26737","prim@char":"1:11888:419","str::split_terminator":"2:12069:35634"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"RSplitTerminator","id":"2:43425:8926","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12016:35629":{"id":"2:12016:35629","crate_id":2,"name":"ceil_char_boundary","span":null,"visibility":"public","docs":"Finds the closest `x` not below `index` where `is_char_boundary(x)` is `true`.\n\nThis method is the natural complement to [`floor_char_boundary`]. See that method\nfor more details.\n\n[`floor_char_boundary`]: str::floor_char_boundary\n\n# Panics\n\nPanics if `index > self.len()`.\n\n# Examples\n\n```\n#![feature(round_char_boundary)]\nlet s = \"‚ù§Ô∏èüß°üíõüíöüíôüíú\";\nassert_eq!(s.len(), 26);\nassert!(!s.is_char_boundary(13));\n\nlet closest = s.ceil_char_boundary(13);\nassert_eq!(closest, 14);\nassert_eq!(&s[..closest], \"‚ù§Ô∏èüß°üíõ\");\n```","links":{"str::floor_char_boundary":"2:12014:35628"},"attrs":["#[unstable(feature = \"round_char_boundary\", issue = \"93743\")]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["index",{"primitive":"usize"}]],"output":{"primitive":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12032:35632":{"id":"2:12032:35632","crate_id":2,"name":"slice_mut_unchecked","span":null,"visibility":"public","docs":"Creates a string slice from another string slice, bypassing safety\nchecks.\nThis is generally not recommended, use with caution! For a safe\nalternative see [`str`] and [`IndexMut`].\n\n[`IndexMut`]: crate::ops::IndexMut\n\nThis new slice goes from `begin` to `end`, including `begin` but\nexcluding `end`.\n\nTo get an immutable string slice instead, see the\n[`slice_unchecked`] method.\n\n[`slice_unchecked`]: str::slice_unchecked\n\n# Safety\n\nCallers of this function are responsible that three preconditions are\nsatisfied:\n\n* `begin` must not exceed `end`.\n* `begin` and `end` must be byte positions within the string slice.\n* `begin` and `end` must lie on UTF-8 sequence boundaries.","links":{"`str`":"1:11894:1397","crate::ops::IndexMut":"2:2985:3247","str::slice_unchecked":"2:12031:35631"},"attrs":["#[deprecated(since = \"1.29.0\", note =\n\"use `get_unchecked_mut(begin..end)` instead\")]"],"deprecation":{"since":"1.29.0","note":"use `get_unchecked_mut(begin..end)` instead"},"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}],["begin",{"primitive":"usize"}],["end",{"primitive":"usize"}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}}},"2:12019:28313":{"id":"2:12019:28313","crate_id":2,"name":"as_bytes","span":null,"visibility":"public","docs":"Converts a string slice to a byte slice. To convert the byte slice back\ninto a string slice, use the [`from_utf8`] function.\n\n# Examples\n\nBasic usage:\n\n```\nlet bytes = \"bors\".as_bytes();\nassert_eq!(b\"bors\", bytes);\n```","links":{"`from_utf8`":"2:11279:8911"},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"slice":{"primitive":"u8"}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5382":{"id":"5:5382","crate_id":5,"name":null,"span":null,"visibility":"default","docs":"Methods for string slices.","links":{},"attrs":["#[cfg(not(test))]"],"deprecation":null,"inner":{"impl":{"is_unsafe":false,"generics":{"params":[],"where_predicates":[]},"provided_trait_methods":[],"trait":null,"for":{"primitive":"str"},"items":["5:5383:36304","5:5384:9251","5:5387:36305","5:5390:36306","5:5398:36307","5:5399:36308","5:5400:3386","5:5401:27696","5:5402:27695"],"negative":false,"synthetic":false,"blanket_impl":null}}},"2:12101:35642":{"id":"2:12101:35642","crate_id":2,"name":"trim_start","span":null,"visibility":"public","docs":"Returns a string slice with leading whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`, which includes newlines.\n\n# Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\nassert_eq!(\"Hello\\tworld\\t\\n\", s.trim_start());\n```\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('E') == s.trim_start().chars().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊¢') == s.trim_start().chars().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[rustc_diagnostic_item = \"str_trim_start\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5399:36308":{"id":"5:5399:36308","crate_id":5,"name":"into_string","span":null,"visibility":"public","docs":"Converts a [`Box<str>`] into a [`String`] without copying or allocating.\n\n# Examples\n\nBasic usage:\n\n```\nlet string = String::from(\"birthday gift\");\nlet boxed_str = string.clone().into_boxed_str();\n\nassert_eq!(boxed_str.into_string(), string);\n```","links":{"`Box<str>`":"5:280:2682","`String`":"5:7241:224"},"attrs":["#[must_use = \"`self` will be dropped if the result is not used\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"resolved_path":{"name":"Box","id":"5:280:2682","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}},{"type":{"resolved_path":{"name":"Global","id":"5:6990:3236","args":{"angle_bracketed":{"args":[],"bindings":[]}}}}}],"bindings":[]}}}}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12133:27694":{"id":"2:12133:27694","crate_id":2,"name":"make_ascii_uppercase","span":null,"visibility":"public","docs":"Converts this string to its ASCII upper case equivalent in-place.\n\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.\n\nTo return a new uppercased value without modifying the existing one, use\n[`to_ascii_uppercase()`].\n\n[`to_ascii_uppercase()`]: #method.to_ascii_uppercase\n\n# Examples\n\n```\nlet mut s = String::from(\"Gr√º√üe, J√ºrgen ‚ù§\");\n\ns.make_ascii_uppercase();\n\nassert_eq!(\"GR√º√üE, J√ºRGEN ‚ù§\", s);\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}]],"output":null,"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:10:1846":{"id":"0:10:1846","crate_id":0,"name":"escaped_positional","span":{"filename":"src/_cookbook/escaped_positional.rs","begin":[1,0],"end":[7,62]},"visibility":"public","docs":"# Example (Builder API)\n\n```rust\nuse clap::{arg, command, value_parser, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(arg!(eff: -f).action(ArgAction::SetTrue))\n        .arg(arg!(pea: -p <PEAR>).value_parser(value_parser!(String)))\n        .arg(\n            // Indicates that `slop` is only accessible after `--`.\n            arg!(slop: [SLOP])\n                .num_args(1..)\n                .last(true)\n                .value_parser(value_parser!(String)),\n        )\n        .get_matches();\n\n    // This is what will happen with `myprog -f -p=bob -- sloppy slop slop`...\n\n    // -f used: true\n    println!(\"-f used: {:?}\", matches.get_flag(\"eff\"));\n    // -p's value: Some(\"bob\")\n    println!(\"-p's value: {:?}\", matches.get_one::<String>(\"pea\"));\n    // 'slops' values: Some([\"sloppy\", \"slop\", \"slop\"])\n    println!(\n        \"'slops' values: {:?}\",\n        matches\n            .get_many::<String>(\"slop\")\n            .map(|vals| vals.collect::<Vec<_>>())\n            .unwrap_or_default()\n    );\n\n    // Continued program logic goes here...\n}\n```\n\n**This requires enabling the [`cargo` feature flag][crate::_features].**\n\nYou can use `--` to escape further arguments.\n\nLet's see what this looks like in the help:\n```console\n$ escaped-positional --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: escaped-positional[EXE] [OPTIONS] [-- <SLOP>...]\n\nArguments:\n  [SLOP]...  \n\nOptions:\n  -f             \n  -p <PEAR>      \n  -h, --help     Print help\n  -V, --version  Print version\n\n```\n\nHere is a baseline without any arguments:\n```console\n$ escaped-positional\n-f used: false\n-p's value: None\n'slops' values: []\n\n```\n\nNotice that we can't pass positional arguments before `--`:\n```console\n$ escaped-positional foo bar\n? failed\nerror: unexpected argument 'foo' found\n\nUsage: escaped-positional[EXE] [OPTIONS] [-- <SLOP>...]\n\nFor more information, try '--help'.\n\n```\n\nBut you can after:\n```console\n$ escaped-positional -f -p=bob -- sloppy slop slop\n-f used: true\n-p's value: Some(\"bob\")\n'slops' values: [\"sloppy\", \"slop\", \"slop\"]\n\n```\n\nAs mentioned, the parser will directly pass everything through:\n```console\n$ escaped-positional -- -f -p=bob sloppy slop slop\n-f used: false\n-p's value: None\n'slops' values: [\"-f\", \"-p=bob\", \"sloppy\", \"slop\", \"slop\"]\n\n```","links":{"crate::_features":"0:24:1712"},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"0:17:1853":{"id":"0:17:1853","crate_id":0,"name":"pacman","span":{"filename":"src/_cookbook/pacman.rs","begin":[1,0],"end":[7,50]},"visibility":"public","docs":"# Example: pacman-like CLI (Builder API)\n\n```rust\nuse clap::{Arg, ArgAction, Command};\n\nfn main() {\n    let matches = Command::new(\"pacman\")\n        .about(\"package manager utility\")\n        .version(\"5.2.1\")\n        .subcommand_required(true)\n        .arg_required_else_help(true)\n        .author(\"Pacman Development Team\")\n        // Query subcommand\n        //\n        // Only a few of its arguments are implemented below.\n        .subcommand(\n            Command::new(\"query\")\n                .short_flag('Q')\n                .long_flag(\"query\")\n                .about(\"Query the package database.\")\n                .arg(\n                    Arg::new(\"search\")\n                        .short('s')\n                        .long(\"search\")\n                        .help(\"search locally installed packages for matching strings\")\n                        .conflicts_with(\"info\")\n                        .action(ArgAction::Set)\n                        .num_args(1..),\n                )\n                .arg(\n                    Arg::new(\"info\")\n                        .long(\"info\")\n                        .short('i')\n                        .conflicts_with(\"search\")\n                        .help(\"view package information\")\n                        .action(ArgAction::Set)\n                        .num_args(1..),\n                ),\n        )\n        // Sync subcommand\n        //\n        // Only a few of its arguments are implemented below.\n        .subcommand(\n            Command::new(\"sync\")\n                .short_flag('S')\n                .long_flag(\"sync\")\n                .about(\"Synchronize packages.\")\n                .arg(\n                    Arg::new(\"search\")\n                        .short('s')\n                        .long(\"search\")\n                        .conflicts_with(\"info\")\n                        .action(ArgAction::Set)\n                        .num_args(1..)\n                        .help(\"search remote repositories for matching strings\"),\n                )\n                .arg(\n                    Arg::new(\"info\")\n                        .long(\"info\")\n                        .conflicts_with(\"search\")\n                        .short('i')\n                        .action(ArgAction::SetTrue)\n                        .help(\"view package information\"),\n                )\n                .arg(\n                    Arg::new(\"package\")\n                        .help(\"packages\")\n                        .required_unless_present(\"search\")\n                        .action(ArgAction::Set)\n                        .num_args(1..),\n                ),\n        )\n        .get_matches();\n\n    match matches.subcommand() {\n        Some((\"sync\", sync_matches)) => {\n            if sync_matches.contains_id(\"search\") {\n                let packages: Vec<_> = sync_matches\n                    .get_many::<String>(\"search\")\n                    .expect(\"contains_id\")\n                    .map(|s| s.as_str())\n                    .collect();\n                let values = packages.join(\", \");\n                println!(\"Searching for {values}...\");\n                return;\n            }\n\n            let packages: Vec<_> = sync_matches\n                .get_many::<String>(\"package\")\n                .expect(\"is present\")\n                .map(|s| s.as_str())\n                .collect();\n            let values = packages.join(\", \");\n\n            if sync_matches.get_flag(\"info\") {\n                println!(\"Retrieving info for {values}...\");\n            } else {\n                println!(\"Installing {values}...\");\n            }\n        }\n        Some((\"query\", query_matches)) => {\n            if let Some(packages) = query_matches.get_many::<String>(\"info\") {\n                let comma_sep = packages.map(|s| s.as_str()).collect::<Vec<_>>().join(\", \");\n                println!(\"Retrieving info for {comma_sep}...\");\n            } else if let Some(queries) = query_matches.get_many::<String>(\"search\") {\n                let comma_sep = queries.map(|s| s.as_str()).collect::<Vec<_>>().join(\", \");\n                println!(\"Searching Locally for {comma_sep}...\");\n            } else {\n                println!(\"Displaying all locally installed packages...\");\n            }\n        }\n        _ => unreachable!(), // If all subcommands are defined above, anything else is unreachable\n    }\n}\n```\n\n[`pacman`](https://wiki.archlinux.org/index.php/pacman) defines subcommands via flags.\n\nHere, `-S` is a short flag subcommand:\n```console\n$ pacman -S package\nInstalling package...\n\n```\n\nHere `--sync` is a long flag subcommand:\n```console\n$ pacman --sync package\nInstalling package...\n\n```\n\nNow the short flag subcommand (`-S`) with a long flag:\n```console\n$ pacman -S --search name\nSearching for name...\n\n```\n\nAnd the various forms of short flags that work:\n```console\n$ pacman -S -s name\nSearching for name...\n\n$ pacman -Ss name\nSearching for name...\n\n```\n*(users can \"stack\" short subcommands with short flags or with other short flag subcommands)*\n\nIn the help, this looks like:\n```console\n$ pacman -h\npackage manager utility\n\nUsage: pacman[EXE] <COMMAND>\n\nCommands:\n  query, -Q, --query  Query the package database.\n  sync, -S, --sync    Synchronize packages.\n  help                Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ pacman -S -h\nSynchronize packages.\n\nUsage: pacman[EXE] {sync|--sync|-S} [OPTIONS] [package]...\n\nArguments:\n  [package]...  packages\n\nOptions:\n  -s, --search <search>...  search remote repositories for matching strings\n  -i, --info                view package information\n  -h, --help                Print help\n\n```\n\nAnd errors:\n```console\n$ pacman -S -s foo -i bar\n? failed\nerror: the argument '--search <search>...' cannot be used with '--info'\n\nUsage: pacman[EXE] {sync|--sync|-S} --search <search>... <package>...\n\nFor more information, try '--help'.\n\n```\n\n**NOTE:** Keep in mind that subcommands, flags, and long flags are *case sensitive*: `-Q` and `-q` are different flags/subcommands. For example, you can have both `-Q` subcommand and `-q` flag, and they will be properly disambiguated.\nLet's make a quick program to illustrate.","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12014:35628":{"id":"2:12014:35628","crate_id":2,"name":"floor_char_boundary","span":null,"visibility":"public","docs":"Finds the closest `x` not exceeding `index` where `is_char_boundary(x)` is `true`.\n\nThis method can help you truncate a string so that it's still valid UTF-8, but doesn't\nexceed a given number of bytes. Note that this is done purely at the character level\nand can still visually split graphemes, even though the underlying characters aren't\nsplit. For example, the emoji üßë‚Äçüî¨ (scientist) could be split so that the string only\nincludes üßë (person) instead.\n\n# Examples\n\n```\n#![feature(round_char_boundary)]\nlet s = \"‚ù§Ô∏èüß°üíõüíöüíôüíú\";\nassert_eq!(s.len(), 26);\nassert!(!s.is_char_boundary(13));\n\nlet closest = s.floor_char_boundary(13);\nassert_eq!(closest, 10);\nassert_eq!(&s[..closest], \"‚ù§Ô∏èüß°\");\n```","links":{},"attrs":["#[unstable(feature = \"round_char_boundary\", issue = \"93743\")]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["index",{"primitive":"usize"}]],"output":{"primitive":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12041:35633":{"id":"2:12041:35633","crate_id":2,"name":"lines_any","span":null,"visibility":"public","docs":"An iterator over the lines of a string.","links":{},"attrs":["#[deprecated(since = \"1.4.0\", note = \"use lines() instead now\")]"],"deprecation":{"since":"1.4.0","note":"use lines() instead now"},"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"LinesAny","id":"2:43621:8921","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12075:28458":{"id":"2:12075:28458","crate_id":2,"name":"splitn","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by a\npattern, restricted to returning at most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring)\nwill contain the remainder of the string.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will not be double ended, because it is\nnot efficient to support.\n\nIf the pattern allows a reverse search, the [`rsplitn`] method can be\nused.\n\n[`rsplitn`]: str::rsplitn\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lambda\".splitn(3, ' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".splitn(3, \"X\").collect();\nassert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n\nlet v: Vec<&str> = \"abcXdef\".splitn(1, 'X').collect();\nassert_eq!(v, [\"abcXdef\"]);\n\nlet v: Vec<&str> = \"\".splitn(1, 'X').collect();\nassert_eq!(v, [\"\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".splitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"defXghi\"]);\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907","str::rsplitn":"2:12078:28460"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["n",{"primitive":"usize"}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"SplitN","id":"2:43461:8896","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12078:28460":{"id":"2:12078:28460","crate_id":2,"name":"rsplitn","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by a\npattern, starting from the end of the string, restricted to returning\nat most `n` items.\n\nIf `n` substrings are returned, the last substring (the `n`th substring)\nwill contain the remainder of the string.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will not be double ended, because it is not\nefficient to support.\n\nFor splitting from the front, the [`splitn`] method can be used.\n\n[`splitn`]: str::splitn\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplitn(3, ' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(3, 'X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(2, \"::\").collect();\nassert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplitn(2, |c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"abc1def\"]);\n```","links":{"prim@char":"1:11888:419","str::splitn":"2:12075:28458","self::pattern":"2:11712:8907"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["n",{"primitive":"usize"}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"RSplitN","id":"2:43479:8894","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12013:35627":{"id":"2:12013:35627","crate_id":2,"name":"is_char_boundary","span":null,"visibility":"public","docs":"Checks that `index`-th byte is the first byte in a UTF-8 code point\nsequence or the end of the string.\n\nThe start and end of the string (when `index == self.len()`) are\nconsidered to be boundaries.\n\nReturns `false` if `index` is greater than `self.len()`.\n\n# Examples\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nassert!(s.is_char_boundary(0));\n// start of `ËÄÅ`\nassert!(s.is_char_boundary(6));\nassert!(s.is_char_boundary(s.len()));\n\n// second byte of `√∂`\nassert!(!s.is_char_boundary(2));\n\n// third byte of `ËÄÅ`\nassert!(!s.is_char_boundary(8));\n```","links":{},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["index",{"primitive":"usize"}]],"output":{"primitive":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12103:35643":{"id":"2:12103:35643","crate_id":2,"name":"trim_end","span":null,"visibility":"public","docs":"Returns a string slice with trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`, which includes newlines.\n\n# Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\nassert_eq!(\"\\n Hello\\tworld\", s.trim_end());\n```\n\nDirectionality:\n\n```\nlet s = \"  English  \";\nassert!(Some('h') == s.trim_end().chars().rev().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊™') == s.trim_end().chars().rev().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[rustc_diagnostic_item = \"str_trim_end\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12096:35640":{"id":"2:12096:35640","crate_id":2,"name":"rmatch_indices","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within `self`,\nyielded in reverse order along with the index of the match.\n\nFor matches of `pat` within `self` that overlap, only the indices\ncorresponding to the last match are returned.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`match_indices`] method can be used.\n\n[`match_indices`]: str::match_indices\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(12, \"abc\"), (6, \"abc\"), (0, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".rmatch_indices(\"abc\").collect();\nassert_eq!(v, [(4, \"abc\"), (1, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".rmatch_indices(\"aba\").collect();\nassert_eq!(v, [(2, \"aba\")]); // only the last `aba`\n```","links":{"self::pattern":"2:11712:8907","`DoubleEndedIterator`":"2:7240:121","prim@char":"1:11888:419","str::match_indices":"2:12093:35639"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"RMatchIndices","id":"2:43525:8923","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12105:35644":{"id":"2:12105:35644","crate_id":2,"name":"trim_left","span":null,"visibility":"public","docs":"Returns a string slice with leading whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. 'Left' in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _right_ side, not the left.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\"Hello\\tworld\\t\", s.trim_left());\n```\n\nDirectionality:\n\n```\nlet s = \"  English\";\nassert!(Some('E') == s.trim_left().chars().next());\n\nlet s = \"  ◊¢◊ë◊®◊ô◊™\";\nassert!(Some('◊¢') == s.trim_left().chars().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_start`\", suggestion\n= \"trim_start\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_start`"},"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12125:35650":{"id":"2:12125:35650","crate_id":2,"name":"trim_right_matches","span":null,"visibility":"public","docs":"Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. 'Right' in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _left_ side, not the right.\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_right_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_right_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_right_matches(x), \"12foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_right_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":["#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_end_matches`\",\nsuggestion = \"trim_end_matches\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_end_matches`"},"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5402:27695":{"id":"5:5402:27695","crate_id":5,"name":"to_ascii_lowercase","span":null,"visibility":"public","docs":"Returns a copy of this string where each character is mapped to its\nASCII lower case equivalent.\n\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.\n\nTo lowercase the value in-place, use [`make_ascii_lowercase`].\n\nTo lowercase ASCII characters in addition to non-ASCII characters, use\n[`to_lowercase`].\n\n# Examples\n\n```\nlet s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"gr√º√üe, j√ºrgen ‚ù§\", s.to_ascii_lowercase());\n```\n\n[`make_ascii_lowercase`]: str::make_ascii_lowercase\n[`to_lowercase`]: #method.to_lowercase","links":{"str::make_ascii_lowercase":"2:12134:27693"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use = \"to lowercase the value in-place, use `make_ascii_lowercase()`\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12069:35634":{"id":"2:12069:35634","crate_id":2,"name":"split_terminator","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\nEquivalent to [`split`], except that the trailing substring\nis skipped if empty.\n\n[`split`]: str::split\n\nThis method can be used for string data that is _terminated_,\nrather than _separated_ by a pattern.\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rsplit_terminator`] method can be used.\n\n[`rsplit_terminator`]: str::rsplit_terminator\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\nassert_eq!(v, [\"A\", \"B\"]);\n\nlet v: Vec<&str> = \"A..B..\".split_terminator(\".\").collect();\nassert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n\nlet v: Vec<&str> = \"A.B:C.D\".split_terminator(&['.', ':'][..]).collect();\nassert_eq!(v, [\"A\", \"B\", \"C\", \"D\"]);\n```","links":{"self::pattern":"2:11712:8907","str::split":"2:12060:26737","prim@char":"1:11888:419","`DoubleEndedIterator`":"2:7240:121","str::rsplit_terminator":"2:12072:35635"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"SplitTerminator","id":"2:43407:8927","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12043:28462":{"id":"2:12043:28462","crate_id":2,"name":"contains","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a sub-slice of\nthis string slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.contains(\"nana\"));\nassert!(!bananas.contains(\"apples\"));\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"primitive":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12010":{"id":"2:12010","crate_id":2,"name":null,"span":null,"visibility":"default","docs":null,"links":{},"attrs":["#[cfg(not(test))]"],"deprecation":null,"inner":{"impl":{"is_unsafe":false,"generics":{"params":[],"where_predicates":[]},"provided_trait_methods":[],"trait":null,"for":{"primitive":"str"},"items":["2:12011:811","2:12012:25960","2:12013:35627","2:12014:35628","2:12016:35629","2:12019:28313","2:12020:35630","2:12021:314","2:12022:28421","2:12023:28417","2:12025:28418","2:12027:28419","2:12029:28420","2:12031:35631","2:12032:35632","2:12033:28445","2:12034:28446","2:12035:33053","2:12036:33026","2:12037:24297","2:12038:33048","2:12039:33037","2:12040:26738","2:12041:35633","2:12042:33054","2:12043:28462","2:12046:27849","2:12049:27851","2:12052:1848","2:12056:20659","2:12060:26737","2:12063:28454","2:12066:28456","2:12069:35634","2:12072:35635","2:12075:28458","2:12078:28460","2:12081:35636","2:12084:35637","2:12087:2606","2:12090:35638","2:12093:35639","2:12096:35640","2:12099:35641","2:12101:35642","2:12103:35643","2:12105:35644","2:12106:35645","2:12107:35646","2:12110:35647","2:12113:25631","2:12116:28463","2:12119:35648","2:12122:35649","2:12125:35650","2:12128:35651","2:12130:27697","2:12131:28317","2:12132:27698","2:12133:27694","2:12134:27693","2:12135:35652","2:12137:3164","2:12138:35653"],"negative":false,"synthetic":false,"blanket_impl":null}}},"0:13:1849":{"id":"0:13:1849","crate_id":0,"name":"git","span":{"filename":"src/_cookbook/git.rs","begin":[1,0],"end":[7,47]},"visibility":"public","docs":"# Example: git-like CLI (Builder API)\n\n```rust\nuse std::ffi::OsString;\nuse std::path::PathBuf;\n\nuse clap::{arg, Command};\n\nfn cli() -> Command {\n    Command::new(\"git\")\n        .about(\"A fictional versioning CLI\")\n        .subcommand_required(true)\n        .arg_required_else_help(true)\n        .allow_external_subcommands(true)\n        .subcommand(\n            Command::new(\"clone\")\n                .about(\"Clones repos\")\n                .arg(arg!(<REMOTE> \"The remote to clone\"))\n                .arg_required_else_help(true),\n        )\n        .subcommand(\n            Command::new(\"diff\")\n                .about(\"Compare two commits\")\n                .arg(arg!(base: [COMMIT]))\n                .arg(arg!(head: [COMMIT]))\n                .arg(arg!(path: [PATH]).last(true))\n                .arg(\n                    arg!(--color <WHEN>)\n                        .value_parser([\"always\", \"auto\", \"never\"])\n                        .num_args(0..=1)\n                        .require_equals(true)\n                        .default_value(\"auto\")\n                        .default_missing_value(\"always\"),\n                ),\n        )\n        .subcommand(\n            Command::new(\"push\")\n                .about(\"pushes things\")\n                .arg(arg!(<REMOTE> \"The remote to target\"))\n                .arg_required_else_help(true),\n        )\n        .subcommand(\n            Command::new(\"add\")\n                .about(\"adds things\")\n                .arg_required_else_help(true)\n                .arg(arg!(<PATH> ... \"Stuff to add\").value_parser(clap::value_parser!(PathBuf))),\n        )\n        .subcommand(\n            Command::new(\"stash\")\n                .args_conflicts_with_subcommands(true)\n                .args(push_args())\n                .subcommand(Command::new(\"push\").args(push_args()))\n                .subcommand(Command::new(\"pop\").arg(arg!([STASH])))\n                .subcommand(Command::new(\"apply\").arg(arg!([STASH]))),\n        )\n}\n\nfn push_args() -> Vec<clap::Arg> {\n    vec![arg!(-m --message <MESSAGE>)]\n}\n\nfn main() {\n    let matches = cli().get_matches();\n\n    match matches.subcommand() {\n        Some((\"clone\", sub_matches)) => {\n            println!(\n                \"Cloning {}\",\n                sub_matches.get_one::<String>(\"REMOTE\").expect(\"required\")\n            );\n        }\n        Some((\"diff\", sub_matches)) => {\n            let color = sub_matches\n                .get_one::<String>(\"color\")\n                .map(|s| s.as_str())\n                .expect(\"defaulted in clap\");\n\n            let mut base = sub_matches.get_one::<String>(\"base\").map(|s| s.as_str());\n            let mut head = sub_matches.get_one::<String>(\"head\").map(|s| s.as_str());\n            let mut path = sub_matches.get_one::<String>(\"path\").map(|s| s.as_str());\n            if path.is_none() {\n                path = head;\n                head = None;\n                if path.is_none() {\n                    path = base;\n                    base = None;\n                }\n            }\n            let base = base.unwrap_or(\"stage\");\n            let head = head.unwrap_or(\"worktree\");\n            let path = path.unwrap_or(\"\");\n            println!(\"Diffing {base}..{head} {path} (color={color})\");\n        }\n        Some((\"push\", sub_matches)) => {\n            println!(\n                \"Pushing to {}\",\n                sub_matches.get_one::<String>(\"REMOTE\").expect(\"required\")\n            );\n        }\n        Some((\"add\", sub_matches)) => {\n            let paths = sub_matches\n                .get_many::<PathBuf>(\"PATH\")\n                .into_iter()\n                .flatten()\n                .collect::<Vec<_>>();\n            println!(\"Adding {paths:?}\");\n        }\n        Some((\"stash\", sub_matches)) => {\n            let stash_command = sub_matches.subcommand().unwrap_or((\"push\", sub_matches));\n            match stash_command {\n                (\"apply\", sub_matches) => {\n                    let stash = sub_matches.get_one::<String>(\"STASH\");\n                    println!(\"Applying {stash:?}\");\n                }\n                (\"pop\", sub_matches) => {\n                    let stash = sub_matches.get_one::<String>(\"STASH\");\n                    println!(\"Popping {stash:?}\");\n                }\n                (\"push\", sub_matches) => {\n                    let message = sub_matches.get_one::<String>(\"message\");\n                    println!(\"Pushing {message:?}\");\n                }\n                (name, _) => {\n                    unreachable!(\"Unsupported subcommand `{name}`\")\n                }\n            }\n        }\n        Some((ext, sub_matches)) => {\n            let args = sub_matches\n                .get_many::<OsString>(\"\")\n                .into_iter()\n                .flatten()\n                .collect::<Vec<_>>();\n            println!(\"Calling out to {ext:?} with {args:?}\");\n        }\n        _ => unreachable!(), // If all subcommands are defined above, anything else is unreachable!()\n    }\n\n    // Continued program logic goes here...\n}\n```\n\nGit is an example of several common subcommand patterns.\n\nHelp:\n```console\n$ git\n? failed\nA fictional versioning CLI\n\nUsage: git[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git help\nA fictional versioning CLI\n\nUsage: git[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git help add\nadds things\n\nUsage: git[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n```\n\nA basic argument:\n```console\n$ git add\n? failed\nadds things\n\nUsage: git[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n$ git add Cargo.toml Cargo.lock\nAdding [\"Cargo.toml\", \"Cargo.lock\"]\n\n```\n\nDefault subcommand:\n```console\n$ git stash -h\nUsage: git[EXE] stash [OPTIONS]\n       git[EXE] stash <COMMAND>\n\nCommands:\n  push   \n  pop    \n  apply  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\n$ git stash push -h\nUsage: git[EXE] stash push [OPTIONS]\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\n$ git stash pop -h\nUsage: git[EXE] stash pop [STASH]\n\nArguments:\n  [STASH]  \n\nOptions:\n  -h, --help  Print help\n\n$ git stash -m \"Prototype\"\nPushing Some(\"Prototype\")\n\n$ git stash pop\nPopping None\n\n$ git stash push -m \"Prototype\"\nPushing Some(\"Prototype\")\n\n$ git stash pop\nPopping None\n\n```\n\nExternal subcommands:\n```console\n$ git custom-tool arg1 --foo bar\nCalling out to \"custom-tool\" with [\"arg1\", \"--foo\", \"bar\"]\n\n```\n\nLast argument:\n```console\n$ git diff --help\nCompare two commits\n\nUsage: git[EXE] diff [OPTIONS] [COMMIT] [COMMIT] [-- <PATH>]\n\nArguments:\n  [COMMIT]  \n  [COMMIT]  \n  [PATH]    \n\nOptions:\n      --color[=<WHEN>]  [default: auto] [possible values: always, auto, never]\n  -h, --help            Print help\n\n$ git diff\nDiffing stage..worktree  (color=auto)\n\n$ git diff ./src\nDiffing stage..worktree ./src (color=auto)\n\n$ git diff HEAD ./src\nDiffing HEAD..worktree ./src (color=auto)\n\n$ git diff HEAD~~ -- HEAD\nDiffing HEAD~~..worktree HEAD (color=auto)\n\n$ git diff --color\nDiffing stage..worktree  (color=always)\n\n$ git diff --color=never\nDiffing stage..worktree  (color=never)\n\n```","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12130:27697":{"id":"2:12130:27697","crate_id":2,"name":"is_ascii","span":null,"visibility":"public","docs":"Checks if all characters in this string are within the ASCII range.\n\n# Examples\n\n```\nlet ascii = \"hello!\\n\";\nlet non_ascii = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert!(ascii.is_ascii());\nassert!(!non_ascii.is_ascii());\n```","links":{},"attrs":["#[rustc_const_unstable(feature = \"const_slice_is_ascii\", issue = \"111090\")]","#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"primitive":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5398:36307":{"id":"5:5398:36307","crate_id":5,"name":"to_uppercase","span":null,"visibility":"public","docs":"Returns the uppercase equivalent of this string slice, as a new [`String`].\n\n'Uppercase' is defined according to the terms of the Unicode Derived Core Property\n`Uppercase`.\n\nSince some characters can expand into multiple characters when changing\nthe case, this function returns a [`String`] instead of modifying the\nparameter in-place.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"hello\";\n\nassert_eq!(\"HELLO\", s.to_uppercase());\n```\n\nScripts without case are not changed:\n\n```\nlet new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_uppercase());\n```\n\nOne character can become multiple:\n```\nlet s = \"tsch√º√ü\";\n\nassert_eq!(\"TSCH√úSS\", s.to_uppercase());\n```","links":{"`String`":"5:7241:224"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the uppercase string as a new String, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:16:1852":{"id":"0:16:1852","crate_id":0,"name":"multicall_hostname","span":{"filename":"src/_cookbook/multicall_hostname.rs","begin":[1,0],"end":[7,62]},"visibility":"public","docs":"# Example: hostname-like CLI (Builder API)\n\n```rust\nuse clap::Command;\n\nfn main() {\n    let cmd = Command::new(env!(\"CARGO_CRATE_NAME\"))\n        .multicall(true)\n        .arg_required_else_help(true)\n        .subcommand_value_name(\"APPLET\")\n        .subcommand_help_heading(\"APPLETS\")\n        .subcommand(Command::new(\"hostname\").about(\"show hostname part of FQDN\"))\n        .subcommand(Command::new(\"dnsdomainname\").about(\"show domain name part of FQDN\"));\n\n    match cmd.get_matches().subcommand_name() {\n        Some(\"hostname\") => println!(\"www\"),\n        Some(\"dnsdomainname\") => println!(\"example.com\"),\n        _ => unreachable!(\"parser should ensure only valid subcommand names are used\"),\n    }\n}\n```\n\nSee the documentation for [`Command::multicall`][crate::Command::multicall] for rationale.\n\nThis example omits the implementation of displaying address config\n\n```console\n$ hostname\nwww\n\n```\n*Note: without the links setup, we can't demonstrate the multicall behavior*","links":{"crate::Command::multicall":"20:528:2937"},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"0:3-20:0:1707":{"id":"0:3-20:0:1707","crate_id":0,"name":null,"span":{"filename":"src/lib.rs","begin":[98,0],"end":[98,24]},"visibility":"public","docs":null,"links":{},"attrs":[],"deprecation":null,"inner":{"import":{"source":"clap_builder","name":"clap_builder","id":"20:0:1707","glob":true}}},"2:12099:35641":{"id":"2:12099:35641","crate_id":2,"name":"trim","span":null,"visibility":"public","docs":"Returns a string slice with leading and trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`, which includes newlines.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\\n Hello\\tworld\\t\\n\";\n\nassert_eq!(\"Hello\\tworld\", s.trim());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a slice, \\\n                  without modifying the original\"]","#[rustc_diagnostic_item = \"str_trim\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:9:1845":{"id":"0:9:1845","crate_id":0,"name":"cargo_example_derive","span":{"filename":"src/_cookbook/cargo_example_derive.rs","begin":[1,0],"end":[7,64]},"visibility":"public","docs":"# Example: cargo subcommand (Derive API)\n\n```rust\nuse clap::Parser;\n\n#[derive(Parser)] // requires `derive` feature\n#[command(name = \"cargo\")]\n#[command(bin_name = \"cargo\")]\nenum CargoCli {\n    ExampleDerive(ExampleDeriveArgs),\n}\n\n#[derive(clap::Args)]\n#[command(author, version, about, long_about = None)]\nstruct ExampleDeriveArgs {\n    #[arg(long)]\n    manifest_path: Option<std::path::PathBuf>,\n}\n\nfn main() {\n    let CargoCli::ExampleDerive(args) = CargoCli::parse();\n    println!(\"{:?}\", args.manifest_path);\n}\n```\n\nFor more on creating a custom subcommand, see [the cargo\nbook](https://doc.rust-lang.org/cargo/reference/external-tools.html#custom-subcommands).\nThe crate [`clap-cargo`](https://github.com/crate-ci/clap-cargo) can help in\nmimicking cargo's interface.\n\nThe help looks like:\n```console\n$ cargo-example-derive --help\nUsage: cargo <COMMAND>\n\nCommands:\n  example-derive  A simple to use, efficient, and full-featured Command Line Argument Parser\n  help            Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ cargo-example-derive example-derive --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: cargo example-derive [OPTIONS]\n\nOptions:\n      --manifest-path <MANIFEST_PATH>  \n  -h, --help                           Print help\n  -V, --version                        Print version\n\n```\n\nThen to directly invoke the command, run:\n```console\n$ cargo-example-derive example-derive\nNone\n\n$ cargo-example-derive example-derive --manifest-path Cargo.toml\nSome(\"Cargo.toml\")\n\n```","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12135:35652":{"id":"2:12135:35652","crate_id":2,"name":"escape_debug","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_debug`].\n\nNote: only extended grapheme codepoints that begin the string will be\nescaped.\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_debug() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_debug());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"‚ù§\\\\n!\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_debug().to_string(), \"‚ù§\\\\n!\");\n```","links":{"`char::escape_debug`":"2:4535:35652"},"attrs":["#[must_use =\n\"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"EscapeDebug","id":"2:43656:8918","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5384:9251":{"id":"5:5384:9251","crate_id":5,"name":"replace","span":null,"visibility":"public","docs":"Replaces all matches of a pattern with another string.\n\n`replace` creates a new [`String`], and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"this is old\";\n\nassert_eq!(\"this is new\", s.replace(\"old\", \"new\"));\nassert_eq!(\"than an old\", s.replace(\"is\", \"an\"));\n```\n\nWhen the pattern doesn't match, it returns this string slice as [`String`]:\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replace(\"cookie monster\", \"little lamb\"));\n```","links":{"`String`":"5:7241:224"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["from",{"generic":"P"}],["to",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12011:811":{"id":"2:12011:811","crate_id":2,"name":"len","span":null,"visibility":"public","docs":"Returns the length of `self`.\n\nThis length is in bytes, not [`char`]s or graphemes. In other words,\nit might not be what a human considers the length of the string.\n\n[`char`]: prim@char\n\n# Examples\n\nBasic usage:\n\n```\nlet len = \"foo\".len();\nassert_eq!(3, len);\n\nassert_eq!(\"∆íoo\".len(), 4); // fancy f!\nassert_eq!(\"∆íoo\".chars().count(), 3);\n```","links":{"prim@char":"1:11888:419"},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"primitive":"usize"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:15:1851":{"id":"0:15:1851","crate_id":0,"name":"multicall_busybox","span":{"filename":"src/_cookbook/multicall_busybox.rs","begin":[1,0],"end":[7,61]},"visibility":"public","docs":"# Example: busybox-like CLI (Builder API)\n\n```rust\nuse std::path::PathBuf;\nuse std::process::exit;\n\nuse clap::{value_parser, Arg, ArgAction, Command};\n\nfn applet_commands() -> [Command; 2] {\n    [\n        Command::new(\"true\").about(\"does nothing successfully\"),\n        Command::new(\"false\").about(\"does nothing unsuccessfully\"),\n    ]\n}\n\nfn main() {\n    let cmd = Command::new(env!(\"CARGO_CRATE_NAME\"))\n        .multicall(true)\n        .subcommand(\n            Command::new(\"busybox\")\n                .arg_required_else_help(true)\n                .subcommand_value_name(\"APPLET\")\n                .subcommand_help_heading(\"APPLETS\")\n                .arg(\n                    Arg::new(\"install\")\n                        .long(\"install\")\n                        .help(\"Install hardlinks for all subcommands in path\")\n                        .exclusive(true)\n                        .action(ArgAction::Set)\n                        .default_missing_value(\"/usr/local/bin\")\n                        .value_parser(value_parser!(PathBuf)),\n                )\n                .subcommands(applet_commands()),\n        )\n        .subcommands(applet_commands());\n\n    let matches = cmd.get_matches();\n    let mut subcommand = matches.subcommand();\n    if let Some((\"busybox\", cmd)) = subcommand {\n        if cmd.contains_id(\"install\") {\n            unimplemented!(\"Make hardlinks to the executable here\");\n        }\n        subcommand = cmd.subcommand();\n    }\n    match subcommand {\n        Some((\"false\", _)) => exit(1),\n        Some((\"true\", _)) => exit(0),\n        _ => unreachable!(\"parser should ensure only valid subcommand names are used\"),\n    }\n}\n```\n\nSee the documentation for [`Command::multicall`][crate::Command::multicall] for rationale.\n\nThis example omits every command except true and false,\nwhich are the most trivial to implement,\n```console\n$ busybox true\n? 0\n\n$ busybox false\n? 1\n\n```\n*Note: without the links setup, we can't demonstrate the multicall behavior*\n\nBut includes the `--install` option as an example of why it can be useful\nfor the main program to take arguments that aren't applet subcommands.\n```console\n$ busybox --install\n? failed\n...\n\n```\n\nThough users must pass something:\n```console\n$ busybox\n? failed\nUsage: busybox [OPTIONS] [APPLET]\n\nAPPLETS:\n  true   does nothing successfully\n  false  does nothing unsuccessfully\n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n      --install <install>  Install hardlinks for all subcommands in path\n  -h, --help               Print help\n\n```","links":{"crate::Command::multicall":"20:528:2937"},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12063:28454":{"id":"2:12063:28454","crate_id":2,"name":"split_inclusive","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern. Differs from the iterator produced by\n`split` in that `split_inclusive` leaves the matched part as the\nterminator of the substring.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n```\n\nIf the last element of the string is matched,\nthat element will be considered the terminator of the preceding substring.\nThat substring will be the last item returned by the iterator.\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n    .split_inclusive('\\n').collect();\nassert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"SplitInclusive","id":"2:11535:8898","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12023:28417":{"id":"2:12023:28417","crate_id":2,"name":"get","span":null,"visibility":"public","docs":"Returns a subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns\n[`None`] whenever equivalent indexing operation would panic.\n\n# Examples\n\n```\nlet v = String::from(\"üóª‚ààüåè\");\n\nassert_eq!(Some(\"üóª\"), v.get(0..4));\n\n// indices not on UTF-8 sequence boundaries\nassert!(v.get(1..).is_none());\nassert!(v.get(..8).is_none());\n\n// out of bounds\nassert!(v.get(..42).is_none());\n```","links":{"`None`":"2:41396:179"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["i",{"generic":"I"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"qualified_path":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"I"},"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}}}}}}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"I"},"bounds":[{"trait_bound":{"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12034:28446":{"id":"2:12034:28446","crate_id":2,"name":"split_at_mut","span":null,"visibility":"public","docs":"Divide one mutable string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`,\nand from `mid` to the end of the string slice.\n\nTo get immutable string slices instead, see the [`split_at`] method.\n\n[`split_at`]: str::split_at\n\n# Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is\npast the end of the last code point of the string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut s = \"Per Martin-L√∂f\".to_string();\n{\n    let (first, last) = s.split_at_mut(3);\n    first.make_ascii_uppercase();\n    assert_eq!(\"PER\", first);\n    assert_eq!(\" Martin-L√∂f\", last);\n}\nassert_eq!(\"PER Martin-L√∂f\", s);\n```","links":{"str::split_at":"2:12033:28445"},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}],["mid",{"primitive":"usize"}]],"output":{"tuple":[{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"primitive":"str"}}},{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"primitive":"str"}}}]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12036:33026":{"id":"2:12036:33026","crate_id":2,"name":"char_indices","span":null,"visibility":"public","docs":"Returns an iterator over the [`char`]s of a string slice, and their\npositions.\n\nAs a string slice consists of valid UTF-8, we can iterate through a\nstring slice by [`char`]. This method returns an iterator of both\nthese [`char`]s, as well as their byte positions.\n\nThe iterator yields tuples. The position is first, the [`char`] is\nsecond.\n\n# Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.char_indices().count();\nassert_eq!(7, count);\n\nlet mut char_indices = word.char_indices();\n\nassert_eq!(Some((0, 'g')), char_indices.next());\nassert_eq!(Some((1, 'o')), char_indices.next());\nassert_eq!(Some((2, 'o')), char_indices.next());\nassert_eq!(Some((3, 'd')), char_indices.next());\nassert_eq!(Some((4, 'b')), char_indices.next());\nassert_eq!(Some((5, 'y')), char_indices.next());\nassert_eq!(Some((6, 'e')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```\n\nRemember, [`char`]s might not match your intuition about characters:\n\n[`char`]: prim@char\n\n```\nlet yes = \"yÃÜes\";\n\nlet mut char_indices = yes.char_indices();\n\nassert_eq!(Some((0, 'y')), char_indices.next()); // not (0, 'yÃÜ')\nassert_eq!(Some((1, '\\u{0306}')), char_indices.next());\n\n// note the 3 here - the last character took up two bytes\nassert_eq!(Some((3, 'e')), char_indices.next());\nassert_eq!(Some((4, 's')), char_indices.next());\n\nassert_eq!(None, char_indices.next());\n```","links":{"prim@char":"1:11888:419"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"CharIndices","id":"2:43333:8913","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12021:314":{"id":"2:12021:314","crate_id":2,"name":"as_ptr","span":null,"visibility":"public","docs":"Converts a string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a\n[`u8`]. This pointer will be pointing to the first byte of the string\nslice.\n\nThe caller must ensure that the returned pointer is never written to.\nIf you need to mutate the contents of the string slice, use [`as_mut_ptr`].\n\n[`as_mut_ptr`]: str::as_mut_ptr\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"Hello\";\nlet ptr = s.as_ptr();\n```","links":{"str::as_mut_ptr":"2:12022:28421","`u8`":"1:11905:1499"},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"raw_pointer":{"mutable":false,"type":{"primitive":"u8"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:19:1855":{"id":"0:19:1855","crate_id":0,"name":"typed_derive","span":{"filename":"src/_cookbook/typed_derive.rs","begin":[1,0],"end":[7,56]},"visibility":"public","docs":"# Example: Custom Types (Derive API)\n\n```rust\nuse clap::builder::TypedValueParser as _;\nuse clap::Parser;\nuse std::error::Error;\n\n#[derive(Parser, Debug)] // requires `derive` feature\n#[command(term_width = 0)] // Just to make testing across clap features easier\nstruct Args {\n    /// Implicitly using `std::str::FromStr`\n    #[arg(short = 'O')]\n    optimization: Option<usize>,\n\n    /// Allow invalid UTF-8 paths\n    #[arg(short = 'I', value_name = \"DIR\", value_hint = clap::ValueHint::DirPath)]\n    include: Option<std::path::PathBuf>,\n\n    /// Handle IP addresses\n    #[arg(long)]\n    bind: Option<std::net::IpAddr>,\n\n    /// Allow human-readable durations\n    #[arg(long)]\n    sleep: Option<humantime::Duration>,\n\n    /// Hand-written parser for tuples\n    #[arg(short = 'D', value_parser = parse_key_val::<String, i32>)]\n    defines: Vec<(String, i32)>,\n\n    /// Support for discrete numbers\n    #[arg(\n        long,\n        default_value_t = 22,\n        value_parser = clap::builder::PossibleValuesParser::new([\"22\", \"80\"])\n            .map(|s| s.parse::<usize>().unwrap()),\n    )]\n    port: usize,\n\n    /// Support enums from a foreign crate that don't implement `ValueEnum`\n    #[arg(\n        long,\n        default_value_t = foreign_crate::LogLevel::Info,\n        value_parser = clap::builder::PossibleValuesParser::new([\"info\", \"debug\", \"info\", \"warn\", \"error\"])\n            .map(|s| s.parse::<foreign_crate::LogLevel>().unwrap()),\n    )]\n    log_level: foreign_crate::LogLevel,\n}\n\n/// Parse a single key-value pair\nfn parse_key_val<T, U>(s: &str) -> Result<(T, U), Box<dyn Error + Send + Sync + 'static>>\nwhere\n    T: std::str::FromStr,\n    T::Err: Error + Send + Sync + 'static,\n    U: std::str::FromStr,\n    U::Err: Error + Send + Sync + 'static,\n{\n    let pos = s\n        .find('=')\n        .ok_or_else(|| format!(\"invalid KEY=value: no `=` found in `{s}`\"))?;\n    Ok((s[..pos].parse()?, s[pos + 1..].parse()?))\n}\n\nmod foreign_crate {\n    #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n    pub enum LogLevel {\n        Trace,\n        Debug,\n        Info,\n        Warn,\n        Error,\n    }\n\n    impl std::fmt::Display for LogLevel {\n        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n            let s = match self {\n                Self::Trace => \"trace\",\n                Self::Debug => \"debug\",\n                Self::Info => \"info\",\n                Self::Warn => \"warn\",\n                Self::Error => \"error\",\n            };\n            s.fmt(f)\n        }\n    }\n    impl std::str::FromStr for LogLevel {\n        type Err = String;\n\n        fn from_str(s: &str) -> Result<Self, Self::Err> {\n            match s {\n                \"trace\" => Ok(Self::Trace),\n                \"debug\" => Ok(Self::Debug),\n                \"info\" => Ok(Self::Info),\n                \"warn\" => Ok(Self::Warn),\n                \"error\" => Ok(Self::Error),\n                _ => Err(format!(\"Unknown log level: {s}\")),\n            }\n        }\n    }\n}\n\nfn main() {\n    let args = Args::parse();\n    println!(\"{args:?}\");\n}\n```\n\n**This requires enabling the [`derive` feature flag][crate::_features].**\n\nHelp:\n```console\n$ typed-derive --help\nUsage: typed-derive[EXE] [OPTIONS]\n\nOptions:\n  -O <OPTIMIZATION>            Implicitly using `std::str::FromStr`\n  -I <DIR>                     Allow invalid UTF-8 paths\n      --bind <BIND>            Handle IP addresses\n      --sleep <SLEEP>          Allow human-readable durations\n  -D <DEFINES>                 Hand-written parser for tuples\n      --port <PORT>            Support for discrete numbers [default: 22] [possible values: 22, 80]\n      --log-level <LOG_LEVEL>  Support enums from a foreign crate that don't implement `ValueEnum` [default: info] [possible values: info, debug, info, warn, error]\n  -h, --help                   Print help\n\n```\n\nOptimization-level (number)\n```console\n$ typed-derive -O 1\nArgs { optimization: Some(1), include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Info }\n\n$ typed-derive -O plaid\n? failed\nerror: invalid value 'plaid' for '-O <OPTIMIZATION>': invalid digit found in string\n\nFor more information, try '--help'.\n\n```\n\nInclude (path)\n```console\n$ typed-derive -I../hello\nArgs { optimization: None, include: Some(\"../hello\"), bind: None, sleep: None, defines: [], port: 22, log_level: Info }\n\n```\n\nIP Address\n```console\n$ typed-derive --bind 192.0.0.1\nArgs { optimization: None, include: None, bind: Some(192.0.0.1), sleep: None, defines: [], port: 22, log_level: Info }\n\n$ typed-derive --bind localhost\n? failed\nerror: invalid value 'localhost' for '--bind <BIND>': invalid IP address syntax\n\nFor more information, try '--help'.\n\n```\n\nTime\n```console\n$ typed-derive --sleep 10s\nArgs { optimization: None, include: None, bind: None, sleep: Some(Duration(10s)), defines: [], port: 22, log_level: Info }\n\n$ typed-derive --sleep forever\n? failed\nerror: invalid value 'forever' for '--sleep <SLEEP>': expected number at 0\n\nFor more information, try '--help'.\n\n```\n\nDefines (key-value pairs)\n```console\n$ typed-derive -D Foo=10 -D Alice=30\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [(\"Foo\", 10), (\"Alice\", 30)], port: 22, log_level: Info }\n\n$ typed-derive -D Foo\n? failed\nerror: invalid value 'Foo' for '-D <DEFINES>': invalid KEY=value: no `=` found in `Foo`\n\nFor more information, try '--help'.\n\n$ typed-derive -D Foo=Bar\n? failed\nerror: invalid value 'Foo=Bar' for '-D <DEFINES>': invalid digit found in string\n\nFor more information, try '--help'.\n\n```\n\nDiscrete numbers\n```console\n$ typed-derive --port 22\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Info }\n\n$ typed-derive --port 80\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 80, log_level: Info }\n\n$ typed-derive --port\n? failed\nerror: a value is required for '--port <PORT>' but none was supplied\n  [possible values: 22, 80]\n\nFor more information, try '--help'.\n\n$ typed-derive --port 3000\n? failed\nerror: invalid value '3000' for '--port <PORT>'\n  [possible values: 22, 80]\n\nFor more information, try '--help'.\n\n```\n\nEnums from crates that can't implement `ValueEnum`\n```console\n$ typed-derive --log-level debug\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Debug }\n\n$ typed-derive --log-level error\nArgs { optimization: None, include: None, bind: None, sleep: None, defines: [], port: 22, log_level: Error }\n\n$ typed-derive --log-level\n? failed\nerror: a value is required for '--log-level <LOG_LEVEL>' but none was supplied\n  [possible values: info, debug, info, warn, error]\n\nFor more information, try '--help'.\n\n$ typed-derive --log-level critical\n? failed\nerror: invalid value 'critical' for '--log-level <LOG_LEVEL>'\n  [possible values: info, debug, info, warn, error]\n\nFor more information, try '--help'.\n\n```","links":{"crate::_features":"0:24:1712"},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12090:35638":{"id":"2:12090:35638","crate_id":2,"name":"rmatches","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within this string slice,\nyielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`matches`] method can be used.\n\n[`matches`]: str::matches\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".rmatches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".rmatches(char::is_numeric).collect();\nassert_eq!(v, [\"3\", \"2\", \"1\"]);\n```","links":{"self::pattern":"2:11712:8907","`DoubleEndedIterator`":"2:7240:121","prim@char":"1:11888:419","str::matches":"2:12087:2606"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"RMatches","id":"2:43579:8925","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5400:3386":{"id":"5:5400:3386","crate_id":5,"name":"repeat","span":null,"visibility":"public","docs":"Creates a new [`String`] by repeating a string `n` times.\n\n# Panics\n\nThis function will panic if the capacity would overflow.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"abc\".repeat(4), String::from(\"abcabcabcabc\"));\n```\n\nA panic upon overflow:\n\n```should_panic\n// this will panic at runtime\nlet huge = \"0123456789abcdef\".repeat(usize::MAX);\n```","links":{"`String`":"5:7241:224"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["n",{"primitive":"usize"}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12037:24297":{"id":"2:12037:24297","crate_id":2,"name":"bytes","span":null,"visibility":"public","docs":"An iterator over the bytes of a string slice.\n\nAs a string slice consists of a sequence of bytes, we can iterate\nthrough a string slice by byte. This method returns such an iterator.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut bytes = \"bors\".bytes();\n\nassert_eq!(Some(b'b'), bytes.next());\nassert_eq!(Some(b'o'), bytes.next());\nassert_eq!(Some(b'r'), bytes.next());\nassert_eq!(Some(b's'), bytes.next());\n\nassert_eq!(None, bytes.next());\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"Bytes","id":"2:43343:3361","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12052:1848":{"id":"2:12052:1848","crate_id":2,"name":"find","span":null,"visibility":"public","docs":"Returns the byte index of the first character of this string slice that\nmatches the pattern.\n\nReturns [`None`] if the pattern doesn't match.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard Gepardi\";\n\nassert_eq!(s.find('L'), Some(0));\nassert_eq!(s.find('√©'), Some(14));\nassert_eq!(s.find(\"pard\"), Some(17));\n```\n\nMore complex patterns using point-free style and closures:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.find(char::is_whitespace), Some(5));\nassert_eq!(s.find(char::is_lowercase), Some(1));\nassert_eq!(s.find(|c: char| c.is_whitespace() || c.is_lowercase()), Some(1));\nassert_eq!(s.find(|c: char| (c < 'o') && (c > 'a')), Some(4));\n```\n\nNot finding the pattern:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.find(x), None);\n```","links":{"`None`":"2:41396:179","prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"primitive":"usize"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12084:35637":{"id":"2:12084:35637","crate_id":2,"name":"rsplit_once","span":null,"visibility":"public","docs":"Splits the string on the last occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.\n\n# Examples\n\n```\nassert_eq!(\"cfg\".rsplit_once('='), None);\nassert_eq!(\"cfg=foo\".rsplit_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".rsplit_once('='), Some((\"cfg=foo\", \"bar\")));\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["delimiter",{"generic":"P"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"tuple":[{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}},{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}}]}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12027:28419":{"id":"2:12027:28419","crate_id":2,"name":"get_unchecked","span":null,"visibility":"public","docs":"Returns an unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n# Safety\n\nCallers of this function are responsible that these preconditions are\nsatisfied:\n\n* The starting index must not exceed the ending index;\n* Indexes must be within bounds of the original slice;\n* Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the `str` type.\n\n# Examples\n\n```\nlet v = \"üóª‚ààüåè\";\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked(7..11));\n}\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["i",{"generic":"I"}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"qualified_path":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"I"},"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}}}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"I"},"bounds":[{"trait_bound":{"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}}},"2:12128:35651":{"id":"2:12128:35651","crate_id":2,"name":"parse","span":null,"visibility":"public","docs":"Parses this string slice into another type.\n\nBecause `parse` is so general, it can cause problems with type\ninference. As such, `parse` is one of the few times you'll see\nthe syntax affectionately known as the 'turbofish': `::<>`. This\nhelps the inference algorithm understand specifically which type\nyou're trying to parse into.\n\n`parse` can parse into any type that implements the [`FromStr`] trait.\n\n# Errors\n\nWill return [`Err`] if it's not possible to parse this string slice into\nthe desired type.\n\n[`Err`]: FromStr::Err\n\n# Examples\n\nBasic usage\n\n```\nlet four: u32 = \"4\".parse().unwrap();\n\nassert_eq!(4, four);\n```\n\nUsing the 'turbofish' instead of annotating `four`:\n\n```\nlet four = \"4\".parse::<u32>();\n\nassert_eq!(Ok(4), four);\n```\n\nFailing to parse:\n\n```\nlet nope = \"j\".parse::<u32>();\n\nassert!(nope.is_err());\n```","links":{"FromStr::Err":"2:11673:127","`FromStr`":"2:11672:3530"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"Result","id":"2:41538:210","args":{"angle_bracketed":{"args":[{"type":{"generic":"F"}},{"type":{"qualified_path":{"name":"Err","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"F"},"trait":{"name":"FromStr","id":"2:11672:3530","args":{"angle_bracketed":{"args":[],"bindings":[]}}}}}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"F","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"F"},"bounds":[{"trait_bound":{"trait":{"name":"FromStr","id":"2:11672:3530","args":{"angle_bracketed":{"args":[],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5383:36304":{"id":"5:5383:36304","crate_id":5,"name":"into_boxed_bytes","span":null,"visibility":"public","docs":"Converts a `Box<str>` into a `Box<[u8]>` without copying or allocating.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"this is a string\";\nlet boxed_str = s.to_owned().into_boxed_str();\nlet boxed_bytes = boxed_str.into_boxed_bytes();\nassert_eq!(*boxed_bytes, *s.as_bytes());\n```","links":{},"attrs":["#[must_use = \"`self` will be dropped if the result is not used\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"resolved_path":{"name":"Box","id":"5:280:2682","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}},{"type":{"resolved_path":{"name":"Global","id":"5:6990:3236","args":{"angle_bracketed":{"args":[],"bindings":[]}}}}}],"bindings":[]}}}}]],"output":{"resolved_path":{"name":"Box","id":"5:280:2682","args":{"angle_bracketed":{"args":[{"type":{"slice":{"primitive":"u8"}}},{"type":{"resolved_path":{"name":"Global","id":"5:6990:3236","args":{"angle_bracketed":{"args":[],"bindings":[]}}}}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:23:1711":{"id":"0:23:1711","crate_id":0,"name":"_faq","span":{"filename":"src/_faq.rs","begin":[1,0],"end":[95,3]},"visibility":"public","docs":"# Documentation: FAQ\n\n1. [Comparisons](#comparisons)\n   1. [How does `clap` compare to structopt?](#how-does-clap-compare-to-structopt)\n   2. [What are some reasons to use `clap`? (The Pitch)](#what-are-some-reasons-to-use-clap-the-pitch)\n   3. [What are some reasons *not* to use `clap`? (The Anti Pitch)](#what-are-some-reasons-not-to-use-clap-the-anti-pitch)\n   4. [Reasons to use `clap`](#reasons-to-use-clap)\n2. [How many approaches are there to create a parser?](#how-many-approaches-are-there-to-create-a-parser)\n3. [When should I use the builder vs derive APIs?](#when-should-i-use-the-builder-vs-derive-apis)\n4. [Why is there a default subcommand of help?](#why-is-there-a-default-subcommand-of-help)\n\n### Comparisons\n\nFirst, let me say that these comparisons are highly subjective, and not meant\nin a critical or harsh manner. All the argument parsing libraries out there (to\ninclude `clap`) have their own strengths and weaknesses. Sometimes it just\ncomes down to personal taste when all other factors are equal. When in doubt,\ntry them all and pick one that you enjoy :). There's plenty of room in the Rust\ncommunity for multiple implementations!\n\nFor less detailed but more broad comparisons, see\n[argparse-benchmarks](https://github.com/rust-cli/argparse-benchmarks-rs).\n\n#### How does `clap` compare to [structopt](https://github.com/TeXitoi/structopt)?\n\nSimple! `clap` *is* `structopt`.  `structopt` started as a derive API built on\ntop of clap v2.  With clap v3, we've forked structopt and integrated it\ndirectly into clap.  structopt is in\n[maintenance mode](https://github.com/TeXitoi/structopt/issues/516#issuecomment-989566094)\nwith the release of `clap_derive`.\n\nThe benefits of integrating `structopt` and `clap` are:\n- Easier cross-linking in documentation\n- [Documentation parity](../examples)\n- Tighter design feedback loop, ensuring all new features are designed with\n  derives in mind and easier to change `clap` in response to `structopt` bugs.\n- Clearer endorsement of `structopt`\n\nSee also\n- [`clap` v3 CHANGELOG](../CHANGELOG.md#300---2021-12-31)\n- [`structopt` migration guide](../CHANGELOG.md#migrate-structopt)\n\n#### What are some reasons to use `clap`? (The Pitch)\n\n`clap` is as fast, and as lightweight as possible while still giving all the features you'd expect from a modern argument parser. In fact, for the amount and type of features `clap` offers it remains about as fast as `getopts`. If you use `clap`, when you just need some simple arguments parsed, you'll find it's a walk in the park. `clap` also makes it possible to represent extremely complex and advanced requirements without too much thought. `clap` aims to be intuitive, easy to use, and fully capable for wide variety use cases and needs.\n\n#### What are some reasons *not* to use `clap`? (The Anti Pitch)\n\nDepending on the style in which you choose to define the valid arguments, `clap` can be very verbose. `clap` also offers so many finetuning knobs and dials, that learning everything can seem overwhelming. I strive to keep the simple cases simple, but when turning all those custom dials it can get complex. `clap` is also opinionated about parsing. Even though so much can be tweaked and tuned with `clap` (and I'm adding more all the time), there are still certain features which `clap` implements in specific ways that may be contrary to some users' use-cases.\n\n#### Reasons to use `clap`\n\n * You want all the nice CLI features your users may expect, yet you don't want to implement them all yourself. You'd like to focus on your application, not argument parsing.\n * In addition to the point above, you don't want to sacrifice performance to get all those nice features.\n * You have complex requirements/conflicts between your various valid args.\n * You want to use subcommands (although other libraries also support subcommands, they are not nearly as feature rich as those provided by `clap`).\n * You want some sort of custom validation built into the argument parsing process, instead of as part of your application (which allows for earlier failures, better error messages, more cohesive experience, etc.).\n\n### How many approaches are there to create a parser?\n\nThe following APIs are supported:\n- [Derive][crate::_derive::_tutorial]\n- [Builder][crate::_tutorial]\n\nPreviously, we supported:\n- [YAML](https://github.com/clap-rs/clap/issues/3087)\n- [docopt](http://docopt.org/)-inspired [usage parser](https://github.com/clap-rs/clap/issues/3086)\n- [`clap_app!`](https://github.com/clap-rs/clap/issues/2835)\n\nThere are also experiments with other APIs:\n- [fncmd](https://github.com/yuhr/fncmd): function attribute\n- [clap-serde](https://github.com/aobatact/clap-serde): create an `Command` from a deserializer\n\n### When should I use the builder vs derive APIs?\n\nOur default answer is to use the [Derive API][crate::_derive::_tutorial]:\n- Easier to read, write, and modify\n- Easier to keep the argument declaration and reading of argument in sync\n- Easier to reuse, e.g. [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag)\n\nThe [Builder API][crate::_tutorial] is a lower-level API that someone might want to use for\n- Faster compile times if you aren't already using other procedural macros\n- More flexibility, e.g. you can look up an [arguments values][crate::ArgMatches::get_many],\n  their [ordering with other arguments][crate::ArgMatches::indices_of], and [what set\n  them][crate::ArgMatches::value_source].  The Derive API can only report values and not\n  indices of or other data.\n\nYou can [interop between Derive and Builder APIs][crate::_derive#mixing-builder-and-derive-apis].\n\n### Why is there a default subcommand of help?\n\nThere is only a default subcommand of `help` when other subcommands have been defined manually. So it's opt-in(ish), being that you only get a `help` subcommand if you're actually using subcommands.\n\nAlso, if the user defined a `help` subcommand themselves, the auto-generated one wouldn't be added (meaning it's only generated if the user hasn't defined one themselves).\n","links":{"crate::ArgMatches::value_source":"20:1877:3082","crate::ArgMatches::indices_of":"20:1879:3080","crate::_derive#mixing-builder-and-derive-apis":"0:20:1710","crate::_tutorial":"0:25:1713","crate::_derive::_tutorial":"0:21:1713","crate::ArgMatches::get_many":"20:1862:3077"},"attrs":["#[cfg(feature = \"unstable-doc\")]"],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12137:3164":{"id":"2:12137:3164","crate_id":2,"name":"escape_default","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_default`].\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_default() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_default());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\n!\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_default().to_string(), \"\\\\u{2764}\\\\n!\");\n```","links":{"`char::escape_default`":"2:4536:3164"},"attrs":["#[must_use =\n\"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"EscapeDefault","id":"2:43665:3165","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12020:35630":{"id":"2:12020:35630","crate_id":2,"name":"as_bytes_mut","span":null,"visibility":"public","docs":"Converts a mutable string slice to a mutable byte slice.\n\n# Safety\n\nThe caller must ensure that the content of the slice is valid UTF-8\nbefore the borrow ends and the underlying `str` is used.\n\nUse of a `str` whose contents are not valid UTF-8 is undefined behavior.\n\n# Examples\n\nBasic usage:\n\n```\nlet mut s = String::from(\"Hello\");\nlet bytes = unsafe { s.as_bytes_mut() };\n\nassert_eq!(b\"Hello\", bytes);\n```\n\nMutability:\n\n```\nlet mut s = String::from(\"üóª‚ààüåè\");\n\nunsafe {\n    let bytes = s.as_bytes_mut();\n\n    bytes[0] = 0xF0;\n    bytes[1] = 0x9F;\n    bytes[2] = 0x8D;\n    bytes[3] = 0x94;\n}\n\nassert_eq!(\"üçî‚ààüåè\", s);\n```","links":{},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"slice":{"primitive":"u8"}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}}},"2:12093:35639":{"id":"2:12093:35639","crate_id":2,"name":"match_indices","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within this string\nslice as well as the index that the match starts at.\n\nFor matches of `pat` within `self` that overlap, only the indices\ncorresponding to the first match are returned.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rmatch_indices`] method can be used.\n\n[`rmatch_indices`]: str::rmatch_indices\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<_> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\nassert_eq!(v, [(0, \"abc\"), (6, \"abc\"), (12, \"abc\")]);\n\nlet v: Vec<_> = \"1abcabc2\".match_indices(\"abc\").collect();\nassert_eq!(v, [(1, \"abc\"), (4, \"abc\")]);\n\nlet v: Vec<_> = \"ababa\".match_indices(\"aba\").collect();\nassert_eq!(v, [(0, \"aba\")]); // only the first `aba`\n```","links":{"self::pattern":"2:11712:8907","`DoubleEndedIterator`":"2:7240:121","prim@char":"1:11888:419","str::rmatch_indices":"2:12096:35640"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"MatchIndices","id":"2:43507:8922","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12049:27851":{"id":"2:12049:27851","crate_id":2,"name":"ends_with","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a suffix of this\nstring slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.ends_with(\"anas\"));\nassert!(!bananas.ends_with(\"nana\"));\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"primitive":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:12:1848":{"id":"0:12:1848","crate_id":0,"name":"find","span":{"filename":"src/_cookbook/find.rs","begin":[1,0],"end":[7,48]},"visibility":"public","docs":"# Example: find-like CLI (Builder API)\n\n```rust\nuse std::collections::BTreeMap;\n\nuse clap::{arg, command, ArgGroup, ArgMatches, Command};\n\nfn main() {\n    let matches = cli().get_matches();\n    let values = Value::from_matches(&matches);\n    println!(\"{values:#?}\");\n}\n\nfn cli() -> Command {\n    command!()\n        .group(ArgGroup::new(\"tests\").multiple(true))\n        .next_help_heading(\"TESTS\")\n        .args([\n            arg!(--empty \"File is empty and is either a regular file or a directory\").group(\"tests\"),\n            arg!(--name <NAME> \"Base of file name (the path with the leading directories removed) matches shell pattern pattern\").group(\"tests\"),\n        ])\n        .group(ArgGroup::new(\"operators\").multiple(true))\n        .next_help_heading(\"OPERATORS\")\n        .args([\n            arg!(-o - -or \"expr2 is not evaluate if exp1 is true\").group(\"operators\"),\n            arg!(-a - -and \"Same as `expr1 expr1`\").group(\"operators\"),\n        ])\n}\n\n#[derive(Clone, PartialEq, Eq, Hash, Debug)]\npub enum Value {\n    Bool(bool),\n    String(String),\n}\n\nimpl Value {\n    pub fn from_matches(matches: &ArgMatches) -> Vec<(clap::Id, Self)> {\n        let mut values = BTreeMap::new();\n        for id in matches.ids() {\n            if matches.try_get_many::<clap::Id>(id.as_str()).is_ok() {\n                // ignore groups\n                continue;\n            }\n            let value_source = matches\n                .value_source(id.as_str())\n                .expect(\"id came from matches\");\n            if value_source != clap::parser::ValueSource::CommandLine {\n                // Any other source just gets tacked on at the end (like default values)\n                continue;\n            }\n            if Self::extract::<String>(matches, id, &mut values) {\n                continue;\n            }\n            if Self::extract::<bool>(matches, id, &mut values) {\n                continue;\n            }\n            unimplemented!(\"unknown type for {id}: {matches:?}\");\n        }\n        values.into_values().collect::<Vec<_>>()\n    }\n\n    fn extract<T: Clone + Into<Value> + Send + Sync + 'static>(\n        matches: &ArgMatches,\n        id: &clap::Id,\n        output: &mut BTreeMap<usize, (clap::Id, Self)>,\n    ) -> bool {\n        match matches.try_get_many::<T>(id.as_str()) {\n            Ok(Some(values)) => {\n                for (value, index) in values.zip(\n                    matches\n                        .indices_of(id.as_str())\n                        .expect(\"id came from matches\"),\n                ) {\n                    output.insert(index, (id.clone(), value.clone().into()));\n                }\n                true\n            }\n            Ok(None) => {\n                unreachable!(\"`ids` only reports what is present\")\n            }\n            Err(clap::parser::MatchesError::UnknownArgument { .. }) => {\n                unreachable!(\"id came from matches\")\n            }\n            Err(clap::parser::MatchesError::Downcast { .. }) => false,\n            Err(_) => {\n                unreachable!(\"id came from matches\")\n            }\n        }\n    }\n}\n\nimpl From<String> for Value {\n    fn from(other: String) -> Self {\n        Self::String(other)\n    }\n}\n\nimpl From<bool> for Value {\n    fn from(other: bool) -> Self {\n        Self::Bool(other)\n    }\n}\n```\n\n`find` is an example of position-sensitive flags\n\n```console\n$ find --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: find[EXE] [OPTIONS]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\nTESTS:\n      --empty        File is empty and is either a regular file or a directory\n      --name <NAME>  Base of file name (the path with the leading directories removed) matches shell\n                     pattern pattern\n\nOPERATORS:\n  -o, --or   expr2 is not evaluate if exp1 is true\n  -a, --and  Same as `expr1 expr1`\n\n$ find --empty -o --name .keep\n[\n    (\n        \"empty\",\n        Bool(\n            true,\n        ),\n    ),\n    (\n        \"or\",\n        Bool(\n            true,\n        ),\n    ),\n    (\n        \"name\",\n        String(\n            \".keep\",\n        ),\n    ),\n]\n\n```\n","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12046:27849":{"id":"2:12046:27849","crate_id":2,"name":"starts_with","span":null,"visibility":"public","docs":"Returns `true` if the given pattern matches a prefix of this\nstring slice.\n\nReturns `false` if it does not.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nBasic usage:\n\n```\nlet bananas = \"bananas\";\n\nassert!(bananas.starts_with(\"bana\"));\nassert!(!bananas.starts_with(\"nana\"));\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"primitive":"bool"},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12107:35646":{"id":"2:12107:35646","crate_id":2,"name":"trim_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes and suffixes that match a\npattern repeatedly removed.\n\nThe [pattern] can be a [`char`], a slice of [`char`]s, or a function\nor closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_matches('1'), \"foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_matches(char::is_numeric), \"foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_matches(x), \"foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1foo1barXX\".trim_matches(|c| c == '1' || c == 'X'), \"foo1bar\");\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"DoubleEndedSearcher","id":"2:11737:8902","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12029:28420":{"id":"2:12029:28420","crate_id":2,"name":"get_unchecked_mut","span":null,"visibility":"public","docs":"Returns a mutable, unchecked subslice of `str`.\n\nThis is the unchecked alternative to indexing the `str`.\n\n# Safety\n\nCallers of this function are responsible that these preconditions are\nsatisfied:\n\n* The starting index must not exceed the ending index;\n* Indexes must be within bounds of the original slice;\n* Indexes must lie on UTF-8 sequence boundaries.\n\nFailing that, the returned string slice may reference invalid memory or\nviolate the invariants communicated by the `str` type.\n\n# Examples\n\n```\nlet mut v = String::from(\"üóª‚ààüåè\");\nunsafe {\n    assert_eq!(\"üóª\", v.get_unchecked_mut(0..4));\n    assert_eq!(\"‚àà\", v.get_unchecked_mut(4..7));\n    assert_eq!(\"üåè\", v.get_unchecked_mut(7..11));\n}\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}],["i",{"generic":"I"}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"qualified_path":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"I"},"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}}}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"I"},"bounds":[{"trait_bound":{"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}}},"2:12035:33053":{"id":"2:12035:33053","crate_id":2,"name":"chars","span":null,"visibility":"public","docs":"Returns an iterator over the [`char`]s of a string slice.\n\nAs a string slice consists of valid UTF-8, we can iterate through a\nstring slice by [`char`]. This method returns such an iterator.\n\nIt's important to remember that [`char`] represents a Unicode Scalar\nValue, and might not match your idea of what a 'character' is. Iteration\nover grapheme clusters may be what you actually want. This functionality\nis not provided by Rust's standard library, check crates.io instead.\n\n# Examples\n\nBasic usage:\n\n```\nlet word = \"goodbye\";\n\nlet count = word.chars().count();\nassert_eq!(7, count);\n\nlet mut chars = word.chars();\n\nassert_eq!(Some('g'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('o'), chars.next());\nassert_eq!(Some('d'), chars.next());\nassert_eq!(Some('b'), chars.next());\nassert_eq!(Some('y'), chars.next());\nassert_eq!(Some('e'), chars.next());\n\nassert_eq!(None, chars.next());\n```\n\nRemember, [`char`]s might not match your intuition about characters:\n\n[`char`]: prim@char\n\n```\nlet y = \"yÃÜ\";\n\nlet mut chars = y.chars();\n\nassert_eq!(Some('y'), chars.next()); // not 'yÃÜ'\nassert_eq!(Some('\\u{0306}'), chars.next());\n\nassert_eq!(None, chars.next());\n```","links":{"prim@char":"1:11888:419"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"Chars","id":"2:43327:8914","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12022:28421":{"id":"2:12022:28421","crate_id":2,"name":"as_mut_ptr","span":null,"visibility":"public","docs":"Converts a mutable string slice to a raw pointer.\n\nAs string slices are a slice of bytes, the raw pointer points to a\n[`u8`]. This pointer will be pointing to the first byte of the string\nslice.\n\nIt is your responsibility to make sure that the string slice only gets\nmodified in a way that it remains valid UTF-8.","links":{"`u8`":"1:11905:1499"},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}]],"output":{"raw_pointer":{"mutable":true,"type":{"primitive":"u8"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12066:28456":{"id":"2:12066:28456","crate_id":2,"name":"rsplit","span":null,"visibility":"public","docs":"An iterator over substrings of the given string slice, separated by\ncharacters matched by a pattern and yielded in reverse order.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator requires that the pattern supports a reverse\nsearch, and it will be a [`DoubleEndedIterator`] if a forward/reverse\nsearch yields the same elements.\n\nFor iterating from the front, the [`split`] method can be used.\n\n[`split`]: str::split\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".rsplit(' ').collect();\nassert_eq!(v, [\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n\nlet v: Vec<&str> = \"\".rsplit('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".rsplit('X').collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"\", \"lion\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".rsplit(\"::\").collect();\nassert_eq!(v, [\"leopard\", \"tiger\", \"lion\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".rsplit(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"ghi\", \"def\", \"abc\"]);\n```","links":{"self::pattern":"2:11712:8907","`DoubleEndedIterator`":"2:7240:121","prim@char":"1:11888:419","str::split":"2:12060:26737"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"RSplit","id":"2:43375:8892","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12113:25631":{"id":"2:12113:25631","crate_id":2,"name":"strip_prefix","span":null,"visibility":"public","docs":"Returns a string slice with the prefix removed.\n\nIf the string starts with the pattern `prefix`, returns substring after the prefix, wrapped\nin `Some`.  Unlike `trim_start_matches`, this method removes the prefix exactly once.\n\nIf the string does not start with `prefix`, returns `None`.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nassert_eq!(\"foo:bar\".strip_prefix(\"foo:\"), Some(\"bar\"));\nassert_eq!(\"foo:bar\".strip_prefix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_prefix(\"foo\"), Some(\"foo\"));\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":["#[must_use =\n\"this returns the remaining substring as a new slice, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["prefix",{"generic":"P"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:7:1709":{"id":"0:7:1709","crate_id":0,"name":"_cookbook","span":{"filename":"src/_cookbook/mod.rs","begin":[8,0],"end":[61,21]},"visibility":"public","docs":"# Documentation: Cookbook\n\nTyped arguments: [derive][typed_derive]\n- Topics:\n  - Custom `parse()`\n\nCustom cargo command: [builder][cargo_example], [derive][cargo_example_derive]\n- Topics:\n  - Subcommands\n  - Cargo plugins\n\nfind-like interface: [builder][find]\n- Topics:\n  - Position-sensitive flags\n\ngit-like interface: [builder][git], [derive][git_derive]\n- Topics:\n  - Subcommands\n  - External subcommands\n  - Optional subcommands\n  - Default subcommands\n  - [`last`][crate::Arg::last]\n\npacman-like interface: [builder][pacman]\n- Topics:\n  - Flag subcommands\n  - Conflicting arguments\n\nEscaped positionals with `--`: [builder][escaped_positional], [derive][escaped_positional_derive]\n\nMulti-call\n- busybox: [builder][multicall_busybox]\n  - Topics:\n    - Subcommands\n- hostname: [builder][multicall_hostname]\n  - Topics:\n    - Subcommands\n\nrepl: [builder][repl]\n- Topics:\n  - Read-Eval-Print Loops / Custom command lines","links":{"git":"0:13:1849","pacman":"0:17:1853","crate::Arg::last":"20:174:2931","cargo_example_derive":"0:9:1845","escaped_positional_derive":"0:11:1847","multicall_hostname":"0:16:1852","multicall_busybox":"0:15:1851","find":"0:12:1848","repl":"0:18:1854","escaped_positional":"0:10:1846","typed_derive":"0:19:1855","cargo_example":"0:8:1844","git_derive":"0:14:1850"},"attrs":["#[cfg(feature = \"unstable-doc\")]"],"deprecation":null,"inner":{"module":{"is_crate":false,"items":["0:8:1844","0:9:1845","0:10:1846","0:11:1847","0:12:1848","0:13:1849","0:14:1850","0:15:1851","0:16:1852","0:17:1853","0:18:1854","0:19:1855"],"is_stripped":false}}},"0:0:1716":{"id":"0:0:1716","crate_id":0,"name":"clap","span":{"filename":"src/lib.rs","begin":[6,0],"end":[119,1]},"visibility":"public","docs":"> **Command Line Argument Parser for Rust**\n\nQuick Links:\n- Derive [tutorial][_derive::_tutorial] and [reference][_derive]\n- Builder [tutorial][_tutorial] and [reference](index.html)\n- [Cookbook][_cookbook]\n- [FAQ][_faq]\n- [Discussions](https://github.com/clap-rs/clap/discussions)\n\n## Aspirations\n\n- Out of the box, users get a polished CLI experience\n  - Including common argument behavior, help generation, suggested fixes for users, colored output, [shell completions](https://github.com/clap-rs/clap/tree/master/clap_complete), etc\n- Flexible enough to port your existing CLI interface\n  - However, we won't necessarily streamline support for each use case\n- Reasonable parse performance\n- Resilient maintainership, including\n  - Willing to break compatibility rather than batching up breaking changes in large releases\n  - Leverage feature flags to keep to one active branch\n  - Being under [WG-CLI](https://github.com/rust-cli/team/) to increase the bus factor\n- We follow semver and will wait about 6-9 months between major breaking changes\n- We will support the last two minor Rust releases (MSRV, currently 1.64.0)\n\nWhile these aspirations can be at odds with fast build times and low binary\nsize, we will still strive to keep these reasonable for the flexibility you\nget.  Check out the\n[argparse-benchmarks](https://github.com/rust-cli/argparse-benchmarks-rs) for\nCLI parsers optimized for other use cases.\n\n## Example\n\nRun\n```console\n$ cargo add clap --features derive\n```\n*(See also [feature flag reference][_features])*\n\nThen define your CLI in `main.rs`:\n```rust\n# #[cfg(feature = \"derive\")] {\nuse clap::Parser;\n\n/// Simple program to greet a person\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// Name of the person to greet\n    #[arg(short, long)]\n    name: String,\n\n    /// Number of times to greet\n    #[arg(short, long, default_value_t = 1)]\n    count: u8,\n}\n\nfn main() {\n    let args = Args::parse();\n\n    for _ in 0..args.count {\n        println!(\"Hello {}!\", args.name)\n    }\n}\n# }\n```\n\nAnd try it out:\n```console\n$ demo --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: demo[EXE] [OPTIONS] --name <NAME>\n\nOptions:\n  -n, --name <NAME>    Name of the person to greet\n  -c, --count <COUNT>  Number of times to greet [default: 1]\n  -h, --help           Print help\n  -V, --version        Print version\n\n$ demo --name Me\nHello Me!\n\n```\n*(version number and `.exe` extension on windows replaced by placeholders)*\n\nSee also the derive [tutorial][_derive::_tutorial] and [reference][_derive]\n\n### Related Projects\n\nAugment clap:\n- [wild](https://crates.io/crates/wild) for supporting wildcards (`*`) on Windows like you do Linux\n- [argfile](https://crates.io/crates/argfile) for loading additional arguments from a file (aka response files)\n- [shadow-rs](https://crates.io/crates/shadow-rs) for generating `Command::long_version`\n- [clap_mangen](https://crates.io/crates/clap_mangen) for generating man page source (roff)\n- [clap_complete](https://crates.io/crates/clap_complete) for shell completion support\n\nCLI Helpers\n- [clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag)\n- [clap-cargo](https://crates.io/crates/clap-cargo)\n- [concolor-clap](https://crates.io/crates/concolor-clap)\n\nTesting\n- [`trycmd`](https://crates.io/crates/trycmd):  Bulk snapshot testing\n- [`snapbox`](https://crates.io/crates/snapbox):  Specialized snapshot testing\n- [`assert_cmd`](https://crates.io/crates/assert_cmd) and [`assert_fs`](https://crates.io/crates/assert_fs): Customized testing\n\nDocumentation:\n- [Command-line Apps for Rust](https://rust-cli.github.io/book/index.html) book\n","links":{"_derive::_tutorial":"0:21:1713","_cookbook":"0:7:1709","_features":"0:24:1712","_faq":"0:23:1711","_derive":"0:20:1710","_tutorial":"0:25:1713"},"attrs":["#![doc(html_logo_url =\n\"https://raw.githubusercontent.com/clap-rs/clap/master/assets/clap.png\")]","#![warn(missing_docs, missing_debug_implementations,\nmissing_copy_implementations, trivial_casts, unused_allocation,\ntrivial_numeric_casts, clippy :: single_char_pattern)]","#![forbid(unsafe_code)]","#![allow(clippy :: single_component_path_imports)]","#![allow(clippy :: branches_sharing_code)]","#![allow(clippy :: if_same_then_else)]","#![allow(clippy :: collapsible_else_if)]"],"deprecation":null,"inner":{"module":{"is_crate":true,"items":["0:7:1709","0:20:1710","0:23:1711","0:24:1712","0:25:1713","0:3-20:0:1707"],"is_stripped":false}}},"2:12025:28418":{"id":"2:12025:28418","crate_id":2,"name":"get_mut","span":null,"visibility":"public","docs":"Returns a mutable subslice of `str`.\n\nThis is the non-panicking alternative to indexing the `str`. Returns\n[`None`] whenever equivalent indexing operation would panic.\n\n# Examples\n\n```\nlet mut v = String::from(\"hello\");\n// correct length\nassert!(v.get_mut(0..5).is_some());\n// out of bounds\nassert!(v.get_mut(..42).is_none());\nassert_eq!(Some(\"he\"), v.get_mut(0..2).map(|v| &*v));\n\nassert_eq!(\"hello\", v);\n{\n    let s = v.get_mut(0..2);\n    let s = s.map(|s| {\n        s.make_ascii_uppercase();\n        &*s\n    });\n    assert_eq!(Some(\"HE\"), s);\n}\nassert_eq!(\"HEllo\", v);\n```","links":{"`None`":"2:41396:179"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}],["i",{"generic":"I"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"qualified_path":{"name":"Output","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"I"},"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}}}}}}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"I","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"I"},"bounds":[{"trait_bound":{"trait":{"name":"SliceIndex","id":"2:9813:222","args":{"angle_bracketed":{"args":[{"type":{"primitive":"str"}}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12110:35647":{"id":"2:12110:35647","crate_id":2,"name":"trim_start_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. `start` in this context means the first\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be left side, and for right-to-left languages like\nArabic or Hebrew, this will be the right side.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"11foo1bar11\".trim_start_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_start_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_start_matches(x), \"foo1bar12\");\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12119:35648":{"id":"2:12119:35648","crate_id":2,"name":"trim_end_matches","span":null,"visibility":"public","docs":"Returns a string slice with all suffixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. `end` in this context means the last\nposition of that byte string; for a left-to-right language like English or\nRussian, this will be right side, and for right-to-left languages like\nArabic or Hebrew, this will be the left side.\n\n# Examples\n\nSimple patterns:\n\n```\nassert_eq!(\"11foo1bar11\".trim_end_matches('1'), \"11foo1bar\");\nassert_eq!(\"123foo1bar123\".trim_end_matches(char::is_numeric), \"123foo1bar\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_end_matches(x), \"12foo1bar\");\n```\n\nA more complex pattern, using a closure:\n\n```\nassert_eq!(\"1fooX\".trim_end_matches(|c| c == '1' || c == 'X'), \"1foo\");\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:14:1850":{"id":"0:14:1850","crate_id":0,"name":"git_derive","span":{"filename":"src/_cookbook/git_derive.rs","begin":[1,0],"end":[7,54]},"visibility":"public","docs":"# Example: git-like CLI (Derive API)\n\n```rust\nuse std::ffi::OsStr;\nuse std::ffi::OsString;\nuse std::path::PathBuf;\n\nuse clap::{Args, Parser, Subcommand, ValueEnum};\n\n/// A fictional versioning CLI\n#[derive(Debug, Parser)] // requires `derive` feature\n#[command(name = \"git\")]\n#[command(about = \"A fictional versioning CLI\", long_about = None)]\nstruct Cli {\n    #[command(subcommand)]\n    command: Commands,\n}\n\n#[derive(Debug, Subcommand)]\nenum Commands {\n    /// Clones repos\n    #[command(arg_required_else_help = true)]\n    Clone {\n        /// The remote to clone\n        remote: String,\n    },\n    /// Compare two commits\n    Diff {\n        #[arg(value_name = \"COMMIT\")]\n        base: Option<OsString>,\n        #[arg(value_name = \"COMMIT\")]\n        head: Option<OsString>,\n        #[arg(last = true)]\n        path: Option<OsString>,\n        #[arg(\n            long,\n            require_equals = true,\n            value_name = \"WHEN\",\n            num_args = 0..=1,\n            default_value_t = ColorWhen::Auto,\n            default_missing_value = \"always\",\n            value_enum\n        )]\n        color: ColorWhen,\n    },\n    /// pushes things\n    #[command(arg_required_else_help = true)]\n    Push {\n        /// The remote to target\n        remote: String,\n    },\n    /// adds things\n    #[command(arg_required_else_help = true)]\n    Add {\n        /// Stuff to add\n        #[arg(required = true)]\n        path: Vec<PathBuf>,\n    },\n    Stash(StashArgs),\n    #[command(external_subcommand)]\n    External(Vec<OsString>),\n}\n\n#[derive(ValueEnum, Copy, Clone, Debug, PartialEq, Eq)]\nenum ColorWhen {\n    Always,\n    Auto,\n    Never,\n}\n\nimpl std::fmt::Display for ColorWhen {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.to_possible_value()\n            .expect(\"no values are skipped\")\n            .get_name()\n            .fmt(f)\n    }\n}\n\n#[derive(Debug, Args)]\n#[command(args_conflicts_with_subcommands = true)]\nstruct StashArgs {\n    #[command(subcommand)]\n    command: Option<StashCommands>,\n\n    #[command(flatten)]\n    push: StashPushArgs,\n}\n\n#[derive(Debug, Subcommand)]\nenum StashCommands {\n    Push(StashPushArgs),\n    Pop { stash: Option<String> },\n    Apply { stash: Option<String> },\n}\n\n#[derive(Debug, Args)]\nstruct StashPushArgs {\n    #[arg(short, long)]\n    message: Option<String>,\n}\n\nfn main() {\n    let args = Cli::parse();\n\n    match args.command {\n        Commands::Clone { remote } => {\n            println!(\"Cloning {remote}\");\n        }\n        Commands::Diff {\n            mut base,\n            mut head,\n            mut path,\n            color,\n        } => {\n            if path.is_none() {\n                path = head;\n                head = None;\n                if path.is_none() {\n                    path = base;\n                    base = None;\n                }\n            }\n            let base = base\n                .as_deref()\n                .map(|s| s.to_str().unwrap())\n                .unwrap_or(\"stage\");\n            let head = head\n                .as_deref()\n                .map(|s| s.to_str().unwrap())\n                .unwrap_or(\"worktree\");\n            let path = path.as_deref().unwrap_or_else(|| OsStr::new(\"\"));\n            println!(\n                \"Diffing {}..{} {} (color={})\",\n                base,\n                head,\n                path.to_string_lossy(),\n                color\n            );\n        }\n        Commands::Push { remote } => {\n            println!(\"Pushing to {remote}\");\n        }\n        Commands::Add { path } => {\n            println!(\"Adding {path:?}\");\n        }\n        Commands::Stash(stash) => {\n            let stash_cmd = stash.command.unwrap_or(StashCommands::Push(stash.push));\n            match stash_cmd {\n                StashCommands::Push(push) => {\n                    println!(\"Pushing {push:?}\");\n                }\n                StashCommands::Pop { stash } => {\n                    println!(\"Popping {stash:?}\");\n                }\n                StashCommands::Apply { stash } => {\n                    println!(\"Applying {stash:?}\");\n                }\n            }\n        }\n        Commands::External(args) => {\n            println!(\"Calling out to {:?} with {:?}\", &args[0], &args[1..]);\n        }\n    }\n\n    // Continued program logic goes here...\n}\n```\n\n**This requires enabling the [`derive` feature flag][crate::_features].**\n\nGit is an example of several common subcommand patterns.\n\nHelp:\n```console\n$ git-derive\n? failed\nA fictional versioning CLI\n\nUsage: git-derive[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git-derive help\nA fictional versioning CLI\n\nUsage: git-derive[EXE] <COMMAND>\n\nCommands:\n  clone  Clones repos\n  diff   Compare two commits\n  push   pushes things\n  add    adds things\n  stash  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ git-derive help add\nadds things\n\nUsage: git-derive[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n```\n\nA basic argument:\n```console\n$ git-derive add\n? failed\nadds things\n\nUsage: git-derive[EXE] add <PATH>...\n\nArguments:\n  <PATH>...  Stuff to add\n\nOptions:\n  -h, --help  Print help\n\n$ git-derive add Cargo.toml Cargo.lock\nAdding [\"Cargo.toml\", \"Cargo.lock\"]\n\n```\n\nDefault subcommand:\n```console\n$ git-derive stash -h\nUsage: git-derive[EXE] stash [OPTIONS]\n       git-derive[EXE] stash <COMMAND>\n\nCommands:\n  push   \n  pop    \n  apply  \n  help   Print this message or the help of the given subcommand(s)\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\n$ git-derive stash push -h\nUsage: git-derive[EXE] stash push [OPTIONS]\n\nOptions:\n  -m, --message <MESSAGE>  \n  -h, --help               Print help\n\n$ git-derive stash pop -h\nUsage: git-derive[EXE] stash pop [STASH]\n\nArguments:\n  [STASH]  \n\nOptions:\n  -h, --help  Print help\n\n$ git-derive stash -m \"Prototype\"\nPushing StashPushArgs { message: Some(\"Prototype\") }\n\n$ git-derive stash pop\nPopping None\n\n$ git-derive stash push -m \"Prototype\"\nPushing StashPushArgs { message: Some(\"Prototype\") }\n\n$ git-derive stash pop\nPopping None\n\n```\n\nExternal subcommands:\n```console\n$ git-derive custom-tool arg1 --foo bar\nCalling out to \"custom-tool\" with [\"arg1\", \"--foo\", \"bar\"]\n\n```\n\nLast argument:\n```console\n$ git-derive diff --help\nCompare two commits\n\nUsage: git-derive[EXE] diff [OPTIONS] [COMMIT] [COMMIT] [-- <PATH>]\n\nArguments:\n  [COMMIT]  \n  [COMMIT]  \n  [PATH]    \n\nOptions:\n      --color[=<WHEN>]  [default: auto] [possible values: always, auto, never]\n  -h, --help            Print help\n\n$ git-derive diff\nDiffing stage..worktree  (color=auto)\n\n$ git-derive diff ./src\nDiffing stage..worktree ./src (color=auto)\n\n$ git-derive diff HEAD ./src\nDiffing HEAD..worktree ./src (color=auto)\n\n$ git-derive diff HEAD~~ -- HEAD\nDiffing HEAD~~..worktree HEAD (color=auto)\n\n$ git-derive diff --color\nDiffing stage..worktree  (color=always)\n\n$ git-derive diff --color=never\nDiffing stage..worktree  (color=never)\n\n```","links":{"crate::_features":"0:24:1712"},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12081:35636":{"id":"2:12081:35636","crate_id":2,"name":"split_once","span":null,"visibility":"public","docs":"Splits the string on the first occurrence of the specified delimiter and\nreturns prefix before delimiter and suffix after delimiter.\n\n# Examples\n\n```\nassert_eq!(\"cfg\".split_once('='), None);\nassert_eq!(\"cfg=\".split_once('='), Some((\"cfg\", \"\")));\nassert_eq!(\"cfg=foo\".split_once('='), Some((\"cfg\", \"foo\")));\nassert_eq!(\"cfg=foo=bar\".split_once('='), Some((\"cfg\", \"foo=bar\")));\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["delimiter",{"generic":"P"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"tuple":[{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}},{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}}]}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12087:2606":{"id":"2:12087:2606","crate_id":2,"name":"matches","span":null,"visibility":"public","docs":"An iterator over the disjoint matches of a pattern within the given string\nslice.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rmatches`] method can be used.\n\n[`rmatches`]: str::matches\n\n# Examples\n\nBasic usage:\n\n```\nlet v: Vec<&str> = \"abcXXXabcYYYabc\".matches(\"abc\").collect();\nassert_eq!(v, [\"abc\", \"abc\", \"abc\"]);\n\nlet v: Vec<&str> = \"1abc2abc3\".matches(char::is_numeric).collect();\nassert_eq!(v, [\"1\", \"2\", \"3\"]);\n```","links":{"self::pattern":"2:11712:8907","`DoubleEndedIterator`":"2:7240:121","prim@char":"1:11888:419","str::matches":"2:12087:2606"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"Matches","id":"2:43561:8924","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12138:35653":{"id":"2:12138:35653","crate_id":2,"name":"escape_unicode","span":null,"visibility":"public","docs":"Return an iterator that escapes each char in `self` with [`char::escape_unicode`].\n\n# Examples\n\nAs an iterator:\n\n```\nfor c in \"‚ù§\\n!\".escape_unicode() {\n    print!(\"{c}\");\n}\nprintln!();\n```\n\nUsing `println!` directly:\n\n```\nprintln!(\"{}\", \"‚ù§\\n!\".escape_unicode());\n```\n\n\nBoth are equivalent to:\n\n```\nprintln!(\"\\\\u{{2764}}\\\\u{{a}}\\\\u{{21}}\");\n```\n\nUsing `to_string`:\n\n```\nassert_eq!(\"‚ù§\\n!\".escape_unicode().to_string(), \"\\\\u{2764}\\\\u{a}\\\\u{21}\");\n```","links":{"`char::escape_unicode`":"2:4533:35653"},"attrs":["#[must_use =\n\"this returns the escaped string as an iterator, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"EscapeUnicode","id":"2:43674:8919","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12056:20659":{"id":"2:12056:20659","crate_id":2,"name":"rfind","span":null,"visibility":"public","docs":"Returns the byte index for the first character of the last match of the pattern in\nthis string slice.\n\nReturns [`None`] if the pattern doesn't match.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\nSimple patterns:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard Gepardi\";\n\nassert_eq!(s.rfind('L'), Some(13));\nassert_eq!(s.rfind('√©'), Some(14));\nassert_eq!(s.rfind(\"pard\"), Some(24));\n```\n\nMore complex patterns with closures:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nassert_eq!(s.rfind(char::is_whitespace), Some(12));\nassert_eq!(s.rfind(char::is_lowercase), Some(20));\n```\n\nNot finding the pattern:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\nlet x: &[_] = &['1', '2'];\n\nassert_eq!(s.rfind(x), None);\n```","links":{"`None`":"2:41396:179","prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"primitive":"usize"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5387:36305":{"id":"5:5387:36305","crate_id":5,"name":"replacen","span":null,"visibility":"public","docs":"Replaces first N matches of a pattern with another string.\n\n`replacen` creates a new [`String`], and copies the data from this string slice into it.\nWhile doing so, it attempts to find matches of a pattern. If it finds any, it\nreplaces them with the replacement string slice at most `count` times.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"foo foo 123 foo\";\nassert_eq!(\"new new 123 foo\", s.replacen(\"foo\", \"new\", 2));\nassert_eq!(\"faa fao 123 foo\", s.replacen('o', \"a\", 3));\nassert_eq!(\"foo foo new23 foo\", s.replacen(char::is_numeric, \"new\", 1));\n```\n\nWhen the pattern doesn't match, it returns this string slice as [`String`]:\n\n```\nlet s = \"this is old\";\nassert_eq!(s, s.replacen(\"cookie monster\", \"little lamb\", 10));\n```","links":{"`String`":"5:7241:224"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the replaced string as a new allocation, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}],["to",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}}],["count",{"primitive":"usize"}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:18:1854":{"id":"0:18:1854","crate_id":0,"name":"repl","span":{"filename":"src/_cookbook/repl.rs","begin":[1,0],"end":[5,7]},"visibility":"public","docs":"# Example: Command REPL (Builder API)\n\n```rust\nuse std::io::Write;\n\nuse clap::Command;\n\nfn main() -> Result<(), String> {\n    loop {\n        let line = readline()?;\n        let line = line.trim();\n        if line.is_empty() {\n            continue;\n        }\n\n        match respond(line) {\n            Ok(quit) => {\n                if quit {\n                    break;\n                }\n            }\n            Err(err) => {\n                write!(std::io::stdout(), \"{err}\").map_err(|e| e.to_string())?;\n                std::io::stdout().flush().map_err(|e| e.to_string())?;\n            }\n        }\n    }\n\n    Ok(())\n}\n\nfn respond(line: &str) -> Result<bool, String> {\n    let args = shlex::split(line).ok_or(\"error: Invalid quoting\")?;\n    let matches = cli()\n        .try_get_matches_from(args)\n        .map_err(|e| e.to_string())?;\n    match matches.subcommand() {\n        Some((\"ping\", _matches)) => {\n            write!(std::io::stdout(), \"Pong\").map_err(|e| e.to_string())?;\n            std::io::stdout().flush().map_err(|e| e.to_string())?;\n        }\n        Some((\"quit\", _matches)) => {\n            write!(std::io::stdout(), \"Exiting ...\").map_err(|e| e.to_string())?;\n            std::io::stdout().flush().map_err(|e| e.to_string())?;\n            return Ok(true);\n        }\n        Some((name, _matches)) => unimplemented!(\"{name}\"),\n        None => unreachable!(\"subcommand required\"),\n    }\n\n    Ok(false)\n}\n\nfn cli() -> Command {\n    // strip out usage\n    const PARSER_TEMPLATE: &str = \"\\\n        {all-args}\n    \";\n    // strip out name/version\n    const APPLET_TEMPLATE: &str = \"\\\n        {about-with-newline}\\n\\\n        {usage-heading}\\n    {usage}\\n\\\n        \\n\\\n        {all-args}{after-help}\\\n    \";\n\n    Command::new(\"repl\")\n        .multicall(true)\n        .arg_required_else_help(true)\n        .subcommand_required(true)\n        .subcommand_value_name(\"APPLET\")\n        .subcommand_help_heading(\"APPLETS\")\n        .help_template(PARSER_TEMPLATE)\n        .subcommand(\n            Command::new(\"ping\")\n                .about(\"Get a response\")\n                .help_template(APPLET_TEMPLATE),\n        )\n        .subcommand(\n            Command::new(\"quit\")\n                .alias(\"exit\")\n                .about(\"Quit the REPL\")\n                .help_template(APPLET_TEMPLATE),\n        )\n}\n\nfn readline() -> Result<String, String> {\n    write!(std::io::stdout(), \"$ \").map_err(|e| e.to_string())?;\n    std::io::stdout().flush().map_err(|e| e.to_string())?;\n    let mut buffer = String::new();\n    std::io::stdin()\n        .read_line(&mut buffer)\n        .map_err(|e| e.to_string())?;\n    Ok(buffer)\n}\n```","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"5:5390:36306":{"id":"5:5390:36306","crate_id":5,"name":"to_lowercase","span":null,"visibility":"public","docs":"Returns the lowercase equivalent of this string slice, as a new [`String`].\n\n'Lowercase' is defined according to the terms of the Unicode Derived Core Property\n`Lowercase`.\n\nSince some characters can expand into multiple characters when changing\nthe case, this function returns a [`String`] instead of modifying the\nparameter in-place.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"HELLO\";\n\nassert_eq!(\"hello\", s.to_lowercase());\n```\n\nA tricky example, with sigma:\n\n```\nlet sigma = \"Œ£\";\n\nassert_eq!(\"œÉ\", sigma.to_lowercase());\n\n// but at the end of a word, it's œÇ, not œÉ:\nlet odysseus = \"·ΩàŒîŒ•Œ£Œ£ŒïŒéŒ£\";\n\nassert_eq!(\"·ΩÄŒ¥œÖœÉœÉŒµœçœÇ\", odysseus.to_lowercase());\n```\n\nLanguages without case are not changed:\n\n```\nlet new_year = \"ÂÜúÂéÜÊñ∞Âπ¥\";\n\nassert_eq!(new_year, new_year.to_lowercase());\n```","links":{"`String`":"5:7241:224"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use =\n\"this returns the lowercase string as a new String, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"5:5401:27696":{"id":"5:5401:27696","crate_id":5,"name":"to_ascii_uppercase","span":null,"visibility":"public","docs":"Returns a copy of this string where each character is mapped to its\nASCII upper case equivalent.\n\nASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\nbut non-ASCII letters are unchanged.\n\nTo uppercase the value in-place, use [`make_ascii_uppercase`].\n\nTo uppercase ASCII characters in addition to non-ASCII characters, use\n[`to_uppercase`].\n\n# Examples\n\n```\nlet s = \"Gr√º√üe, J√ºrgen ‚ù§\";\n\nassert_eq!(\"GR√º√üE, J√ºRGEN ‚ù§\", s.to_ascii_uppercase());\n```\n\n[`make_ascii_uppercase`]: str::make_ascii_uppercase\n[`to_uppercase`]: #method.to_uppercase","links":{"str::make_ascii_uppercase":"2:12133:27694"},"attrs":["#[cfg(not(no_global_oom_handling))]","#[must_use = \"to uppercase the value in-place, use `make_ascii_uppercase()`\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"String","id":"5:7241:224","args":{"angle_bracketed":{"args":[],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12038:33048":{"id":"2:12038:33048","crate_id":2,"name":"split_whitespace","span":null,"visibility":"public","docs":"Splits a string slice by whitespace.\n\nThe iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of whitespace.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`. If you only want to split on ASCII whitespace\ninstead, use [`split_ascii_whitespace`].\n\n[`split_ascii_whitespace`]: str::split_ascii_whitespace\n\n# Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nAll kinds of whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta\\u{2009}little  \\n\\t lamb\".split_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nIf the string is empty or all whitespace, the iterator yields no string slices:\n```\nassert_eq!(\"\".split_whitespace().next(), None);\nassert_eq!(\"   \".split_whitespace().next(), None);\n```","links":{"str::split_ascii_whitespace":"2:12039:33037"},"attrs":["#[must_use =\n\"this returns the split string as an iterator, \\\n                  without modifying the original\"]","#[rustc_diagnostic_item = \"str_split_whitespace\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"SplitWhitespace","id":"2:43631:8910","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:20:1710":{"id":"0:20:1710","crate_id":0,"name":"_derive","span":{"filename":"src/_derive/mod.rs","begin":[1,0],"end":[490,25]},"visibility":"public","docs":"# Documentation: Derive Reference\n\n1. [Overview](#overview)\n2. [Attributes](#attributes)\n    1. [Terminology](#terminology)\n    2. [Command Attributes](#command-attributes)\n    2. [ArgGroup Attributes](#arggroup-attributes)\n    3. [Arg Attributes](#arg-attributes)\n    4. [ValueEnum Attributes](#valueenum-attributes)\n    5. [Possible Value Attributes](#possible-value-attributes)\n3. [Arg Types](#arg-types)\n4. [Doc Comments](#doc-comments)\n5. [Mixing Builder and Derive APIs](#mixing-builder-and-derive-apis)\n6. [Tips](#tips)\n\n## Overview\n\nTo derive `clap` types, you need to enable the [`derive` feature flag][crate::_features].\n\nExample:\n```rust\nuse clap::Parser;\n\n/// Simple program to greet a person\n#[derive(Parser, Debug)]\n#[command(author, version, about, long_about = None)]\nstruct Args {\n    /// Name of the person to greet\n    #[arg(short, long)]\n    name: String,\n\n    /// Number of times to greet\n    #[arg(short, long, default_value_t = 1)]\n    count: u8,\n}\n\nfn main() {\n    let args = Args::parse();\n\n    for _ in 0..args.count {\n        println!(\"Hello {}!\", args.name)\n    }\n}\n```\n\nLet's start by breaking down the anatomy of the derive attributes:\n```rust\nuse clap::{Parser, Args, Subcommand, ValueEnum};\n\n/// Doc comment\n#[derive(Parser)]\n#[command(CMD ATTRIBUTE)]\n#[group(GROUP ATTRIBUTE)]\nstruct Cli {\n    /// Doc comment\n    #[arg(ARG ATTRIBUTE)]\n    field: UserType,\n\n    #[arg(value_enum, ARG ATTRIBUTE...)]\n    field: EnumValues,\n\n    #[command(flatten)]\n    delegate: Struct,\n\n    #[command(subcommand)]\n    command: Command,\n}\n\n/// Doc comment\n#[derive(Args)]\n#[command(PARENT CMD ATTRIBUTE)]\n#[group(GROUP ATTRIBUTE)]\nstruct Struct {\n    /// Doc comment\n    #[command(ARG ATTRIBUTE)]\n    field: UserType,\n}\n\n/// Doc comment\n#[derive(Subcommand)]\n#[command(PARENT CMD ATTRIBUTE)]\nenum Command {\n    /// Doc comment\n    #[command(CMD ATTRIBUTE)]\n    Variant1(Struct),\n\n    /// Doc comment\n    #[command(CMD ATTRIBUTE)]\n    Variant2 {\n        /// Doc comment\n        #[arg(ARG ATTRIBUTE)]\n        field: UserType,\n    }\n}\n\n/// Doc comment\n#[derive(ValueEnum)]\n#[value(VALUE ENUM ATTRIBUTE)]\nenum EnumValues {\n    /// Doc comment\n    #[value(POSSIBLE VALUE ATTRIBUTE)]\n    Variant1,\n}\n\nfn main() {\n    let cli = Cli::parse();\n}\n```\n\nTraits:\n- [`Parser`][crate::Parser] parses arguments into a `struct` (arguments) or `enum` (subcommands).\n  - [`Args`][crate::Args] allows defining a set of re-usable arguments that get merged into their parent container.\n  - [`Subcommand`][crate::Subcommand] defines available subcommands.\n  - Subcommand arguments can be defined in a struct-variant or automatically flattened with a tuple-variant.\n- [`ValueEnum`][crate::ValueEnum] allows parsing a value directly into an `enum`, erroring on unsupported values.\n  - The derive doesn't work on enums that contain non-unit variants, unless they are skipped\n\n*See also the [derive tutorial][crate::_derive::_tutorial] and [cookbook][crate::_cookbook]*\n\n## Attributes\n\n### Terminology\n\n**Raw attributes** are forwarded directly to the underlying [`clap` builder][crate::builder].  Any\n[`Command`][crate::Command], [`Arg`][crate::Arg], or [`PossibleValue`][crate::builder::PossibleValue] method can be used as an attribute.\n\nRaw attributes come in two different syntaxes:\n```rust,ignore\n#[arg(\n    global = true, // name = arg form, neat for one-arg methods\n    required_if_eq(\"out\", \"file\") // name(arg1, arg2, ...) form.\n)]\n```\n\n- `method = arg` can only be used for methods which take only one argument.\n- `method(arg1, arg2)` can be used with any method.\n\nAs long as `method_name` is not one of the magical methods it will be\ntranslated into a mere method call.\n\n**Magic attributes** have post-processing done to them, whether that is\n- Providing of defaults\n- Special behavior is triggered off of it\n\nMagic attributes are more constrained in the syntax they support, usually just\n`<attr> = <value>` though some use `<attr>(<value>)` instead.  See the specific\nmagic attributes documentation for details.  This allows users to access the\nraw behavior of an attribute via `<attr>(<value>)` syntax.\n\n**NOTE:** Some attributes are inferred from [Arg Types](#arg-types) and [Doc\nComments](#doc-comments).  Explicit attributes take precedence over inferred\nattributes.\n\n### Command Attributes\n\nThese correspond to a [`Command`][crate::Command] which is used for both top-level parsers and\nwhen defining subcommands.\n\n**Raw attributes:**  Any [`Command` method][crate::Command] can also be used as an attribute,\nsee [Terminology](#terminology) for syntax.\n- e.g. `#[command(arg_required_else_help(true))]` would translate to `cmd.arg_required_else_help(true)`\n\n**Magic attributes:**\n- `name  = <expr>`: [`Command::name`][crate::Command::name]\n  - When not present: [package `name`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-name-field) (if on [`Parser`][crate::Parser] container), variant name (if on [`Subcommand`][crate::Subcommand] variant)\n- `version [= <expr>]`: [`Command::version`][crate::Command::version]\n  - When not present: no version set\n  - Without `<expr>`: defaults to [crate `version`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-version-field)\n- `author [= <expr>]`: [`Command::author`][crate::Command::author]\n  - When not present: no author set\n  - Without `<expr>`: defaults to [crate `authors`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-authors-field)\n- `about [= <expr>]`: [`Command::about`][crate::Command::about]\n  - When not present: [Doc comment summary](#doc-comments)\n  - Without `<expr>`: [crate `description`](https://doc.rust-lang.org/cargo/reference/manifest.html#the-description-field) ([`Parser`][crate::Parser] container)\n    - **TIP:** When a doc comment is also present, you most likely want to add\n      `#[arg(long_about = None)]` to clear the doc comment so only [`about`][crate::Command::about]\n      gets shown with both `-h` and `--help`.\n- `long_about[ = <expr>]`: [`Command::long_about`][crate::Command::long_about]\n  - When not present: [Doc comment](#doc-comments) if there is a blank line, else nothing\n  - When present without a value: [Doc comment](#doc-comments)\n- `verbatim_doc_comment`: Minimizes pre-processing when converting doc comments to [`about`][crate::Command::about] / [`long_about`][crate::Command::long_about]\n- `next_display_order`: [`Command::next_display_order`][crate::Command::next_display_order]\n- `next_help_heading`: [`Command::next_help_heading`][crate::Command::next_help_heading]\n  - When `flatten`ing [`Args`][crate::Args], this is scoped to just the args in this struct and any struct `flatten`ed into it\n- `rename_all = <string_literal>`: Override default field / variant name case conversion for [`Command::name`][crate::Command::name] / [`Arg::id`][crate::Arg::id]\n  - When not present: `\"kebab-case\"`\n  - Available values: `\"camelCase\"`, `\"kebab-case\"`, `\"PascalCase\"`, `\"SCREAMING_SNAKE_CASE\"`, `\"snake_case\"`, `\"lower\"`, `\"UPPER\"`, `\"verbatim\"`\n- `rename_all_env = <string_literal>`: Override default field name case conversion for env variables for  [`Arg::env`][crate::Arg::env]\n  - When not present: `\"SCREAMING_SNAKE_CASE\"`\n  - Available values: `\"camelCase\"`, `\"kebab-case\"`, `\"PascalCase\"`, `\"SCREAMING_SNAKE_CASE\"`, `\"snake_case\"`, `\"lower\"`, `\"UPPER\"`, `\"verbatim\"`\n\nAnd for [`Subcommand`][crate::Subcommand] variants:\n- `skip`: Ignore this variant\n- `flatten`: Delegates to the variant for more subcommands (must implement\n  [`Subcommand`][crate::Subcommand])\n- `subcommand`: Nest subcommands under the current set of subcommands (must implement\n  [`Subcommand`][crate::Subcommand])\n- `external_subcommand`: [`Command::allow_external_subcommand(true)`][crate::Command::allow_external_subcommands]\n  - Variant must be either `Variant(Vec<String>)` or `Variant(Vec<OsString>)`\n\nAnd for [`Args`][crate::Args] fields:\n- `flatten`: Delegates to the field for more arguments (must implement [`Args`][crate::Args])\n  - Only [`next_help_heading`][crate::Command::next_help_heading] can be used with `flatten`.  See\n    [clap-rs/clap#3269](https://github.com/clap-rs/clap/issues/3269) for why\n    arg attributes are not generally supported.\n  - **Tip:** Though we do apply a flattened [`Args`][crate::Args]'s Parent Command Attributes, this\n    makes reuse harder. Generally prefer putting the cmd attributes on the\n    [`Parser`][crate::Parser] or on the flattened field.\n- `subcommand`: Delegates definition of subcommands to the field (must implement\n  [`Subcommand`][crate::Subcommand])\n  - When `Option<T>`, the subcommand becomes optional\n\n### ArgGroup Attributes\n\nThese correspond to the [`ArgGroup`][crate::ArgGroup] which is implicitly created for each\n`Args` derive.\n\n**Raw attributes:**  Any [`ArgGroup` method][crate::ArgGroup] can also be used as an attribute, see [Terminology](#terminology) for syntax.\n- e.g. `#[group(required = true)]` would translate to `arg_group.required(true)`\n\n**Magic attributes**:\n- `id = <expr>`: [`ArgGroup::id`][crate::ArgGroup::id]\n  - When not present: struct's name is used\n- `skip [= <expr>]`: Ignore this field, filling in with `<expr>`\n  - Without `<expr>`: fills the field with `Default::default()`\n\n### Arg Attributes\n\nThese correspond to a [`Arg`][crate::Arg].\n\n**Raw attributes:**  Any [`Arg` method][crate::Arg] can also be used as an attribute, see [Terminology](#terminology) for syntax.\n- e.g. `#[arg(max_values(3))]` would translate to `arg.max_values(3)`\n\n**Magic attributes**:\n- `id = <expr>`: [`Arg::id`][crate::Arg::id]\n  - When not present: field's name is used\n- `value_parser [= <expr>]`: [`Arg::value_parser`][crate::Arg::value_parser]\n  - When not present: will auto-select an implementation based on the field type using\n    [`value_parser!`][crate::value_parser!]\n- `action [= <expr>]`: [`Arg::action`][crate::Arg::action]\n  - When not present: will auto-select an action based on the field type\n- `help = <expr>`: [`Arg::help`][crate::Arg::help]\n  - When not present: [Doc comment summary](#doc-comments)\n- `long_help[ = <expr>]`: [`Arg::long_help`][crate::Arg::long_help]\n  - When not present: [Doc comment](#doc-comments) if there is a blank line, else nothing\n  - When present without a value: [Doc comment](#doc-comments)\n- `verbatim_doc_comment`: Minimizes pre-processing when converting doc comments to [`help`][crate::Arg::help] / [`long_help`][crate::Arg::long_help]\n- `short [= <char>]`: [`Arg::short`][crate::Arg::short]\n  - When not present: no short set\n  - Without `<char>`: defaults to first character in the case-converted field name\n- `long [= <str>]`: [`Arg::long`][crate::Arg::long]\n  - When not present: no long set\n  - Without `<str>`: defaults to the case-converted field name\n- `env [= <str>]`: [`Arg::env`][crate::Arg::env] (needs [`env` feature][crate::_features] enabled)\n  - When not present: no env set\n  - Without `<str>`: defaults to the case-converted field name\n- `from_global`: Read a [`Arg::global`][crate::Arg::global] argument (raw attribute), regardless of what subcommand you are in\n- `value_enum`: Parse the value using the [`ValueEnum`][crate::ValueEnum]\n- `skip [= <expr>]`: Ignore this field, filling in with `<expr>`\n  - Without `<expr>`: fills the field with `Default::default()`\n- `default_value = <str>`: [`Arg::default_value`][crate::Arg::default_value] and [`Arg::required(false)`][crate::Arg::required]\n- `default_value_t [= <expr>]`: [`Arg::default_value`][crate::Arg::default_value] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires `std::fmt::Display` that roundtrips correctly with the\n    [`Arg::value_parser`][crate::Arg::value_parser] or `#[arg(value_enum)]`\n  - Without `<expr>`, relies on `Default::default()`\n- `default_values_t = <expr>`: [`Arg::default_values`][crate::Arg::default_values] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires field arg to be of type `Vec<T>` and `T` to implement `std::fmt::Display` or `#[arg(value_enum)]`\n  - `<expr>` must implement `IntoIterator<T>`\n- `default_value_os_t [= <expr>]`: [`Arg::default_value_os`][crate::Arg::default_value_os] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires `std::convert::Into<OsString>` or `#[arg(value_enum)]`\n  - Without `<expr>`, relies on `Default::default()`\n- `default_values_os_t = <expr>`: [`Arg::default_values_os`][crate::Arg::default_values_os] and [`Arg::required(false)`][crate::Arg::required]\n  - Requires field arg to be of type `Vec<T>` and `T` to implement `std::convert::Into<OsString>` or `#[arg(value_enum)]`\n  - `<expr>` must implement `IntoIterator<T>`\n\n### ValueEnum Attributes\n\n- `rename_all = <string_literal>`: Override default field / variant name case conversion for [`PossibleValue::new`][crate::builder::PossibleValue]\n  - When not present: `\"kebab-case\"`\n  - Available values: `\"camelCase\"`, `\"kebab-case\"`, `\"PascalCase\"`, `\"SCREAMING_SNAKE_CASE\"`, `\"snake_case\"`, `\"lower\"`, `\"UPPER\"`, `\"verbatim\"`\n\n### Possible Value Attributes\n\nThese correspond to a [`PossibleValue`][crate::builder::PossibleValue].\n\n**Raw attributes:**  Any [`PossibleValue` method][crate::builder::PossibleValue] can also be used as an attribute, see [Terminology](#terminology) for syntax.\n- e.g. `#[value(alias(\"foo\"))]` would translate to `pv.alias(\"foo\")`\n\n**Magic attributes**:\n- `name = <expr>`: [`PossibleValue::new`][crate::builder::PossibleValue::new]\n  - When not present: case-converted field name is used\n- `help = <expr>`: [`PossibleValue::help`][crate::builder::PossibleValue::help]\n  - When not present: [Doc comment summary](#doc-comments)\n- `skip`: Ignore this variant\n\n## Arg Types\n\n`clap` assumes some intent based on the type used:\n\n| Type                | Effect                               | Implies                                                     |\n|---------------------|--------------------------------------|-------------------------------------------------------------|\n| `()`                | user-defined                         | `.action(ArgAction::Set).required(false)`                   |\n| `bool`              | flag                                 | `.action(ArgAction::SetTrue)`                               |\n| `Option<T>`         | optional argument                    | `.action(ArgAction::Set).required(false)`                   |\n| `Option<Option<T>>` | optional value for optional argument | `.action(ArgAction::Set).required(false).num_args(0..=1)`   |\n| `T`                 | required argument                    | `.action(ArgAction::Set).required(!has_default)`            |\n| `Vec<T>`            | `0..` occurrences of argument        | `.action(ArgAction::Append).required(false)`  |\n| `Option<Vec<T>>`    | `0..` occurrences of argument        | `.action(ArgAction::Append).required(false)`  |\n\nIn addition, [`.value_parser(value_parser!(T))`][crate::value_parser!] is called for each\nfield.\n\nNotes:\n- For custom type behavior, you can override the implied attributes/settings and/or set additional ones\n  - To force any inferred type (like `Vec<T>`) to be treated as `T`, you can refer to the type\n    by another means, like using `std::vec::Vec` instead of `Vec`.  For improving this, see\n    [#4626](https://github.com/clap-rs/clap/issues/4626).\n- `Option<Vec<T>>` will be `None` instead of `vec![]` if no arguments are provided.\n  - This gives the user some flexibility in designing their argument, like with `num_args(0..)`\n\n## Doc Comments\n\nIn clap, help messages for the whole binary can be specified\nvia [`Command::about`][crate::Command::about] and [`Command::long_about`][crate::Command::long_about] while help messages\nfor individual arguments can be specified via [`Arg::help`][crate::Arg::help] and [`Arg::long_help`][crate::Arg::long_help].\n\n`long_*` variants are used when user calls the program with\n`--help` and \"short\" variants are used with `-h` flag.\n\n```rust\n# use clap::Parser;\n\n#[derive(Parser)]\n#[command(about = \"I am a program and I work, just pass `-h`\", long_about = None)]\nstruct Foo {\n    #[arg(short, help = \"Pass `-h` and you'll see me!\")]\n    bar: String,\n}\n```\n\nFor convenience, doc comments can be used instead of raw methods\n(this example works exactly like the one above):\n\n```rust\n# use clap::Parser;\n\n#[derive(Parser)]\n/// I am a program and I work, just pass `-h`\nstruct Foo {\n    /// Pass `-h` and you'll see me!\n    bar: String,\n}\n```\n\n**NOTE:** Attributes have priority over doc comments!\n\n**Top level doc comments always generate `Command::about/long_about` calls!**\nIf you really want to use the `Command::about/long_about` methods (you likely don't),\nuse the `about` / `long_about` attributes to override the calls generated from\nthe doc comment.  To clear `long_about`, you can use\n`#[command(long_about = None)]`.\n\n### Pre-processing\n\n```rust\n# use clap::Parser;\n#[derive(Parser)]\n/// Hi there, I'm Robo!\n///\n/// I like beeping, stumbling, eating your electricity,\n/// and making records of you singing in a shower.\n/// Pay up, or I'll upload it to youtube!\nstruct Robo {\n    /// Call my brother SkyNet.\n    ///\n    /// I am artificial superintelligence. I won't rest\n    /// until I'll have destroyed humanity. Enjoy your\n    /// pathetic existence, you mere mortals.\n    #[arg(long, action)]\n    kill_all_humans: bool,\n}\n```\n\nA doc comment consists of three parts:\n- Short summary\n- A blank line (whitespace only)\n- Detailed description, all the rest\n\nThe summary corresponds with `Command::about` / `Arg::help`.  When a blank line is\npresent, the whole doc comment will be passed to `Command::long_about` /\n`Arg::long_help`.  Or in other words, a doc may result in just a `Command::about` /\n`Arg::help` or `Command::about` / `Arg::help` and `Command::long_about` /\n`Arg::long_help`\n\nIn addition, when `verbatim_doc_comment` is not present, `clap` applies some preprocessing, including:\n\n- Strip leading and trailing whitespace from every line, if present.\n\n- Strip leading and trailing blank lines, if present.\n\n- Interpret each group of non-empty lines as a word-wrapped paragraph.\n\n  We replace newlines within paragraphs with spaces to allow the output\n  to be re-wrapped to the terminal width.\n\n- Strip any excess blank lines so that there is exactly one per paragraph break.\n\n- If the first paragraph ends in exactly one period,\n  remove the trailing period (i.e. strip trailing periods but not trailing ellipses).\n\nSometimes you don't want this preprocessing to apply, for example the comment contains\nsome ASCII art or markdown tables, you would need to preserve LFs along with\nblank lines and the leading/trailing whitespace. When you pass use the\n`verbatim_doc_comment` magic attribute, you  preserve\nthem.\n\n**Note:** Keep in mind that `verbatim_doc_comment` will *still*\n- Remove one leading space from each line, even if this attribute is present,\n  to allow for a space between `///` and the content.\n- Remove leading and trailing blank lines\n\n## Mixing Builder and Derive APIs\n\nThe builder and derive APIs do not live in isolation. They can work together, which is\nespecially helpful if some arguments can be specified at compile-time while others must be\nspecified at runtime.\n\n### Using derived arguments in a builder application\n\nWhen using the derive API, you can `#[command(flatten)]` a struct deriving `Args` into a struct\nderiving `Args` or `Parser`. This example shows how you can augment a `Command` instance\ncreated using the builder API with `Args` created using the derive API.\n\nIt uses the [`Args::augment_args`][crate::Args::augment_args] method to add the arguments to\nthe `Command` instance.\n\nCrates such as [clap-verbosity-flag](https://github.com/rust-cli/clap-verbosity-flag) provide\nstructs that implement `Args`. Without the technique shown in this example, it would not be\npossible to use such crates with the builder API.\n\nFor example:\n```rust\nuse clap::{arg, Args, Command, FromArgMatches as _};\n\n#[derive(Args, Debug)]\nstruct DerivedArgs {\n    #[arg(short, long)]\n    derived: bool,\n}\n\nfn main() {\n    let cli = Command::new(\"CLI\").arg(arg!(-b - -built).action(clap::ArgAction::SetTrue));\n    // Augment built args with derived args\n    let cli = DerivedArgs::augment_args(cli);\n\n    let matches = cli.get_matches();\n    println!(\"Value of built: {:?}\", matches.get_flag(\"built\"));\n    println!(\n        \"Value of derived via ArgMatches: {:?}\",\n        matches.get_flag(\"derived\")\n    );\n\n    // Since DerivedArgs implements FromArgMatches, we can extract it from the unstructured ArgMatches.\n    // This is the main benefit of using derived arguments.\n    let derived_matches = DerivedArgs::from_arg_matches(&matches)\n        .map_err(|err| err.exit())\n        .unwrap();\n    println!(\"Value of derived: {derived_matches:#?}\");\n}\n```\n\n### Using derived subcommands in a builder application\n\nWhen using the derive API, you can use `#[command(subcommand)]` inside the struct to add\nsubcommands. The type of the field is usually an enum that derived `Parser`. However, you can\nalso add the subcommands in that enum to a `Command` instance created with the builder API.\n\nIt uses the [`Subcommand::augment_subcommands`][crate::Subcommand::augment_subcommands] method\nto add the subcommands to the `Command` instance.\n\nFor example:\n```rust\nuse clap::{Command, FromArgMatches as _, Parser, Subcommand as _};\n\n#[derive(Parser, Debug)]\nenum Subcommands {\n    Derived {\n        #[arg(short, long)]\n        derived_flag: bool,\n    },\n}\n\nfn main() {\n    let cli = Command::new(\"Built CLI\");\n    // Augment with derived subcommands\n    let cli = Subcommands::augment_subcommands(cli);\n\n    let matches = cli.get_matches();\n    let derived_subcommands = Subcommands::from_arg_matches(&matches)\n        .map_err(|err| err.exit())\n        .unwrap();\n    println!(\"Derived subcommands: {derived_subcommands:#?}\");\n}\n```\n\n### Adding hand-implemented subcommands to a derived application\n\nWhen using the derive API, you can use `#[command(subcommand)]` inside the struct to add\nsubcommands. The type of the field is usually an enum that derived `Parser`. However, you can\nalso implement the `Subcommand` trait manually on this enum (or any other type) and it can\nstill be used inside the struct created with the derive API. The implementation of the\n`Subcommand` trait will use the builder API to add the subcommands to the `Command` instance\ncreated behind the scenes for you by the derive API.\n\nNotice how in the previous example we used\n[`augment_subcommands`][crate::Subcommand::augment_subcommands] on an enum that derived\n`Parser`, whereas now we implement\n[`augment_subcommands`][crate::Subcommand::augment_subcommands] ourselves, but the derive API\ncalls it automatically since we used the `#[command(subcommand)]` attribute.\n\nFor example:\n```rust\nuse clap::error::{Error, ErrorKind};\nuse clap::{ArgMatches, Args as _, Command, FromArgMatches, Parser, Subcommand};\n\n#[derive(Parser, Debug)]\nstruct AddArgs {\n    name: Vec<String>,\n}\n#[derive(Parser, Debug)]\nstruct RemoveArgs {\n    #[arg(short, long)]\n    force: bool,\n    name: Vec<String>,\n}\n\n#[derive(Debug)]\nenum CliSub {\n    Add(AddArgs),\n    Remove(RemoveArgs),\n}\n\nimpl FromArgMatches for CliSub {\n    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {\n        match matches.subcommand() {\n            Some((\"add\", args)) => Ok(Self::Add(AddArgs::from_arg_matches(args)?)),\n            Some((\"remove\", args)) => Ok(Self::Remove(RemoveArgs::from_arg_matches(args)?)),\n            Some((_, _)) => Err(Error::raw(\n                ErrorKind::InvalidSubcommand,\n                \"Valid subcommands are `add` and `remove`\",\n            )),\n            None => Err(Error::raw(\n                ErrorKind::MissingSubcommand,\n                \"Valid subcommands are `add` and `remove`\",\n            )),\n        }\n    }\n    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {\n        match matches.subcommand() {\n            Some((\"add\", args)) => *self = Self::Add(AddArgs::from_arg_matches(args)?),\n            Some((\"remove\", args)) => *self = Self::Remove(RemoveArgs::from_arg_matches(args)?),\n            Some((_, _)) => {\n                return Err(Error::raw(\n                    ErrorKind::InvalidSubcommand,\n                    \"Valid subcommands are `add` and `remove`\",\n                ))\n            }\n            None => (),\n        };\n        Ok(())\n    }\n}\n\nimpl Subcommand for CliSub {\n    fn augment_subcommands(cmd: Command) -> Command {\n        cmd.subcommand(AddArgs::augment_args(Command::new(\"add\")))\n            .subcommand(RemoveArgs::augment_args(Command::new(\"remove\")))\n            .subcommand_required(true)\n    }\n    fn augment_subcommands_for_update(cmd: Command) -> Command {\n        cmd.subcommand(AddArgs::augment_args(Command::new(\"add\")))\n            .subcommand(RemoveArgs::augment_args(Command::new(\"remove\")))\n            .subcommand_required(true)\n    }\n    fn has_subcommand(name: &str) -> bool {\n        matches!(name, \"add\" | \"remove\")\n    }\n}\n\n#[derive(Parser, Debug)]\nstruct Cli {\n    #[arg(short, long)]\n    top_level: bool,\n    #[command(subcommand)]\n    subcommand: CliSub,\n}\n\nfn main() {\n    let args = Cli::parse();\n    println!(\"{args:#?}\");\n}\n```\n\n### Flattening hand-implemented args into a derived application\n\nWhen using the derive API, you can use `#[command(flatten)]` inside the struct to add arguments as\nif they were added directly to the containing struct. The type of the field is usually an\nstruct that derived `Args`. However, you can also implement the `Args` trait manually on this\nstruct (or any other type) and it can still be used inside the struct created with the derive\nAPI. The implementation of the `Args` trait will use the builder API to add the arguments to\nthe `Command` instance created behind the scenes for you by the derive API.\n\nNotice how in the previous example we used [`augment_args`][crate::Args::augment_args] on the\nstruct that derived `Parser`, whereas now we implement\n[`augment_args`][crate::Args::augment_args] ourselves, but the derive API calls it\nautomatically since we used the `#[command(flatten)]` attribute.\n\nFor example:\n```rust\nuse clap::error::Error;\nuse clap::{Arg, ArgAction, ArgMatches, Args, Command, FromArgMatches, Parser};\n\n#[derive(Debug)]\nstruct CliArgs {\n    foo: bool,\n    bar: bool,\n    quuz: Option<String>,\n}\n\nimpl FromArgMatches for CliArgs {\n    fn from_arg_matches(matches: &ArgMatches) -> Result<Self, Error> {\n        let mut matches = matches.clone();\n        Self::from_arg_matches_mut(&mut matches)\n    }\n    fn from_arg_matches_mut(matches: &mut ArgMatches) -> Result<Self, Error> {\n        Ok(Self {\n            foo: matches.get_flag(\"foo\"),\n            bar: matches.get_flag(\"bar\"),\n            quuz: matches.remove_one::<String>(\"quuz\"),\n        })\n    }\n    fn update_from_arg_matches(&mut self, matches: &ArgMatches) -> Result<(), Error> {\n        let mut matches = matches.clone();\n        self.update_from_arg_matches_mut(&mut matches)\n    }\n    fn update_from_arg_matches_mut(&mut self, matches: &mut ArgMatches) -> Result<(), Error> {\n        self.foo |= matches.get_flag(\"foo\");\n        self.bar |= matches.get_flag(\"bar\");\n        if let Some(quuz) = matches.remove_one::<String>(\"quuz\") {\n            self.quuz = Some(quuz);\n        }\n        Ok(())\n    }\n}\n\nimpl Args for CliArgs {\n    fn augment_args(cmd: Command) -> Command {\n        cmd.arg(\n            Arg::new(\"foo\")\n                .short('f')\n                .long(\"foo\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"bar\")\n                .short('b')\n                .long(\"bar\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"quuz\")\n                .short('q')\n                .long(\"quuz\")\n                .action(ArgAction::Set),\n        )\n    }\n    fn augment_args_for_update(cmd: Command) -> Command {\n        cmd.arg(\n            Arg::new(\"foo\")\n                .short('f')\n                .long(\"foo\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"bar\")\n                .short('b')\n                .long(\"bar\")\n                .action(ArgAction::SetTrue),\n        )\n        .arg(\n            Arg::new(\"quuz\")\n                .short('q')\n                .long(\"quuz\")\n                .action(ArgAction::Set),\n        )\n    }\n}\n\n#[derive(Parser, Debug)]\nstruct Cli {\n    #[arg(short, long)]\n    top_level: bool,\n    #[command(flatten)]\n    more_args: CliArgs,\n}\n\nfn main() {\n    let args = Cli::parse();\n    println!(\"{args:#?}\");\n}\n```\n\n## Tips\n\n- To get access to a [`Command`][crate::Command] call\n  [`CommandFactory::command`][crate::CommandFactory::command] (implemented when deriving\n  [`Parser`][crate::Parser])\n- Proactively check for bad [`Command`][crate::Command] configurations by calling\n  [`Command::debug_assert`][crate::Command::debug_assert] in a test\n  ([example](../tutorial_derive/05_01_assert.rs))\n- Always remember to [document](#doc-comments) args and commands with `#![deny(missing_docs)]`","links":{"crate::Command::author":"20:478:2997","crate::Command::name":"20:475:917","crate::Arg::long_help":"20:216:3019","crate::Args":"20:64:2659","crate::Command::about":"20:479:2999","crate::Command::long_about":"20:480:3001","crate::ArgGroup":"20:3364:2655","crate::Command::next_display_order":"20:497:3003","crate::Args::augment_args":"20:66:3040","crate::Arg::default_value_os":"20:203:3033","crate::ValueEnum":"20:72:2664","crate::Arg::default_value":"20:202:3027","crate::Arg::env":"20:212:610","crate::Arg::help":"20:215:1621","crate::Arg::long":"20:161:3023","crate::Arg::action":"20:185:2672","crate::Command::allow_external_subcommands":"20:523:3010","crate::Arg::default_values_os":"20:206:3035","crate::builder":"20:112:2645","crate::_derive::_tutorial":"0:21:1713","crate::Arg::value_parser":"20:186:2671","crate::Command::next_help_heading":"20:496:3005","crate::Arg::id":"20:159:3007","crate::value_parser!":"20:1483:2671","crate::builder::PossibleValue::help":"20:870:1621","crate::_features":"0:24:1712","crate::Arg::short":"20:160:3021","crate::builder::PossibleValue":"20:3796:2949","crate::Arg":"20:3326:2654","crate::_cookbook":"0:7:1709","crate::Parser":"20:41:2662","crate::Subcommand":"20:68:2663","crate::Command::debug_assert":"20:425:2603","crate::Command":"20:3650:2652","crate::Arg::required":"20:175:3029","crate::Command::version":"20:485:1567","crate::Arg::global":"20:178:3025","crate::ArgGroup::id":"20:338:3007","crate::builder::PossibleValue::new":"20:869:939","crate::Subcommand::augment_subcommands":"20:69:3045","crate::CommandFactory::command":"20:57:2668","crate::Arg::default_values":"20:204:3031"},"attrs":["#[cfg(feature = \"unstable-doc\")]"],"deprecation":null,"inner":{"module":{"is_crate":false,"items":["0:21:1713","0:22-0:7:1709"],"is_stripped":false}}},"0:25:1713":{"id":"0:25:1713","crate_id":0,"name":"_tutorial","span":{"filename":"src/_tutorial.rs","begin":[10,0],"end":[222,7]},"visibility":"public","docs":"# Documentation: Builder Tutorial\n\n1. [Quick Start](#quick-start)\n2. [Configuring the Parser](#configuring-the-parser)\n3. [Adding Arguments](#adding-arguments)\n    1. [Positionals](#positionals)\n    2. [Options](#options)\n    3. [Flags](#flags)\n    4. [Subcommands](#subcommands)\n    5. [Defaults](#defaults)\n4. Validation\n    1. [Enumerated values](#enumerated-values)\n    2. [Validated values](#validated-values)\n    3. [Argument Relations](#argument-relations)\n    4. [Custom Validation](#custom-validation)\n5. [Testing](#testing)\n\nSee also\n- [FAQ: When should I use the builder vs derive APIs?][crate::_faq#when-should-i-use-the-builder-vs-derive-apis]\n- The [cookbook][crate::_cookbook] for more application-focused examples\n\n## Quick Start\n\nYou can create an application with several arguments using usage strings.\n\n```rust\nuse std::path::PathBuf;\n\nuse clap::{arg, command, value_parser, ArgAction, Command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(arg!([name] \"Optional name to operate on\"))\n        .arg(\n            arg!(\n                -c --config <FILE> \"Sets a custom config file\"\n            )\n            // We don't have syntax yet for optional options, so manually calling `required`\n            .required(false)\n            .value_parser(value_parser!(PathBuf)),\n        )\n        .arg(arg!(\n            -d --debug ... \"Turn debugging information on\"\n        ))\n        .subcommand(\n            Command::new(\"test\")\n                .about(\"does testing things\")\n                .arg(arg!(-l --list \"lists test values\").action(ArgAction::SetTrue)),\n        )\n        .get_matches();\n\n    // You can check the value provided by positional arguments, or option arguments\n    if let Some(name) = matches.get_one::<String>(\"name\") {\n        println!(\"Value for name: {name}\");\n    }\n\n    if let Some(config_path) = matches.get_one::<PathBuf>(\"config\") {\n        println!(\"Value for config: {}\", config_path.display());\n    }\n\n    // You can see how many times a particular flag or argument occurred\n    // Note, only flags can have multiple occurrences\n    match matches\n        .get_one::<u8>(\"debug\")\n        .expect(\"Count's are defaulted\")\n    {\n        0 => println!(\"Debug mode is off\"),\n        1 => println!(\"Debug mode is kind of on\"),\n        2 => println!(\"Debug mode is on\"),\n        _ => println!(\"Don't be crazy\"),\n    }\n\n    // You can check for the existence of subcommands, and if found use their\n    // matches just as you would the top level cmd\n    if let Some(matches) = matches.subcommand_matches(\"test\") {\n        // \"$ myapp test\" was run\n        if matches.get_flag(\"list\") {\n            // \"$ myapp test -l\" was run\n            println!(\"Printing testing lists...\");\n        } else {\n            println!(\"Not printing testing lists...\");\n        }\n    }\n\n    // Continued program logic goes here...\n}\n```\n\n```console\n$ 01_quick --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 01_quick[EXE] [OPTIONS] [name] [COMMAND]\n\nCommands:\n  test  does testing things\n  help  Print this message or the help of the given subcommand(s)\n\nArguments:\n  [name]  Optional name to operate on\n\nOptions:\n  -c, --config <FILE>  Sets a custom config file\n  -d, --debug...       Turn debugging information on\n  -h, --help           Print help\n  -V, --version        Print version\n\n```\n\nBy default, the program does nothing:\n```console\n$ 01_quick\nDebug mode is off\n\n```\n\nBut you can mix and match the various features\n```console\n$ 01_quick -dd test\nDebug mode is on\nNot printing testing lists...\n\n```\n\n## Configuring the Parser\n\nYou use [`Command`][crate::Command] to start building a parser.\n\n```rust\nuse clap::{arg, Command};\n\nfn main() {\n    let matches = Command::new(\"MyApp\")\n        .version(\"1.0\")\n        .author(\"Kevin K. <kbknapp@gmail.com>\")\n        .about(\"Does awesome things\")\n        .arg(arg!(--two <VALUE>).required(true))\n        .arg(arg!(--one <VALUE>).required(true))\n        .get_matches();\n\n    println!(\n        \"two: {:?}\",\n        matches.get_one::<String>(\"two\").expect(\"required\")\n    );\n    println!(\n        \"one: {:?}\",\n        matches.get_one::<String>(\"one\").expect(\"required\")\n    );\n}\n```\n\n```console\n$ 02_apps --help\nDoes awesome things\n\nUsage: 02_apps[EXE] --two <VALUE> --one <VALUE>\n\nOptions:\n      --two <VALUE>  \n      --one <VALUE>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 02_apps --version\nMyApp 1.0\n\n```\n\nYou can use [`command!()`][crate::command!] to fill these fields in from your `Cargo.toml`\nfile.  **This requires the [`cargo` feature flag][crate::_features].**\n\n```rust\nuse clap::{arg, command};\n\nfn main() {\n    // requires `cargo` feature, reading name, version, author, and description from `Cargo.toml`\n    let matches = command!()\n        .arg(arg!(--two <VALUE>).required(true))\n        .arg(arg!(--one <VALUE>).required(true))\n        .get_matches();\n\n    println!(\n        \"two: {:?}\",\n        matches.get_one::<String>(\"two\").expect(\"required\")\n    );\n    println!(\n        \"one: {:?}\",\n        matches.get_one::<String>(\"one\").expect(\"required\")\n    );\n}\n```\n```console\n$ 02_crate --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_crate[EXE] --two <VALUE> --one <VALUE>\n\nOptions:\n      --two <VALUE>  \n      --one <VALUE>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 02_crate --version\nclap [..]\n\n```\n\nYou can use [`Command`][crate::Command] methods to change the application level behavior of\nclap.\n\n```rust\nuse clap::{arg, command, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .next_line_help(true)\n        .arg(arg!(--two <VALUE>).required(true).action(ArgAction::Set))\n        .arg(arg!(--one <VALUE>).required(true).action(ArgAction::Set))\n        .get_matches();\n\n    println!(\n        \"two: {:?}\",\n        matches.get_one::<String>(\"two\").expect(\"required\")\n    );\n    println!(\n        \"one: {:?}\",\n        matches.get_one::<String>(\"one\").expect(\"required\")\n    );\n}\n```\n```console\n$ 02_app_settings --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 02_app_settings[EXE] --two <VALUE> --one <VALUE>\n\nOptions:\n      --two <VALUE>\n          \n      --one <VALUE>\n          \n  -h, --help\n          Print help\n  -V, --version\n          Print version\n\n```\n\n## Adding Arguments\n\n### Positionals\n\nYou can have users specify values by their position on the command-line:\n\n```rust\nuse clap::{command, Arg};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(Arg::new(\"name\"))\n        .get_matches();\n\n    println!(\"name: {:?}\", matches.get_one::<String>(\"name\"));\n}\n```\n```console\n$ 03_03_positional --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional[EXE] [name]\n\nArguments:\n  [name]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional\nname: None\n\n$ 03_03_positional bob\nname: Some(\"bob\")\n\n```\n\nNote that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To\naccept multiple values, use [`Append`][crate::ArgAction::Append]:\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(Arg::new(\"name\").action(ArgAction::Append))\n        .get_matches();\n\n    let args = matches\n        .get_many::<String>(\"name\")\n        .unwrap_or_default()\n        .map(|v| v.as_str())\n        .collect::<Vec<_>>();\n\n    println!(\"names: {:?}\", &args);\n}\n```\n```console\n$ 03_03_positional_mult --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_03_positional_mult[EXE] [name]...\n\nArguments:\n  [name]...  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_03_positional_mult\nnames: []\n\n$ 03_03_positional_mult bob\nnames: [\"bob\"]\n\n$ 03_03_positional_mult bob john\nnames: [\"bob\", \"john\"]\n\n```\n\n### Options\n\nYou can name your arguments with a flag:\n- Order doesn't matter\n- They can be optional\n- Intent is clearer\n\n```rust\nuse clap::{command, Arg};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(Arg::new(\"name\").short('n').long(\"name\"))\n        .get_matches();\n\n    println!(\"name: {:?}\", matches.get_one::<String>(\"name\"));\n}\n```\n```console\n$ 03_02_option --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option[EXE] [OPTIONS]\n\nOptions:\n  -n, --name <name>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option\nname: None\n\n$ 03_02_option --name bob\nname: Some(\"bob\")\n\n$ 03_02_option --name=bob\nname: Some(\"bob\")\n\n$ 03_02_option -n bob\nname: Some(\"bob\")\n\n$ 03_02_option -n=bob\nname: Some(\"bob\")\n\n$ 03_02_option -nbob\nname: Some(\"bob\")\n\n```\n\nNote that the default [`ArgAction`][crate::ArgAction] is [`Set`][crate::ArgAction::Set].  To\naccept multiple occurrences, use [`Append`][crate::ArgAction::Append]:\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            Arg::new(\"name\")\n                .short('n')\n                .long(\"name\")\n                .action(ArgAction::Append),\n        )\n        .get_matches();\n\n    println!(\"name: {:?}\", matches.get_one::<String>(\"name\"));\n}\n```\n```console\n$ 03_02_option_mult --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_02_option_mult[EXE] [OPTIONS]\n\nOptions:\n  -n, --name <name>  \n  -h, --help         Print help\n  -V, --version      Print version\n\n$ 03_02_option_mult\nname: None\n\n$ 03_02_option_mult --name bob\nname: Some(\"bob\")\n\n$ 03_02_option_mult --name=bob\nname: Some(\"bob\")\n\n$ 03_02_option_mult -n bob\nname: Some(\"bob\")\n\n$ 03_02_option_mult -n=bob\nname: Some(\"bob\")\n\n$ 03_02_option_mult -nbob\nname: Some(\"bob\")\n\n```\n\n### Flags\n\nFlags can also be switches that can be on/off:\n\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            Arg::new(\"verbose\")\n                .short('v')\n                .long(\"verbose\")\n                .action(ArgAction::SetTrue),\n        )\n        .get_matches();\n\n    println!(\"verbose: {:?}\", matches.get_flag(\"verbose\"));\n}\n```\n```console\n$ 03_01_flag_bool --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_bool[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose  \n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_01_flag_bool\nverbose: false\n\n$ 03_01_flag_bool --verbose\nverbose: true\n\n$ 03_01_flag_bool --verbose --verbose\n? failed\nerror: the argument '--verbose' cannot be used multiple times\n\nUsage: 03_01_flag_bool[EXE] [OPTIONS]\n\nFor more information, try '--help'.\n\n```\n\nTo accept multiple flags, use [`Count`][crate::ArgAction::Count]:\n\n```rust\nuse clap::{command, Arg, ArgAction};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            Arg::new(\"verbose\")\n                .short('v')\n                .long(\"verbose\")\n                .action(ArgAction::Count),\n        )\n        .get_matches();\n\n    println!(\"verbose: {:?}\", matches.get_count(\"verbose\"));\n}\n```\n```console\n$ 03_01_flag_count --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_01_flag_count[EXE] [OPTIONS]\n\nOptions:\n  -v, --verbose...  \n  -h, --help        Print help\n  -V, --version     Print version\n\n$ 03_01_flag_count\nverbose: 0\n\n$ 03_01_flag_count --verbose\nverbose: 1\n\n$ 03_01_flag_count --verbose --verbose\nverbose: 2\n\n```\n\n### Subcommands\n\nSubcommands are defined as [`Command`][crate::Command]s that get added via\n[`Command::subcommand`][crate::Command::subcommand]. Each instance of a Subcommand can have its\nown version, author(s), Args, and even its own subcommands.\n\n```rust\nuse clap::{arg, command, Command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .propagate_version(true)\n        .subcommand_required(true)\n        .arg_required_else_help(true)\n        .subcommand(\n            Command::new(\"add\")\n                .about(\"Adds files to myapp\")\n                .arg(arg!([NAME])),\n        )\n        .get_matches();\n\n    match matches.subcommand() {\n        Some((\"add\", sub_matches)) => println!(\n            \"'myapp add' was used, name is: {:?}\",\n            sub_matches.get_one::<String>(\"NAME\")\n        ),\n        _ => unreachable!(\"Exhausted list of subcommands and subcommand_required prevents `None`\"),\n    }\n}\n```\n```console\n$ 03_04_subcommands help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands help add\nAdds files to myapp\n\nUsage: 03_04_subcommands[EXE] add [NAME]\n\nArguments:\n  [NAME]  \n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_04_subcommands add bob\n'myapp add' was used, name is: Some(\"bob\")\n\n```\n\nBecause we set [`Command::arg_required_else_help`][crate::Command::arg_required_else_help]:\n```console\n$ 03_04_subcommands\n? failed\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_04_subcommands[EXE] <COMMAND>\n\nCommands:\n  add   Adds files to myapp\n  help  Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n```\n\nBecause we set [`Command::propagate_version`][crate::Command::propagate_version]:\n```console\n$ 03_04_subcommands --version\nclap [..]\n\n$ 03_04_subcommands add --version\nclap-add [..]\n\n```\n\n### Defaults\n\nWe've previously showed that arguments can be [`required`][crate::Arg::required] or optional.\nWhen optional, you work with a `Option` and can `unwrap_or`.  Alternatively, you can set\n[`Arg::default_value`][crate::Arg::default_value].\n\n```rust\nuse clap::{arg, command, value_parser};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!([PORT])\n                .value_parser(value_parser!(u16))\n                .default_value(\"2020\"),\n        )\n        .get_matches();\n\n    println!(\n        \"port: {:?}\",\n        matches\n            .get_one::<u16>(\"PORT\")\n            .expect(\"default ensures there is always a value\")\n    );\n}\n```\n```console\n$ 03_05_default_values --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 03_05_default_values[EXE] [PORT]\n\nArguments:\n  [PORT]  [default: 2020]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 03_05_default_values\nport: 2020\n\n$ 03_05_default_values 22\nport: 22\n\n```\n\n## Validation\n\nBy default, arguments are assumed to be `String`s and only UTF-8 validation is performed.\n\n### Enumerated values\n\nIf you have arguments of specific values you want to test for, you can use the\n[`PossibleValuesParser`][crate::builder::PossibleValuesParser] or [`Arg::value_parser([\"val1\",\n...])`][crate::Arg::value_parser] for short.\n\nThis allows you specify the valid values for that argument. If the user does not use one of\nthose specific values, they will receive a graceful exit with error message informing them\nof the mistake, and what the possible valid values are\n\n```rust\nuse clap::{arg, command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<MODE>)\n                .help(\"What mode to run the program in\")\n                .value_parser([\"fast\", \"slow\"]),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    match matches\n        .get_one::<String>(\"MODE\")\n        .expect(\"'MODE' is required and parsing will fail if its missing\")\n        .as_str()\n    {\n        \"fast\" => {\n            println!(\"Hare\");\n        }\n        \"slow\" => {\n            println!(\"Tortoise\");\n        }\n        _ => unreachable!(),\n    }\n}\n```\n```console\n$ 04_01_possible --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_possible[EXE] <MODE>\n\nArguments:\n  <MODE>  What mode to run the program in [possible values: fast, slow]\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_01_possible fast\nHare\n\n$ 04_01_possible slow\nTortoise\n\n$ 04_01_possible medium\n? failed\nerror: invalid value 'medium' for '<MODE>'\n  [possible values: fast, slow]\n\nFor more information, try '--help'.\n\n```\n\nWhen enabling the [`derive` feature][crate::_features], you can use\n[`ValueEnum`][crate::ValueEnum] to take care of the boiler plate for you, giving the same\nresults.\n\n```rust\nuse clap::{arg, builder::PossibleValue, command, value_parser, ValueEnum};\n\n#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\nenum Mode {\n    Fast,\n    Slow,\n}\n\n// Can also be derived with feature flag `derive`\nimpl ValueEnum for Mode {\n    fn value_variants<'a>() -> &'a [Self] {\n        &[Mode::Fast, Mode::Slow]\n    }\n\n    fn to_possible_value<'a>(&self) -> Option<PossibleValue> {\n        Some(match self {\n            Mode::Fast => PossibleValue::new(\"fast\").help(\"Run swiftly\"),\n            Mode::Slow => PossibleValue::new(\"slow\").help(\"Crawl slowly but steadily\"),\n        })\n    }\n}\n\nimpl std::fmt::Display for Mode {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        self.to_possible_value()\n            .expect(\"no values are skipped\")\n            .get_name()\n            .fmt(f)\n    }\n}\n\nimpl std::str::FromStr for Mode {\n    type Err = String;\n\n    fn from_str(s: &str) -> Result<Self, Self::Err> {\n        for variant in Self::value_variants() {\n            if variant.to_possible_value().unwrap().matches(s, false) {\n                return Ok(*variant);\n            }\n        }\n        Err(format!(\"invalid variant: {s}\"))\n    }\n}\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<MODE>)\n                .help(\"What mode to run the program in\")\n                .value_parser(value_parser!(Mode)),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    match matches\n        .get_one::<Mode>(\"MODE\")\n        .expect(\"'MODE' is required and parsing will fail if its missing\")\n    {\n        Mode::Fast => {\n            println!(\"Hare\");\n        }\n        Mode::Slow => {\n            println!(\"Tortoise\");\n        }\n    }\n}\n```\n```console\n$ 04_01_enum --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum[EXE] <MODE>\n\nArguments:\n  <MODE>\n          What mode to run the program in\n\n          Possible values:\n          - fast: Run swiftly\n          - slow: Crawl slowly but steadily\n\nOptions:\n  -h, --help\n          Print help (see a summary with '-h')\n\n  -V, --version\n          Print version\n\n$ 04_01_enum -h\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_01_enum[EXE] <MODE>\n\nArguments:\n  <MODE>  What mode to run the program in [possible values: fast, slow]\n\nOptions:\n  -h, --help     Print help (see more with '--help')\n  -V, --version  Print version\n\n$ 04_01_enum fast\nHare\n\n$ 04_01_enum slow\nTortoise\n\n$ 04_01_enum medium\n? failed\nerror: invalid value 'medium' for '<MODE>'\n  [possible values: fast, slow]\n\nFor more information, try '--help'.\n\n```\n\n### Validated values\n\nMore generally, you can validate and parse into any data type.\n\n```rust\nuse clap::{arg, command, value_parser};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<PORT>)\n                .help(\"Network port to use\")\n                .value_parser(value_parser!(u16).range(1..)),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    let port: u16 = *matches\n        .get_one::<u16>(\"PORT\")\n        .expect(\"'PORT' is required and parsing will fail if its missing\");\n    println!(\"PORT = {port}\");\n}\n```\n```console\n$ 04_02_parse --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_parse[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_parse 22\nPORT = 22\n\n$ 04_02_parse foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': invalid digit found in string\n\nFor more information, try '--help'.\n\n$ 04_02_parse_derive 0\n? failed\nerror: invalid value '0' for '<PORT>': 0 is not in 1..=65535\n\nFor more information, try '--help'.\n\n```\n\nA custom parser can be used to improve the error messages or provide additional validation:\n\n```rust\nuse std::ops::RangeInclusive;\n\nuse clap::{arg, command};\n\nfn main() {\n    let matches = command!() // requires `cargo` feature\n        .arg(\n            arg!(<PORT>)\n                .help(\"Network port to use\")\n                .value_parser(port_in_range),\n        )\n        .get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    let port: u16 = *matches\n        .get_one::<u16>(\"PORT\")\n        .expect(\"'PORT' is required and parsing will fail if its missing\");\n    println!(\"PORT = {port}\");\n}\n\nconst PORT_RANGE: RangeInclusive<usize> = 1..=65535;\n\nfn port_in_range(s: &str) -> Result<u16, String> {\n    let port: usize = s\n        .parse()\n        .map_err(|_| format!(\"`{s}` isn't a port number\"))?;\n    if PORT_RANGE.contains(&port) {\n        Ok(port as u16)\n    } else {\n        Err(format!(\n            \"port not in range {}-{}\",\n            PORT_RANGE.start(),\n            PORT_RANGE.end()\n        ))\n    }\n}\n```\n```console\n$ 04_02_validate --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_02_validate[EXE] <PORT>\n\nArguments:\n  <PORT>  Network port to use\n\nOptions:\n  -h, --help     Print help\n  -V, --version  Print version\n\n$ 04_02_validate 22\nPORT = 22\n\n$ 04_02_validate foobar\n? failed\nerror: invalid value 'foobar' for '<PORT>': `foobar` isn't a port number\n\nFor more information, try '--help'.\n\n$ 04_02_validate 0\n? failed\nerror: invalid value '0' for '<PORT>': port not in range 1-65535\n\nFor more information, try '--help'.\n\n```\n\nSee [`Arg::value_parser`][crate::Arg::value_parser] for more details.\n\n### Argument Relations\n\nYou can declare dependencies or conflicts between [`Arg`][crate::Arg]s or even\n[`ArgGroup`][crate::ArgGroup]s.\n\n[`ArgGroup`][crate::ArgGroup]s  make it easier to declare relations instead of having to list\neach individually, or when you want a rule to apply \"any but not all\" arguments.\n\nPerhaps the most common use of [`ArgGroup`][crate::ArgGroup]s is to require one and *only* one\nargument to be present out of a given set. Imagine that you had multiple arguments, and you\nwant one of them to be required, but making all of them required isn't feasible because perhaps\nthey conflict with each other.\n\n```rust\nuse std::path::PathBuf;\n\nuse clap::{arg, command, value_parser, ArgAction, ArgGroup};\n\nfn main() {\n    // Create application like normal\n    let matches = command!() // requires `cargo` feature\n        // Add the version arguments\n        .arg(arg!(--\"set-ver\" <VER> \"set version manually\"))\n        .arg(arg!(--major         \"auto inc major\").action(ArgAction::SetTrue))\n        .arg(arg!(--minor         \"auto inc minor\").action(ArgAction::SetTrue))\n        .arg(arg!(--patch         \"auto inc patch\").action(ArgAction::SetTrue))\n        // Create a group, make it required, and add the above arguments\n        .group(\n            ArgGroup::new(\"vers\")\n                .required(true)\n                .args([\"set-ver\", \"major\", \"minor\", \"patch\"]),\n        )\n        // Arguments can also be added to a group individually, these two arguments\n        // are part of the \"input\" group which is not required\n        .arg(\n            arg!([INPUT_FILE] \"some regular input\")\n                .value_parser(value_parser!(PathBuf))\n                .group(\"input\"),\n        )\n        .arg(\n            arg!(--\"spec-in\" <SPEC_IN> \"some special input argument\")\n                .value_parser(value_parser!(PathBuf))\n                .group(\"input\"),\n        )\n        // Now let's assume we have a -c [config] argument which requires one of\n        // (but **not** both) the \"input\" arguments\n        .arg(\n            arg!(config: -c <CONFIG>)\n                .value_parser(value_parser!(PathBuf))\n                .requires(\"input\"),\n        )\n        .get_matches();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set-ver was used to set the version manually\n    let version = if let Some(ver) = matches.get_one::<String>(\"set-ver\") {\n        ver.to_owned()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (\n            matches.get_flag(\"major\"),\n            matches.get_flag(\"minor\"),\n            matches.get_flag(\"patch\"),\n        );\n        match (maj, min, pat) {\n            (true, _, _) => major += 1,\n            (_, true, _) => minor += 1,\n            (_, _, true) => patch += 1,\n            _ => unreachable!(),\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if matches.contains_id(\"config\") {\n        let input = matches\n            .get_one::<PathBuf>(\"INPUT_FILE\")\n            .unwrap_or_else(|| matches.get_one::<PathBuf>(\"spec-in\").unwrap())\n            .display();\n        println!(\n            \"Doing work using input {} and config {}\",\n            input,\n            matches.get_one::<PathBuf>(\"config\").unwrap().display()\n        );\n    }\n}\n```\n```console\n$ 04_03_relations --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_03_relations[EXE] [OPTIONS] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_03_relations\n? failed\nerror: the following required arguments were not provided:\n  <--set-ver <VER>|--major|--minor|--patch>\n\nUsage: 04_03_relations[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations --major\nVersion: 2.2.3\n\n$ 04_03_relations --major --minor\n? failed\nerror: the argument '--major' cannot be used with '--minor'\n\nUsage: 04_03_relations[EXE] <--set-ver <VER>|--major|--minor|--patch> [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_03_relations --major -c config.toml\n? failed\nerror: the following required arguments were not provided:\n  <INPUT_FILE|--spec-in <SPEC_IN>>\n\nUsage: 04_03_relations[EXE] -c <CONFIG> <--set-ver <VER>|--major|--minor|--patch> <INPUT_FILE|--spec-in <SPEC_IN>>\n\nFor more information, try '--help'.\n\n$ 04_03_relations --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n### Custom Validation\n\nAs a last resort, you can create custom errors with the basics of clap's formatting.\n\n```rust\nuse std::path::PathBuf;\n\nuse clap::error::ErrorKind;\nuse clap::{arg, command, value_parser, ArgAction};\n\nfn main() {\n    // Create application like normal\n    let mut cmd = command!() // requires `cargo` feature\n        // Add the version arguments\n        .arg(arg!(--\"set-ver\" <VER> \"set version manually\"))\n        .arg(arg!(--major         \"auto inc major\").action(ArgAction::SetTrue))\n        .arg(arg!(--minor         \"auto inc minor\").action(ArgAction::SetTrue))\n        .arg(arg!(--patch         \"auto inc patch\").action(ArgAction::SetTrue))\n        // Arguments can also be added to a group individually, these two arguments\n        // are part of the \"input\" group which is not required\n        .arg(arg!([INPUT_FILE] \"some regular input\").value_parser(value_parser!(PathBuf)))\n        .arg(\n            arg!(--\"spec-in\" <SPEC_IN> \"some special input argument\")\n                .value_parser(value_parser!(PathBuf)),\n        )\n        // Now let's assume we have a -c [config] argument which requires one of\n        // (but **not** both) the \"input\" arguments\n        .arg(arg!(config: -c <CONFIG>).value_parser(value_parser!(PathBuf)));\n    let matches = cmd.get_matches_mut();\n\n    // Let's assume the old version 1.2.3\n    let mut major = 1;\n    let mut minor = 2;\n    let mut patch = 3;\n\n    // See if --set-ver was used to set the version manually\n    let version = if let Some(ver) = matches.get_one::<String>(\"set-ver\") {\n        if matches.get_flag(\"major\") || matches.get_flag(\"minor\") || matches.get_flag(\"patch\") {\n            cmd.error(\n                ErrorKind::ArgumentConflict,\n                \"Can't do relative and absolute version change\",\n            )\n            .exit();\n        }\n        ver.to_string()\n    } else {\n        // Increment the one requested (in a real program, we'd reset the lower numbers)\n        let (maj, min, pat) = (\n            matches.get_flag(\"major\"),\n            matches.get_flag(\"minor\"),\n            matches.get_flag(\"patch\"),\n        );\n        match (maj, min, pat) {\n            (true, false, false) => major += 1,\n            (false, true, false) => minor += 1,\n            (false, false, true) => patch += 1,\n            _ => {\n                cmd.error(\n                    ErrorKind::ArgumentConflict,\n                    \"Can only modify one version field\",\n                )\n                .exit();\n            }\n        };\n        format!(\"{major}.{minor}.{patch}\")\n    };\n\n    println!(\"Version: {version}\");\n\n    // Check for usage of -c\n    if matches.contains_id(\"config\") {\n        let input = matches\n            .get_one::<PathBuf>(\"INPUT_FILE\")\n            .or_else(|| matches.get_one::<PathBuf>(\"spec-in\"))\n            .unwrap_or_else(|| {\n                cmd.error(\n                    ErrorKind::MissingRequiredArgument,\n                    \"INPUT_FILE or --spec-in is required when using --config\",\n                )\n                .exit()\n            })\n            .display();\n        println!(\n            \"Doing work using input {} and config {}\",\n            input,\n            matches.get_one::<PathBuf>(\"config\").unwrap().display()\n        );\n    }\n}\n```\n```console\n$ 04_04_custom --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nArguments:\n  [INPUT_FILE]  some regular input\n\nOptions:\n      --set-ver <VER>      set version manually\n      --major              auto inc major\n      --minor              auto inc minor\n      --patch              auto inc patch\n      --spec-in <SPEC_IN>  some special input argument\n  -c <CONFIG>              \n  -h, --help               Print help\n  -V, --version            Print version\n\n$ 04_04_custom\n? failed\nerror: Can only modify one version field\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom --major\nVersion: 2.2.3\n\n$ 04_04_custom --major --minor\n? failed\nerror: Can only modify one version field\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom --major -c config.toml\n? failed\nVersion: 2.2.3\nerror: INPUT_FILE or --spec-in is required when using --config\n\nUsage: 04_04_custom[EXE] [OPTIONS] [INPUT_FILE]\n\nFor more information, try '--help'.\n\n$ 04_04_custom --major -c config.toml --spec-in input.txt\nVersion: 2.2.3\nDoing work using input input.txt and config config.toml\n\n```\n\n## Testing\n\nclap reports most development errors as `debug_assert!`s.  Rather than checking every\nsubcommand, you should have a test that calls\n[`Command::debug_assert`][crate::Command::debug_assert]:\n```rust,no_run\nuse clap::{arg, command, value_parser};\n\nfn main() {\n    let matches = cmd().get_matches();\n\n    // Note, it's safe to call unwrap() because the arg is required\n    let port: usize = *matches\n        .get_one::<usize>(\"PORT\")\n        .expect(\"'PORT' is required and parsing will fail if its missing\");\n    println!(\"PORT = {port}\");\n}\n\nfn cmd() -> clap::Command {\n    command!() // requires `cargo` feature\n        .arg(\n            arg!(<PORT>)\n                .help(\"Network port to use\")\n                .value_parser(value_parser!(usize)),\n        )\n}\n\n#[test]\nfn verify_cmd() {\n    cmd().debug_assert();\n}\n```","links":{"crate::ArgAction::Count":"20:2936:110","crate::builder::PossibleValuesParser":"20:4003:2978","crate::_features":"0:24:1712","crate::ArgGroup":"20:3364:2655","crate::ValueEnum":"20:72:2664","crate::_cookbook":"0:7:1709","crate::_faq#when-should-i-use-the-builder-vs-derive-apis":"0:23:1711","crate::ArgAction::Set":"20:2928:3056","crate::ArgAction":"20:2927:2651","crate::command!":"20:27:2668","crate::ArgAction::Append":"20:2930:3057","crate::Command":"20:3650:2652","crate::Command::subcommand":"20:422:3088","crate::Command::arg_required_else_help":"20:498:3090","crate::Command::propagate_version":"20:464:3092","crate::Arg::required":"20:175:3029","crate::Arg::default_value":"20:202:3027","crate::Arg":"20:3326:2654","crate::Command::debug_assert":"20:425:2603","crate::Arg::value_parser":"20:186:2671"},"attrs":["#[cfg(feature = \"unstable-doc\")]"],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12116:28463":{"id":"2:12116:28463","crate_id":2,"name":"strip_suffix","span":null,"visibility":"public","docs":"Returns a string slice with the suffix removed.\n\nIf the string ends with the pattern `suffix`, returns the substring before the suffix,\nwrapped in `Some`.  Unlike `trim_end_matches`, this method removes the suffix exactly once.\n\nIf the string does not end with `suffix`, returns `None`.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Examples\n\n```\nassert_eq!(\"bar:foo\".strip_suffix(\":foo\"), Some(\"bar\"));\nassert_eq!(\"bar:foo\".strip_suffix(\"bar\"), None);\nassert_eq!(\"foofoo\".strip_suffix(\"foo\"), Some(\"foo\"));\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":["#[must_use =\n\"this returns the remaining substring as a new slice, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["suffix",{"generic":"P"}]],"output":{"resolved_path":{"name":"Option","id":"2:41394:181","args":{"angle_bracketed":{"args":[{"type":{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}},{"bound_predicate":{"type":{"qualified_path":{"name":"Searcher","args":{"angle_bracketed":{"args":[],"bindings":[]}},"self_type":{"generic":"P"},"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}}}},"bounds":[{"trait_bound":{"trait":{"name":"ReverseSearcher","id":"2:11732:8904","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:24:1712":{"id":"0:24:1712","crate_id":0,"name":"_features","span":{"filename":"src/_features.rs","begin":[1,0],"end":[29,58]},"visibility":"public","docs":"## Documentation: Feature Flags\n\nAvailable [compile-time feature flags](https://doc.rust-lang.org/cargo/reference/features.html#dependency-features)\n\n#### Default Features\n\n* **std**: _Not Currently Used._ Placeholder for supporting `no_std` environments in a backwards compatible manner.\n* **color**: Turns on colored error messages.\n* **help**: Auto-generate help output\n* **usage**: Auto-generate usage\n* **error-context**: Include contextual information for errors (which arg failed, etc)\n* **suggestions**: Turns on the `Did you mean '--myoption'?` feature for when users make typos.\n\n#### Optional features\n\n* **deprecated**: Guided experience to prepare for next breaking release (at different stages of development, this may become default)\n* **derive**: Enables the custom derive (i.e. `#[derive(Parser)]`). Without this you must use one of the other methods of creating a `clap` CLI listed above.\n* **cargo**: Turns on macros that read values from [`CARGO_*` environment variables](https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates).\n* **env**: Turns on the usage of environment variables during parsing.\n* **unicode**: Turns on support for unicode characters (including emoji) in arguments and help messages.\n* **wrap_help**: Turns on the help text wrapping feature, based on the terminal size.\n* **string**: Allow runtime generated strings (e.g. with [`Str`][crate::builder::Str]).\n\n#### Experimental features\n\n**Warning:** These may contain breaking changes between minor releases.\n\n* **unstable-v5**: Preview features which will be stable on the v5.0 release\n* **unstable-styles**: Custom theming support for clap","links":{"crate::builder::Str":"20:3863:2961"},"attrs":["#[cfg(feature = \"unstable-doc\")]"],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"0:8:1844":{"id":"0:8:1844","crate_id":0,"name":"cargo_example","span":{"filename":"src/_cookbook/cargo_example.rs","begin":[1,0],"end":[7,57]},"visibility":"public","docs":"# Example: cargo subcommand (Builder API)\n\n```rust\nfn main() {\n    let cmd = clap::Command::new(\"cargo\")\n        .bin_name(\"cargo\")\n        .subcommand_required(true)\n        .subcommand(\n            clap::command!(\"example\").arg(\n                clap::arg!(--\"manifest-path\" <PATH>)\n                    .value_parser(clap::value_parser!(std::path::PathBuf)),\n            ),\n        );\n    let matches = cmd.get_matches();\n    let matches = match matches.subcommand() {\n        Some((\"example\", matches)) => matches,\n        _ => unreachable!(\"clap should ensure we don't get here\"),\n    };\n    let manifest_path = matches.get_one::<std::path::PathBuf>(\"manifest-path\");\n    println!(\"{manifest_path:?}\");\n}\n```\n\nFor more on creating a custom subcommand, see [the cargo\nbook](https://doc.rust-lang.org/cargo/reference/external-tools.html#custom-subcommands).\nThe crate [`clap-cargo`](https://github.com/crate-ci/clap-cargo) can help in\nmimicking cargo's interface.\n\nThe help looks like:\n```console\n$ cargo-example --help\nUsage: cargo <COMMAND>\n\nCommands:\n  example  A simple to use, efficient, and full-featured Command Line Argument Parser\n  help     Print this message or the help of the given subcommand(s)\n\nOptions:\n  -h, --help  Print help\n\n$ cargo-example example --help\nA simple to use, efficient, and full-featured Command Line Argument Parser\n\nUsage: cargo example [OPTIONS]\n\nOptions:\n      --manifest-path <PATH>  \n  -h, --help                  Print help\n  -V, --version               Print version\n\n```\n\nThen to directly invoke the command, run:\n```console\n$ cargo-example example\nNone\n\n$ cargo-example example --manifest-path Cargo.toml\nSome(\"Cargo.toml\")\n\n```","links":{},"attrs":[],"deprecation":null,"inner":{"module":{"is_crate":false,"items":[],"is_stripped":false}}},"2:12012:25960":{"id":"2:12012:25960","crate_id":2,"name":"is_empty","span":null,"visibility":"public","docs":"Returns `true` if `self` has a length of zero bytes.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"\";\nassert!(s.is_empty());\n\nlet s = \"not empty\";\nassert!(!s.is_empty());\n```","links":{},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"primitive":"bool"},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":true,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12122:35649":{"id":"2:12122:35649","crate_id":2,"name":"trim_left_matches","span":null,"visibility":"public","docs":"Returns a string slice with all prefixes that match a pattern\nrepeatedly removed.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Text directionality\n\nA string is a sequence of bytes. 'Left' in this context means the first\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _right_ side, not the left.\n\n# Examples\n\nBasic usage:\n\n```\nassert_eq!(\"11foo1bar11\".trim_left_matches('1'), \"foo1bar11\");\nassert_eq!(\"123foo1bar123\".trim_left_matches(char::is_numeric), \"foo1bar123\");\n\nlet x: &[_] = &['1', '2'];\nassert_eq!(\"12foo1bar12\".trim_left_matches(x), \"foo1bar12\");\n```","links":{"prim@char":"1:11888:419","self::pattern":"2:11712:8907"},"attrs":["#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_start_matches`\",\nsuggestion = \"trim_start_matches\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_start_matches`"},"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12060:26737":{"id":"2:12060:26737","crate_id":2,"name":"split","span":null,"visibility":"public","docs":"An iterator over substrings of this string slice, separated by\ncharacters matched by a pattern.\n\nThe [pattern] can be a `&str`, [`char`], a slice of [`char`]s, or a\nfunction or closure that determines if a character matches.\n\n[`char`]: prim@char\n[pattern]: self::pattern\n\n# Iterator behavior\n\nThe returned iterator will be a [`DoubleEndedIterator`] if the pattern\nallows a reverse search and forward/reverse search yields the same\nelements. This is true for, e.g., [`char`], but not for `&str`.\n\nIf the pattern allows a reverse search but its results might differ\nfrom a forward search, the [`rsplit`] method can be used.\n\n[`rsplit`]: str::rsplit\n\n# Examples\n\nSimple patterns:\n\n```\nlet v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\nassert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n\nlet v: Vec<&str> = \"\".split('X').collect();\nassert_eq!(v, [\"\"]);\n\nlet v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\nassert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"lion::tiger::leopard\".split(\"::\").collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n\nlet v: Vec<&str> = \"abc1def2ghi\".split(char::is_numeric).collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n\nlet v: Vec<&str> = \"lionXtigerXleopard\".split(char::is_uppercase).collect();\nassert_eq!(v, [\"lion\", \"tiger\", \"leopard\"]);\n```\n\nIf the pattern is a slice of chars, split on each occurrence of any of the characters:\n\n```\nlet v: Vec<&str> = \"2020-11-03 23:59\".split(&['-', ' ', ':', '@'][..]).collect();\nassert_eq!(v, [\"2020\", \"11\", \"03\", \"23\", \"59\"]);\n```\n\nA more complex pattern, using a closure:\n\n```\nlet v: Vec<&str> = \"abc1defXghi\".split(|c| c == '1' || c == 'X').collect();\nassert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n```\n\nIf a string contains multiple contiguous separators, you will end up\nwith empty strings in the output:\n\n```\nlet x = \"||||a||b|c\".to_string();\nlet d: Vec<_> = x.split('|').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\nContiguous separators are separated by the empty string.\n\n```\nlet x = \"(///)\".to_string();\nlet d: Vec<_> = x.split('/').collect();\n\nassert_eq!(d, &[\"(\", \"\", \"\", \")\"]);\n```\n\nSeparators at the start or end of a string are neighbored\nby empty strings.\n\n```\nlet d: Vec<_> = \"010\".split(\"0\").collect();\nassert_eq!(d, &[\"\", \"1\", \"\"]);\n```\n\nWhen the empty string is used as a separator, it separates\nevery character in the string, along with the beginning\nand end of the string.\n\n```\nlet f: Vec<_> = \"rust\".split(\"\").collect();\nassert_eq!(f, &[\"\", \"r\", \"u\", \"s\", \"t\", \"\"]);\n```\n\nContiguous separators can lead to possibly surprising behavior\nwhen whitespace is used as the separator. This code is correct:\n\n```\nlet x = \"    a  b c\".to_string();\nlet d: Vec<_> = x.split(' ').collect();\n\nassert_eq!(d, &[\"\", \"\", \"\", \"\", \"a\", \"\", \"b\", \"c\"]);\n```\n\nIt does _not_ give you:\n\n```,ignore\nassert_eq!(d, &[\"a\", \"b\", \"c\"]);\n```\n\nUse [`split_whitespace`] for this behavior.\n\n[`split_whitespace`]: str::split_whitespace","links":{"self::pattern":"2:11712:8907","`DoubleEndedIterator`":"2:7240:121","prim@char":"1:11888:419","str::split_whitespace":"2:12038:33048","str::rsplit":"2:12066:28456"},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":"'a","mutable":false,"type":{"generic":"Self"}}}],["pat",{"generic":"P"}]],"output":{"resolved_path":{"name":"Split","id":"2:43357:3362","args":{"angle_bracketed":{"args":[{"lifetime":"'a"},{"type":{"generic":"P"}}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[{"name":"'a","kind":{"lifetime":{"outlives":[]}}},{"name":"P","kind":{"type":{"bounds":[],"default":null,"synthetic":false}}}],"where_predicates":[{"bound_predicate":{"type":{"generic":"P"},"bounds":[{"trait_bound":{"trait":{"name":"Pattern","id":"2:11717:8903","args":{"angle_bracketed":{"args":[{"lifetime":"'a"}],"bindings":[]}}},"generic_params":[],"modifier":"none"}}],"generic_params":[]}}]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12042:33054":{"id":"2:12042:33054","crate_id":2,"name":"encode_utf16","span":null,"visibility":"public","docs":"Returns an iterator of `u16` over the string encoded as UTF-16.\n\n# Examples\n\nBasic usage:\n\n```\nlet text = \"Za≈º√≥≈Çƒá gƒô≈õlƒÖ ja≈∫≈Ñ\";\n\nlet utf8_len = text.len();\nlet utf16_len = text.encode_utf16().count();\n\nassert!(utf16_len <= utf8_len);\n```","links":{},"attrs":["#[must_use =\n\"this returns the encoded string as an iterator, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"EncodeUtf16","id":"2:43649:8908","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12039:33037":{"id":"2:12039:33037","crate_id":2,"name":"split_ascii_whitespace","span":null,"visibility":"public","docs":"Splits a string slice by ASCII whitespace.\n\nThe iterator returned will return string slices that are sub-slices of\nthe original string slice, separated by any amount of ASCII whitespace.\n\nTo split by Unicode `Whitespace` instead, use [`split_whitespace`].\n\n[`split_whitespace`]: str::split_whitespace\n\n# Examples\n\nBasic usage:\n\n```\nlet mut iter = \"A few words\".split_ascii_whitespace();\n\nassert_eq!(Some(\"A\"), iter.next());\nassert_eq!(Some(\"few\"), iter.next());\nassert_eq!(Some(\"words\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nAll kinds of ASCII whitespace are considered:\n\n```\nlet mut iter = \" Mary   had\\ta little  \\n\\t lamb\".split_ascii_whitespace();\nassert_eq!(Some(\"Mary\"), iter.next());\nassert_eq!(Some(\"had\"), iter.next());\nassert_eq!(Some(\"a\"), iter.next());\nassert_eq!(Some(\"little\"), iter.next());\nassert_eq!(Some(\"lamb\"), iter.next());\n\nassert_eq!(None, iter.next());\n```\n\nIf the string is empty or all ASCII whitespace, the iterator yields no string slices:\n```\nassert_eq!(\"\".split_ascii_whitespace().next(), None);\nassert_eq!(\"   \".split_ascii_whitespace().next(), None);\n```","links":{"str::split_whitespace":"2:12038:33048"},"attrs":["#[must_use =\n\"this returns the split string as an iterator, \\\n                  without modifying the original\"]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"SplitAsciiWhitespace","id":"2:43640:8909","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"0:22-0:7:1709":{"id":"0:22-0:7:1709","crate_id":0,"name":null,"span":{"filename":"src/_derive/mod.rs","begin":[490,0],"end":[490,25]},"visibility":"public","docs":null,"links":{},"attrs":["#[doc(inline)]"],"deprecation":null,"inner":{"import":{"source":"crate::_cookbook","name":"_cookbook","id":"0:7:1709","glob":false}}},"2:12033:28445":{"id":"2:12033:28445","crate_id":2,"name":"split_at","span":null,"visibility":"public","docs":"Divide one string slice into two at an index.\n\nThe argument, `mid`, should be a byte offset from the start of the\nstring. It must also be on the boundary of a UTF-8 code point.\n\nThe two slices returned go from the start of the string slice to `mid`,\nand from `mid` to the end of the string slice.\n\nTo get mutable string slices instead, see the [`split_at_mut`]\nmethod.\n\n[`split_at_mut`]: str::split_at_mut\n\n# Panics\n\nPanics if `mid` is not on a UTF-8 code point boundary, or if it is\npast the end of the last code point of the string slice.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"Per Martin-L√∂f\";\n\nlet (first, last) = s.split_at(3);\n\nassert_eq!(\"Per\", first);\nassert_eq!(\" Martin-L√∂f\", last);\n```","links":{"str::split_at_mut":"2:12034:28446"},"attrs":["#[must_use]"],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["mid",{"primitive":"usize"}]],"output":{"tuple":[{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}},{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}}]},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12031:35631":{"id":"2:12031:35631","crate_id":2,"name":"slice_unchecked","span":null,"visibility":"public","docs":"Creates a string slice from another string slice, bypassing safety\nchecks.\n\nThis is generally not recommended, use with caution! For a safe\nalternative see [`str`] and [`Index`].\n\n[`Index`]: crate::ops::Index\n\nThis new slice goes from `begin` to `end`, including `begin` but\nexcluding `end`.\n\nTo get a mutable string slice instead, see the\n[`slice_mut_unchecked`] method.\n\n[`slice_mut_unchecked`]: str::slice_mut_unchecked\n\n# Safety\n\nCallers of this function are responsible that three preconditions are\nsatisfied:\n\n* `begin` must not exceed `end`.\n* `begin` and `end` must be byte positions within the string slice.\n* `begin` and `end` must lie on UTF-8 sequence boundaries.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \"L√∂we ËÄÅËôé L√©opard\";\n\nunsafe {\n    assert_eq!(\"L√∂we ËÄÅËôé L√©opard\", s.slice_unchecked(0, 21));\n}\n\nlet s = \"Hello, world!\";\n\nunsafe {\n    assert_eq!(\"world\", s.slice_unchecked(7, 12));\n}\n```","links":{"`str`":"1:11894:1397","str::slice_mut_unchecked":"2:12032:35632","crate::ops::Index":"2:2981:3246"},"attrs":["#[deprecated(since = \"1.29.0\", note =\n\"use `get_unchecked(begin..end)` instead\")]","#[must_use]"],"deprecation":{"since":"1.29.0","note":"use `get_unchecked(begin..end)` instead"},"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}],["begin",{"primitive":"usize"}],["end",{"primitive":"usize"}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":true,"async":false,"abi":"Rust"},"has_body":true}}},"2:12134:27693":{"id":"2:12134:27693","crate_id":2,"name":"make_ascii_lowercase","span":null,"visibility":"public","docs":"Converts this string to its ASCII lower case equivalent in-place.\n\nASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\nbut non-ASCII letters are unchanged.\n\nTo return a new lowercased value without modifying the existing one, use\n[`to_ascii_lowercase()`].\n\n[`to_ascii_lowercase()`]: #method.to_ascii_lowercase\n\n# Examples\n\n```\nlet mut s = String::from(\"GR√ú√üE, J√úRGEN ‚ù§\");\n\ns.make_ascii_lowercase();\n\nassert_eq!(\"gr√ú√üe, j√úrgen ‚ù§\", s);\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":true,"type":{"generic":"Self"}}}]],"output":null,"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12040:26738":{"id":"2:12040:26738","crate_id":2,"name":"lines","span":null,"visibility":"public","docs":"An iterator over the lines of a string, as string slices.\n\nLines are split at line endings that are either newlines (`\\n`) or\nsequences of a carriage return followed by a line feed (`\\r\\n`).\n\nLine terminators are not included in the lines returned by the iterator.\n\nThe final line ending is optional. A string that ends with a final line\nending will return the same lines as an otherwise identical string\nwithout a final line ending.\n\n# Examples\n\nBasic usage:\n\n```\nlet text = \"foo\\r\\nbar\\n\\nbaz\\n\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());\n```\n\nThe final line ending isn't required:\n\n```\nlet text = \"foo\\nbar\\n\\r\\nbaz\";\nlet mut lines = text.lines();\n\nassert_eq!(Some(\"foo\"), lines.next());\nassert_eq!(Some(\"bar\"), lines.next());\nassert_eq!(Some(\"\"), lines.next());\nassert_eq!(Some(\"baz\"), lines.next());\n\nassert_eq!(None, lines.next());\n```","links":{},"attrs":[],"deprecation":null,"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"resolved_path":{"name":"Lines","id":"2:43611:3358","args":{"angle_bracketed":{"args":[{"lifetime":"'_"}],"bindings":[]}}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}},"2:12106:35645":{"id":"2:12106:35645","crate_id":2,"name":"trim_right","span":null,"visibility":"public","docs":"Returns a string slice with trailing whitespace removed.\n\n'Whitespace' is defined according to the terms of the Unicode Derived\nCore Property `White_Space`.\n\n# Text directionality\n\nA string is a sequence of bytes. 'Right' in this context means the last\nposition of that byte string; for a language like Arabic or Hebrew\nwhich are 'right to left' rather than 'left to right', this will be\nthe _left_ side, not the right.\n\n# Examples\n\nBasic usage:\n\n```\nlet s = \" Hello\\tworld\\t\";\n\nassert_eq!(\" Hello\\tworld\", s.trim_right());\n```\n\nDirectionality:\n\n```\nlet s = \"English  \";\nassert!(Some('h') == s.trim_right().chars().rev().next());\n\nlet s = \"◊¢◊ë◊®◊ô◊™  \";\nassert!(Some('◊™') == s.trim_right().chars().rev().next());\n```","links":{},"attrs":["#[must_use =\n\"this returns the trimmed string as a new slice, \\\n                  without modifying the original\"]","#[deprecated(since = \"1.33.0\", note = \"superseded by `trim_end`\", suggestion =\n\"trim_end\")]"],"deprecation":{"since":"1.33.0","note":"superseded by `trim_end`"},"inner":{"function":{"decl":{"inputs":[["self",{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"generic":"Self"}}}]],"output":{"borrowed_ref":{"lifetime":null,"mutable":false,"type":{"primitive":"str"}}},"c_variadic":false},"generics":{"params":[],"where_predicates":[]},"header":{"const":false,"unsafe":false,"async":false,"abi":"Rust"},"has_body":true}}}},"paths":{"47:4868:39549":{"crate_id":47,"path":["rustix","process","prctl","SpeculationFeatureControl"],"kind":"struct"},"16:5367:15395":{"crate_id":16,"path":["gimli","endianity","RunTimeEndian"],"kind":"enum"},"40:479:15407":{"crate_id":40,"path":["gimli","read","cfi","UnwindContextStorage"],"kind":"trait"},"6:4492:13494":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_ramp_effect"],"kind":"struct"},"32:5374:13502":{"crate_id":32,"path":["libc","unix","linux_like","linux","dl_phdr_info"],"kind":"struct"},"2:43935:8945":{"crate_id":2,"path":["core","str","pattern","StrSearcherImpl"],"kind":"enum"},"17:10545:16549":{"crate_id":17,"path":["object","read","pe","export","Export"],"kind":"struct"},"5:6248:3194":{"crate_id":5,"path":["alloc","vec","drain","Drain"],"kind":"struct"},"2:47686:8800":{"crate_id":2,"path":["core","core_arch","x86","__m128d"],"kind":"struct"},"17:12902:20563":{"crate_id":17,"path":["object","pe","ImageFileHeader"],"kind":"struct"},"2:44364:8822":{"crate_id":2,"path":["core","alloc","layout","LayoutError"],"kind":"struct"},"2:22425:173":{"crate_id":2,"path":["core","num","nonzero","NonZeroI8"],"kind":"struct"},"34:5412:22370":{"crate_id":34,"path":["linux_raw_sys","general","ip_beet_phdr"],"kind":"struct"},"34:6478:22418":{"crate_id":34,"path":["linux_raw_sys","general","tcp_info"],"kind":"struct"},"17:13233:20584":{"crate_id":17,"path":["object","pe","ImageAuxSymbolCrc"],"kind":"struct"},"48:6980:22460":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_params"],"kind":"struct"},"41:11467:19305":{"crate_id":41,"path":["object","elf","Syminfo32"],"kind":"struct"},"16:2967:15452":{"crate_id":16,"path":["gimli","common","SectionId"],"kind":"enum"},"1:8286:3442":{"crate_id":1,"path":["std","os","fd","owned","BorrowedFd"],"kind":"struct"},"16:3782:15477":{"crate_id":16,"path":["gimli","constants","DwSectV2"],"kind":"struct"},"40:5708:16355":{"crate_id":40,"path":["gimli","read","cfi","SectionBaseAddresses"],"kind":"struct"},"17:9886:16617":{"crate_id":17,"path":["object","read","elf","hash","HashTable"],"kind":"struct"},"32:492:10026":{"crate_id":32,"path":["libc","unix","utimbuf"],"kind":"struct"},"17:12331:19838":{"crate_id":17,"path":["object","macho","UuidCommand"],"kind":"struct"},"41:9369:16536":{"crate_id":41,"path":["object","read","any","DynamicRelocationIterator"],"kind":"struct"},"5:6597:8972":{"crate_id":5,"path":["alloc","vec","in_place_drop","InPlaceDrop"],"kind":"struct"},"48:6585:22433":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"],"kind":"union"},"2:20594:35002":{"crate_id":2,"path":["core","core_simd","swizzle","deinterleave","Even"],"kind":"struct"},"40:2879:15449":{"crate_id":40,"path":["gimli","common","DebugFrameOffset"],"kind":"struct"},"5:3129:35415":{"crate_id":5,"path":["alloc","collections","btree","set","DifferenceInner"],"kind":"enum"},"41:12827:20559":{"crate_id":41,"path":["object","pe","ImageDosHeader"],"kind":"struct"},"6:1525:10942":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreqn"],"kind":"struct"},"41:11291:19296":{"crate_id":41,"path":["object","elf","FileHeader32"],"kind":"struct"},"2:21559:3336":{"crate_id":2,"path":["core","core_simd","vector","sealed","Sealed"],"kind":"trait"},"40:5779:16358":{"crate_id":40,"path":["gimli","read","cfi","Augmentation"],"kind":"struct"},"17:10598:16548":{"crate_id":17,"path":["object","read","pe","import","Import"],"kind":"enum"},"6:554:10035":{"crate_id":6,"path":["libc","unix","winsize"],"kind":"struct"},"1:7821:130":{"crate_id":1,"path":["std","fs","FileType"],"kind":"struct"},"2:42476:128":{"crate_id":2,"path":["core","fmt","Error"],"kind":"struct"},"47:3846:15262":{"crate_id":47,"path":["rustix","backend","termios","types","Action"],"kind":"enum"},"2:42913:32026":{"crate_id":2,"path":["core","slice","ascii","EscapeByte"],"kind":"struct"},"48:6632:22439":{"crate_id":48,"path":["linux_raw_sys","general","uffdio_range"],"kind":"struct"},"5:1454:198":{"crate_id":5,"path":["alloc","collections","btree","map","Range"],"kind":"struct"},"41:12980:20565":{"crate_id":41,"path":["object","pe","ImageOptionalHeader32"],"kind":"struct"},"41:4091:16506":{"crate_id":41,"path":["object","read","traits","ObjectComdat"],"kind":"trait"},"2:4602:9024":{"crate_id":2,"path":["core","char","REPLACEMENT_CHARACTER"],"kind":"constant"},"17:11902:19812":{"crate_id":17,"path":["object","macho","SegmentCommand32"],"kind":"struct"},"17:13399:20599":{"crate_id":17,"path":["object","pe","ImageResourceDirectory"],"kind":"struct"},"16:7244:37746":{"crate_id":16,"path":["gimli","read","op","OperationEvaluationResult"],"kind":"enum"},"2:42449:71":{"crate_id":2,"path":["core","fmt","rt","Argument"],"kind":"struct"},"48:5754:22393":{"crate_id":48,"path":["linux_raw_sys","general","__sifields"],"kind":"union"},"17:13777:20626":{"crate_id":17,"path":["object","pe","ImageCoffSymbolsHeader"],"kind":"struct"},"1:10050:27454":{"crate_id":1,"path":["std","sys","unix","os_str","Slice"],"kind":"struct"},"34:6050:14989":{"crate_id":34,"path":["linux_raw_sys","general","clone_args"],"kind":"struct"},"20:3456:39034":{"crate_id":20,"path":["clap_builder","builder","arg_settings","Flags"],"kind":"struct"},"16:2298:15397":{"crate_id":16,"path":["gimli","common","Format"],"kind":"enum"},"1:11054:3340":{"crate_id":1,"path":["std","sys","unix","time","SystemTime"],"kind":"struct"},"46:17:24049":{"crate_id":46,"path":["terminal_size","Width"],"kind":"struct"},"41:11657:19319":{"crate_id":41,"path":["object","elf","Vernaux"],"kind":"struct"},"17:10823:16541":{"crate_id":17,"path":["object","read","SectionIndex"],"kind":"struct"},"21:221:20716":{"crate_id":21,"path":["once_cell","sync","Lazy"],"kind":"struct"},"11:119:37577":{"crate_id":11,"path":["hashbrown","raw","RawTable"],"kind":"struct"},"2:44088:9410":{"crate_id":2,"path":["core","str","CharEscapeDefault"],"kind":"struct"},"17:420:15399":{"crate_id":17,"path":["object","read","any","Section"],"kind":"struct"},"2:43809:8941":{"crate_id":2,"path":["core","str","pattern","CharArrayRefSearcher"],"kind":"struct"},"20:72:2664":{"crate_id":20,"path":["clap_builder","derive","ValueEnum"],"kind":"trait"},"41:13123:20573":{"crate_id":41,"path":["object","pe","AnonObjectHeaderV2"],"kind":"struct"},"41:13297:20585":{"crate_id":41,"path":["object","pe","ImageRelocation"],"kind":"struct"},"2:44131:122":{"crate_id":2,"path":["core","time","Duration"],"kind":"struct"},"34:7655:22477":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_buf_reg"],"kind":"struct"},"16:7711:16431":{"crate_id":16,"path":["gimli","read","UnitOffset"],"kind":"struct"},"2:9155:8849":{"crate_id":2,"path":["core","fmt","UpperHex"],"kind":"trait"},"2:11484:9417":{"crate_id":2,"path":["core","str","iter","MatchIndicesInternal"],"kind":"struct"},"5:3163:35420":{"crate_id":5,"path":["alloc","collections","btree","set","IntersectionInner"],"kind":"enum"},"34:7634:22474":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_buf_ring__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"34:6688:14181":{"crate_id":34,"path":["linux_raw_sys","general","termios"],"kind":"struct"},"41:13468:20600":{"crate_id":41,"path":["object","pe","ImageResourceDirectoryEntry"],"kind":"struct"},"41:10509:16713":{"crate_id":41,"path":["object","read","pe","section","PeSegmentIterator"],"kind":"struct"},"41:8740:16499":{"crate_id":41,"path":["object","endian","U16Bytes"],"kind":"struct"},"40:7635:16427":{"crate_id":40,"path":["gimli","read","rnglists","RawRange"],"kind":"struct"},"17:13488:20609":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation64V2"],"kind":"struct"},"20:4055:2973":{"crate_id":20,"path":["clap_builder","builder","value_parser","FalseyValueParser"],"kind":"struct"},"40:7572:37733":{"crate_id":40,"path":["gimli","read","rnglists","RangeListsFormat"],"kind":"enum"},"2:40042:3165":{"crate_id":2,"path":["core","char","EscapeDefault"],"kind":"struct"},"11:638:3189":{"crate_id":11,"path":["hashbrown","map","Iter"],"kind":"struct"},"2:2589:116":{"crate_id":2,"path":["core","default","Default"],"kind":"trait"},"6:5967:14190":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","Elf32_Chdr"],"kind":"struct"},"6:4784:13522":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_tp"],"kind":"struct"},"34:6304:22410":{"crate_id":34,"path":["linux_raw_sys","general","tcphdr"],"kind":"struct"},"17:13356:20595":{"crate_id":17,"path":["object","pe","ImageImportDescriptor"],"kind":"struct"},"20:2766:3190":{"crate_id":20,"path":["clap_builder","util","flat_map","IterMut"],"kind":"struct"},"40:7588:16424":{"crate_id":40,"path":["gimli","read","rnglists","RawRngListIter"],"kind":"struct"},"32:9677:13708":{"crate_id":32,"path":["libc","unix","linux_like","linux","can_frame"],"kind":"struct"},"5:6294:35280":{"crate_id":5,"path":["alloc","vec","drain","drop","DropGuard"],"kind":"struct"},"16:4702:16061":{"crate_id":16,"path":["gimli","constants","DwLang"],"kind":"struct"},"11:1839:3189":{"crate_id":11,"path":["hashbrown","set","Iter"],"kind":"struct"},"2:2348:182":{"crate_id":2,"path":["core","cmp","Ord"],"kind":"trait"},"3:229:210":{"crate_id":3,"path":["compiler_builtins","float","cmp","Result"],"kind":"enum"},"43:234:3524":{"crate_id":43,"path":["miniz_oxide","inflate","core","State"],"kind":"enum"},"40:6254:16373":{"crate_id":40,"path":["gimli","read","endian_slice","EndianSlice"],"kind":"struct"},"42:755:20669":{"crate_id":42,"path":["memchr","memmem","SearcherRev"],"kind":"struct"},"16:4818:16081":{"crate_id":16,"path":["gimli","constants","DwInl"],"kind":"struct"},"41:12116:19821":{"crate_id":41,"path":["object","macho","SubClientCommand"],"kind":"struct"},"41:8708:15393":{"crate_id":41,"path":["object","endian","LittleEndian"],"kind":"struct"},"16:6717:15369":{"crate_id":16,"path":["gimli","read","line","LineSequence"],"kind":"struct"},"2:30864:9050":{"crate_id":2,"path":["core","cmp","Reverse"],"kind":"struct"},"20:1642:20691":{"crate_id":20,"path":["clap_builder","error","format","KindFormatter"],"kind":"struct"},"2:41631:84":{"crate_id":2,"path":["core","sync","atomic","AtomicI8"],"kind":"struct"},"33:4472:39638":{"crate_id":33,"path":["rustix","process","prctl","MachineCheckMemoryCorruptionKillPolicy"],"kind":"enum"},"6:1514:10940":{"crate_id":6,"path":["libc","unix","linux_like","in_addr"],"kind":"struct"},"40:5998:16366":{"crate_id":40,"path":["gimli","read","cfi","CfaRule"],"kind":"enum"},"17:9866:16610":{"crate_id":17,"path":["object","read","elf","note","NoteIterator"],"kind":"struct"},"17:11879:19810":{"crate_id":17,"path":["object","macho","LoadCommand"],"kind":"struct"},"48:4536:9910":{"crate_id":48,"path":["linux_raw_sys","general","flock"],"kind":"struct"},"17:10104:16653":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandIterator"],"kind":"struct"},"34:6204:22406":{"crate_id":34,"path":["linux_raw_sys","general","siginfo__bindgen_ty_1"],"kind":"union"},"32:7584:14190":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","Elf32_Chdr"],"kind":"struct"},"5:963:35280":{"crate_id":5,"path":["alloc","collections","binary_heap","drop","DropGuard"],"kind":"struct"},"6:6706:14610":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpstate"],"kind":"struct"},"2:30041:3415":{"crate_id":2,"path":["core","num","FpCategory"],"kind":"enum"},"41:13442:20598":{"crate_id":41,"path":["object","pe","ImageDelayloadDescriptor"],"kind":"struct"},"16:3225:15456":{"crate_id":16,"path":["gimli","arch","AArch64"],"kind":"struct"},"1:6409:3574":{"crate_id":1,"path":["std","sync","once_lock","OnceLock"],"kind":"struct"},"18:766:20662":{"crate_id":18,"path":["memchr","memmem","SearcherRevKind"],"kind":"enum"},"27:192:15262":{"crate_id":27,"path":["anstyle_parse","state","definitions","Action"],"kind":"enum"},"48:5860:22405":{"crate_id":48,"path":["linux_raw_sys","general","siginfo"],"kind":"struct"},"5:6764:35321":{"crate_id":5,"path":["alloc","vec","dedup_by","FillGapOnDrop"],"kind":"struct"},"41:13306:20586":{"crate_id":41,"path":["object","pe","ImageLinenumber"],"kind":"struct"},"32:7229:14177":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","__timeval"],"kind":"struct"},"1:3939:3429":{"crate_id":1,"path":["std","os","unix","fs","MetadataExt"],"kind":"trait"},"33:2827:20832":{"crate_id":33,"path":["rustix","backend","io","types","SpliceFlags"],"kind":"struct"},"17:12433:19845":{"crate_id":17,"path":["object","macho","BuildVersionCommand"],"kind":"struct"},"41:11376:19300":{"crate_id":41,"path":["object","elf","SectionHeader64"],"kind":"struct"},"2:39114:8835":{"crate_id":2,"path":["core","ops","generator","GeneratorState"],"kind":"enum"},"2:44092:9414":{"crate_id":2,"path":["core","str","IsWhitespace"],"kind":"struct"},"34:7882:14179":{"crate_id":34,"path":["linux_raw_sys","general","msghdr"],"kind":"struct"},"2:45746:3628":{"crate_id":2,"path":["core","core_arch","simd","u8x16"],"kind":"struct"},"48:6357:15149":{"crate_id":48,"path":["linux_raw_sys","general","termios2"],"kind":"struct"},"20:3383:2962":{"crate_id":20,"path":["clap_builder","builder","arg_predicate","ArgPredicate"],"kind":"enum"},"1:10692:130":{"crate_id":1,"path":["std","sys","unix","fs","FileType"],"kind":"struct"},"41:4034:40544":{"crate_id":41,"path":["object","read","traits","Object","section_by_name"],"kind":"foreign_type"},"2:44283:211":{"crate_id":2,"path":["core","future","ResumeTy"],"kind":"struct"},"20:4115:2985":{"crate_id":20,"path":["clap_builder","builder","value_parser","_AnonymousValueParser"],"kind":"struct"},"1:7781:3327":{"crate_id":1,"path":["std","fs","Metadata"],"kind":"struct"},"47:4179:39551":{"crate_id":47,"path":["rustix","process","id","Pid"],"kind":"struct"},"2:41831:89":{"crate_id":2,"path":["core","sync","atomic","AtomicU32"],"kind":"struct"},"16:7366:16411":{"crate_id":16,"path":["gimli","read","op","EvaluationResult"],"kind":"enum"},"16:2616:15438":{"crate_id":16,"path":["gimli","common","DebugMacinfoOffset"],"kind":"struct"},"40:5643:16351":{"crate_id":40,"path":["gimli","read","cfi","EhHdrTable"],"kind":"struct"},"40:7509:16419":{"crate_id":40,"path":["gimli","read","pubtypes","DebugPubTypes"],"kind":"struct"},"34:7084:22450":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_5"],"kind":"union"},"6:6136:14226":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","msqid_ds"],"kind":"struct"},"47:3611:39580":{"crate_id":47,"path":["rustix","backend","process","types","Resource"],"kind":"enum"},"34:0:2639":{"crate_id":34,"path":["linux_raw_sys"],"kind":"module"},"48:5085:22369":{"crate_id":48,"path":["linux_raw_sys","general","ip_comp_hdr"],"kind":"struct"},"41:13669:20614":{"crate_id":41,"path":["object","pe","ImageHotPatchInfo"],"kind":"struct"},"2:40226:8871":{"crate_id":2,"path":["core","iter","adapters","array_chunks","ArrayChunks"],"kind":"struct"},"17:13066:20573":{"crate_id":17,"path":["object","pe","AnonObjectHeaderV2"],"kind":"struct"},"34:6092:22393":{"crate_id":34,"path":["linux_raw_sys","general","__sifields"],"kind":"union"},"25:261:20743":{"crate_id":25,"path":["anstyle","color","Ansi256Color"],"kind":"struct"},"48:4782:22350":{"crate_id":48,"path":["linux_raw_sys","general","fsxattr"],"kind":"struct"},"11:2192:37588":{"crate_id":11,"path":["hashbrown","raw","sse2","Group"],"kind":"struct"},"43:160:15323":{"crate_id":43,"path":["miniz_oxide","inflate","stream","MinReset"],"kind":"struct"},"0:9:1845":{"crate_id":0,"path":["clap","_cookbook","cargo_example_derive"],"kind":"module"},"1:1577:3210":{"crate_id":1,"path":["std","collections","hash","set","Intersection"],"kind":"struct"},"26:286:20762":{"crate_id":26,"path":["anstream","adapter","strip","StripBytes"],"kind":"struct"},"34:4771:22325":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_fsid_t"],"kind":"struct"},"40:5346:16345":{"crate_id":40,"path":["gimli","constants","DwEhPe"],"kind":"struct"},"48:176:20891":{"crate_id":48,"path":["linux_raw_sys","general","__BindgenUnionField"],"kind":"struct"},"33:4822:39537":{"crate_id":33,"path":["rustix","process","prctl","PointerAuthenticationKeys"],"kind":"struct"},"18:736:20661":{"crate_id":18,"path":["memchr","memmem","SearcherKind"],"kind":"enum"},"47:3001:20834":{"crate_id":47,"path":["rustix","backend","io","types","FdFlags"],"kind":"struct"},"20:4079:2974":{"crate_id":20,"path":["clap_builder","builder","value_parser","MapValueParser"],"kind":"struct"},"48:7378:3423":{"crate_id":48,"path":["linux_raw_sys","general","ucred"],"kind":"struct"},"16:6243:37740":{"crate_id":16,"path":["gimli","read","dwarf","RangeIterInner"],"kind":"enum"},"1:11893:1367":{"crate_id":1,"path":["std","slice"],"kind":"primitive"},"2:11726:8905":{"crate_id":2,"path":["core","str","pattern","Searcher"],"kind":"trait"},"11:1091:15344":{"crate_id":11,"path":["hashbrown","map","OccupiedEntryRef"],"kind":"struct"},"47:3873:39619":{"crate_id":47,"path":["rustix","backend","time","types","ClockId"],"kind":"enum"},"1:1924:3285":{"crate_id":1,"path":["std","error","Indented"],"kind":"struct"},"27:26:20781":{"crate_id":27,"path":["anstyle_parse","params","ParamsIter"],"kind":"struct"},"14:215:15363":{"crate_id":14,"path":["rustc_demangle","TryDemangleError"],"kind":"struct"},"20:4727:38928":{"crate_id":20,"path":["clap_builder","mkeymap","MKeyMap"],"kind":"struct"},"16:7588:16424":{"crate_id":16,"path":["gimli","read","rnglists","RawRngListIter"],"kind":"struct"},"40:4327:15902":{"crate_id":40,"path":["gimli","constants","DwAt"],"kind":"struct"},"2:4019:103":{"crate_id":2,"path":["core","asserting","Capture"],"kind":"struct"},"20:4912:3535":{"crate_id":20,"path":["clap_builder","util","graph","Child"],"kind":"struct"},"6:6598:14606":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stack_t"],"kind":"struct"},"1:1080:3207":{"crate_id":1,"path":["std","collections","hash","map","OccupiedError"],"kind":"struct"},"11:1688:144":{"crate_id":11,"path":["hashbrown","set","HashSet"],"kind":"struct"},"34:6655:22421":{"crate_id":34,"path":["linux_raw_sys","general","tcp_diag_md5sig"],"kind":"struct"},"2:9159:8846":{"crate_id":2,"path":["core","fmt","LowerExp"],"kind":"trait"},"23:128:20730":{"crate_id":23,"path":["clap_lex","ParsedArg"],"kind":"struct"},"48:4599:22335":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_policy_v2"],"kind":"struct"},"1:11891:1049":{"crate_id":1,"path":["std","pointer"],"kind":"primitive"},"2:40708:9204":{"crate_id":2,"path":["core","iter","sources","repeat_n","RepeatN"],"kind":"struct"},"16:7529:16421":{"crate_id":16,"path":["gimli","read","rnglists","DebugRanges"],"kind":"struct"},"2:20922:3336":{"crate_id":2,"path":["core","core_simd","elements","sealed","Sealed"],"kind":"trait"},"47:534:3189":{"crate_id":47,"path":["rustix","backend","io","epoll","Iter"],"kind":"struct"},"2:8249:3512":{"crate_id":2,"path":["core","panic","unwind_safe","UnwindSafe"],"kind":"trait"},"40:0:2498":{"crate_id":40,"path":["gimli"],"kind":"module"},"32:5966:13529":{"crate_id":32,"path":["libc","unix","linux_like","linux","nlmsghdr"],"kind":"struct"},"1:8730:3542":{"crate_id":1,"path":["std","process","CommandArgs"],"kind":"struct"},"40:6361:16380":{"crate_id":40,"path":["gimli","read","abbrev","AttributeSpecification"],"kind":"struct"},"17:13324:20592":{"crate_id":17,"path":["object","pe","ImageThunkData32"],"kind":"struct"},"26:333:20768":{"crate_id":26,"path":["anstream","adapter","wincon","WinconBytes"],"kind":"struct"},"2:1667:1087":{"crate_id":2,"path":["core","ptr"],"kind":"module"},"17:13033:20570":{"crate_id":17,"path":["object","pe","ImageRomHeaders"],"kind":"struct"},"5:0:286":{"crate_id":5,"path":["alloc"],"kind":"module"},"48:6923:22456":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_cqe"],"kind":"struct"},"33:3857:39627":{"crate_id":33,"path":["rustix","process","id","Cpuid"],"kind":"struct"},"33:2473:20828":{"crate_id":33,"path":["rustix","backend","io","errno","Errno"],"kind":"struct"},"41:11889:16700":{"crate_id":41,"path":["object","macho","FatArch64"],"kind":"struct"},"41:11147:16553":{"crate_id":41,"path":["object","read","CompressedFileRange"],"kind":"struct"},"34:7930:22488":{"crate_id":34,"path":["linux_raw_sys","general","kernel_sigaction"],"kind":"struct"},"5:4137:3347":{"crate_id":5,"path":["alloc","collections","vec_deque","into_iter","try_fold","Guard"],"kind":"struct"},"16:8025:16438":{"crate_id":16,"path":["gimli","read","unit","Attribute"],"kind":"struct"},"41:242:38756":{"crate_id":41,"path":["object","read","util","DebugByte"],"kind":"struct"},"2:2922:2676":{"crate_id":2,"path":["core","ops","drop","Drop"],"kind":"trait"},"34:5068:22348":{"crate_id":34,"path":["linux_raw_sys","general","files_stat_struct"],"kind":"struct"},"48:6606:22436":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_4"],"kind":"struct"},"1:1982:185":{"crate_id":1,"path":["std","ffi","os_str","OsString"],"kind":"struct"},"6:6691:14608":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpxreg"],"kind":"struct"},"2:41226:3400":{"crate_id":2,"path":["core","net","ip_addr","Ipv4Addr"],"kind":"struct"},"40:5741:16357":{"crate_id":40,"path":["gimli","read","cfi","CieOrFde"],"kind":"enum"},"40:4480:15983":{"crate_id":40,"path":["gimli","constants","DwLle"],"kind":"struct"},"2:46370:3694":{"crate_id":2,"path":["core","core_arch","simd","u16x16"],"kind":"struct"},"1:6009:27084":{"crate_id":1,"path":["std","sync","mpmc","list","Channel"],"kind":"struct"},"20:4371:3193":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","Values"],"kind":"struct"},"41:10855:16540":{"crate_id":41,"path":["object","read","ObjectKind"],"kind":"enum"},"41:10340:16658":{"crate_id":41,"path":["object","read","macho","segment","MachOSegmentInternal"],"kind":"struct"},"41:12350:19835":{"crate_id":41,"path":["object","macho","TwolevelHintsCommand"],"kind":"struct"},"41:10573:16706":{"crate_id":41,"path":["object","read","pe","data_directory","DataDirectories"],"kind":"struct"},"16:6488:16388":{"crate_id":16,"path":["gimli","read","index","UnitIndex"],"kind":"struct"},"16:7488:16417":{"crate_id":16,"path":["gimli","read","pubnames","PubNamesEntryIter"],"kind":"struct"},"1:8427:3526":{"crate_id":1,"path":["std","path","Component"],"kind":"enum"},"0:17:1853":{"crate_id":0,"path":["clap","_cookbook","pacman"],"kind":"module"},"48:6597:22435":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_3"],"kind":"struct"},"16:7757:16433":{"crate_id":16,"path":["gimli","read","unit","DebugInfoUnitHeadersIter"],"kind":"struct"},"43:502:15226":{"crate_id":43,"path":["miniz_oxide","StreamResult"],"kind":"struct"},"20:4656:20702":{"crate_id":20,"path":["clap_builder","parser","parser","Identifier"],"kind":"enum"},"5:7022:3218":{"crate_id":5,"path":["alloc","collections","binary_heap","DrainSorted"],"kind":"struct"},"47:3572:39611":{"crate_id":47,"path":["rustix","backend","process","types","MembarrierCommand"],"kind":"enum"},"5:5642:232":{"crate_id":5,"path":["alloc","string","ToString"],"kind":"trait"},"18:531:20674":{"crate_id":18,"path":["memchr","memmem","prefilter","PrefilterState"],"kind":"struct"},"2:43792:8940":{"crate_id":2,"path":["core","str","pattern","CharArraySearcher"],"kind":"struct"},"34:5388:22367":{"crate_id":34,"path":["linux_raw_sys","general","ip_auth_hdr"],"kind":"struct"},"41:11024:16548":{"crate_id":41,"path":["object","read","Import"],"kind":"struct"},"16:2470:15432":{"crate_id":16,"path":["gimli","common","DebugInfoOffset"],"kind":"struct"},"17:12236:19832":{"crate_id":17,"path":["object","macho","DylibModule32"],"kind":"struct"},"17:13612:20614":{"crate_id":17,"path":["object","pe","ImageHotPatchInfo"],"kind":"struct"},"41:12540:19848":{"crate_id":41,"path":["object","macho","LinkerOptionCommand"],"kind":"struct"},"34:4941:22339":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_key_specifier__bindgen_ty_1"],"kind":"union"},"41:13090:20570":{"crate_id":41,"path":["object","pe","ImageRomHeaders"],"kind":"struct"},"2:42695:3524":{"crate_id":2,"path":["core","hash","sip","State"],"kind":"struct"},"17:11220:16759":{"crate_id":17,"path":["object","archive","AixMemberOffset"],"kind":"struct"},"2:20938:3629":{"crate_id":2,"path":["core","core_simd","eq","SimdPartialEq"],"kind":"trait"},"41:4015:16505":{"crate_id":41,"path":["object","read","traits","Object"],"kind":"trait"},"48:5245:10031":{"crate_id":48,"path":["linux_raw_sys","general","ipv6_mreq"],"kind":"struct"},"34:7025:22444":{"crate_id":34,"path":["linux_raw_sys","general","uffdio_continue"],"kind":"struct"},"5:1366:3190":{"crate_id":5,"path":["alloc","collections","btree","map","IterMut"],"kind":"struct"},"17:13689:20621":{"crate_id":17,"path":["object","pe","ImageRuntimeFunctionEntry"],"kind":"struct"},"17:12178:19829":{"crate_id":17,"path":["object","macho","SymtabCommand"],"kind":"struct"},"32:5148:13490":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_replay"],"kind":"struct"},"20:4845:39023":{"crate_id":20,"path":["clap_builder","output","textwrap","wrap_algorithms","LineWrapper"],"kind":"struct"},"2:43479:8894":{"crate_id":2,"path":["core","str","iter","RSplitN"],"kind":"struct"},"34:6954:22436":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_4"],"kind":"struct"},"6:4431:13486":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_id"],"kind":"struct"},"41:8689:16495":{"crate_id":41,"path":["object","endian","Endianness"],"kind":"enum"},"33:2317:20864":{"crate_id":33,"path":["rustix","backend","io","epoll","EventFlags"],"kind":"struct"},"48:6138:22418":{"crate_id":48,"path":["linux_raw_sys","general","tcp_info"],"kind":"struct"},"17:10354:16662":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbolTable"],"kind":"struct"},"1:4176:3460":{"crate_id":1,"path":["std","os","unix","net","datagram","UnixDatagram"],"kind":"struct"},"2:7318:159":{"crate_id":2,"path":["core","iter","traits","iterator","Iterator"],"kind":"trait"},"41:11981:19813":{"crate_id":41,"path":["object","macho","SegmentCommand64"],"kind":"struct"},"17:9534:16573":{"crate_id":17,"path":["object","read","coff","section","CoffSectionIterator"],"kind":"struct"},"2:43674:8919":{"crate_id":2,"path":["core","str","iter","EscapeUnicode"],"kind":"struct"},"32:8417:14606":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stack_t"],"kind":"struct"},"20:4714:27433":{"crate_id":20,"path":["clap_builder","mkeymap","Key"],"kind":"struct"},"1:8907:24673":{"crate_id":1,"path":["std","sync","mpmc","array","ArrayToken"],"kind":"struct"},"40:4932:16099":{"crate_id":40,"path":["gimli","constants","DwDefaulted"],"kind":"struct"},"41:10800:16538":{"crate_id":41,"path":["object","read","traits","NoDynamicRelocationIterator"],"kind":"struct"},"18:719:20660":{"crate_id":18,"path":["memchr","memmem","NeedleInfo"],"kind":"struct"},"6:4970:13544":{"crate_id":6,"path":["libc","unix","linux_like","linux","dirent64"],"kind":"struct"},"40:7498:16418":{"crate_id":40,"path":["gimli","read","pubtypes","PubTypesEntry"],"kind":"struct"},"1:5354:3537":{"crate_id":1,"path":["std","process","ChildStdout"],"kind":"struct"},"16:7042:37863":{"crate_id":16,"path":["gimli","read","lookup","PubStuffHeader"],"kind":"struct"},"34:6383:22414":{"crate_id":34,"path":["linux_raw_sys","general","tcp_repair_window"],"kind":"struct"},"17:13667:20619":{"crate_id":17,"path":["object","pe","ImageAlpha64RuntimeFunctionEntry"],"kind":"struct"},"32:467:9654":{"crate_id":32,"path":["libc","unix","DIR"],"kind":"enum"},"17:13385:20598":{"crate_id":17,"path":["object","pe","ImageDelayloadDescriptor"],"kind":"struct"},"6:5798:14179":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","msghdr"],"kind":"struct"},"17:8598:16524":{"crate_id":17,"path":["object","common","SymbolFlags"],"kind":"enum"},"2:45491:3687":{"crate_id":2,"path":["core","core_arch","simd","u8x8"],"kind":"struct"},"20:3763:39128":{"crate_id":20,"path":["clap_builder","builder","ext","BoxedEntry"],"kind":"struct"},"9:174:15326":{"crate_id":9,"path":["miniz_oxide","inflate","stream","InflateState"],"kind":"struct"},"17:1034:16581":{"crate_id":17,"path":["object","read","coff","relocation","CoffRelocationIterator"],"kind":"struct"},"47:4196:39627":{"crate_id":47,"path":["rustix","process","id","Cpuid"],"kind":"struct"},"17:11585:19318":{"crate_id":17,"path":["object","elf","Verneed"],"kind":"struct"},"1:3440:3286":{"crate_id":1,"path":["std","io","Write"],"kind":"trait"},"1:10865:3545":{"crate_id":1,"path":["std","sys","unix","process","process_common","ExitCode"],"kind":"struct"},"6:1576:10948":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_ll"],"kind":"struct"},"2:7198:134":{"crate_id":2,"path":["core","iter","traits","collect","FromIterator"],"kind":"trait"},"1:6552:3576":{"crate_id":1,"path":["std","sync","remutex","ReentrantMutexGuard"],"kind":"struct"},"40:5693:16354":{"crate_id":40,"path":["gimli","read","cfi","BaseAddresses"],"kind":"struct"},"2:4322:9008":{"crate_id":2,"path":["core","cell","BorrowRef"],"kind":"struct"},"40:55:15392":{"crate_id":40,"path":["gimli","endianity","Endianity"],"kind":"trait"},"2:41711:81":{"crate_id":2,"path":["core","sync","atomic","AtomicI16"],"kind":"struct"},"16:5847:16360":{"crate_id":16,"path":["gimli","read","cfi","PartialFrameDescriptionEntry"],"kind":"struct"},"32:7681:14195":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_seccomp"],"kind":"struct"},"2:7211:2681":{"crate_id":2,"path":["core","iter","traits","collect","Extend"],"kind":"trait"},"17:12126:19826":{"crate_id":17,"path":["object","macho","ThreadCommand"],"kind":"struct"},"34:6702:15149":{"crate_id":34,"path":["linux_raw_sys","general","termios2"],"kind":"struct"},"0:25:1713":{"crate_id":0,"path":["clap","_tutorial"],"kind":"module"},"34:7824:10881":{"crate_id":34,"path":["linux_raw_sys","general","statfs64"],"kind":"struct"},"11:1071:37598":{"crate_id":11,"path":["hashbrown","map","KeyOrRef"],"kind":"enum"},"1:5926:206":{"crate_id":1,"path":["std","sync","mpmc","counter","Receiver"],"kind":"struct"},"6:6587:14605":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","siginfo_t"],"kind":"struct"},"16:2786:15445":{"crate_id":16,"path":["gimli","common","DebugStrOffsetsBase"],"kind":"struct"},"6:1736:10963":{"crate_id":6,"path":["libc","unix","linux_like","utsname"],"kind":"struct"},"48:5851:22404":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_7"],"kind":"struct"},"17:12634:19858":{"crate_id":17,"path":["object","macho","RelocationInfo"],"kind":"struct"},"41:10109:16674":{"crate_id":41,"path":["object","read","macho","file","MachOFile"],"kind":"struct"},"28:89:2662":{"crate_id":28,"path":["utf8parse","Parser"],"kind":"struct"},"16:5571:16347":{"crate_id":16,"path":["gimli","read","cfi","DebugFrame"],"kind":"struct"},"17:12563:19854":{"crate_id":17,"path":["object","macho","DataInCodeEntry"],"kind":"struct"},"48:5888:22408":{"crate_id":48,"path":["linux_raw_sys","general","sigevent__bindgen_ty_1"],"kind":"union"},"41:10391:16534":{"crate_id":41,"path":["object","read","macho","symbol","SymbolTable"],"kind":"struct"},"2:2843:9275":{"crate_id":2,"path":["core","ops","bit","BitOrAssign"],"kind":"trait"},"40:7467:16415":{"crate_id":40,"path":["gimli","read","pubnames","PubNamesEntry"],"kind":"struct"},"41:10584:16742":{"crate_id":41,"path":["object","read","pe","export","ExportTarget"],"kind":"enum"},"16:5032:16127":{"crate_id":16,"path":["gimli","constants","DwLnct"],"kind":"struct"},"16:6575:16393":{"crate_id":16,"path":["gimli","read","line","LineInstruction"],"kind":"enum"},"40:7449:16414":{"crate_id":40,"path":["gimli","read","op","Evaluation"],"kind":"struct"},"32:5280:13497":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_rumble_effect"],"kind":"struct"},"6:4459:13489":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_mask"],"kind":"struct"},"32:5297:13498":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_effect"],"kind":"struct"},"5:5485:8971":{"crate_id":5,"path":["alloc","string","retain","SetLenOnDrop"],"kind":"struct"},"5:5798:70":{"crate_id":5,"path":["alloc","sync","Arc"],"kind":"struct"},"2:41203:155":{"crate_id":2,"path":["core","net","ip_addr","IpAddr"],"kind":"enum"},"5:4336:35285":{"crate_id":5,"path":["alloc","collections","vec_deque","drop","Dropper"],"kind":"struct"},"18:609:38793":{"crate_id":18,"path":["memchr","memmem","twoway","Suffix"],"kind":"struct"},"2:43763:8938":{"crate_id":2,"path":["core","str","pattern","CharSearcher"],"kind":"struct"},"2:9157:194":{"crate_id":2,"path":["core","fmt","Pointer"],"kind":"trait"},"2:22524:172":{"crate_id":2,"path":["core","num","nonzero","NonZeroI64"],"kind":"struct"},"40:6890:16402":{"crate_id":40,"path":["gimli","read","loclists","DebugLocLists"],"kind":"struct"},"33:4615:39549":{"crate_id":33,"path":["rustix","process","prctl","SpeculationFeatureControl"],"kind":"struct"},"41:10016:16645":{"crate_id":41,"path":["object","read","elf","version","VerdauxIterator"],"kind":"struct"},"32:5572:13510":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf64_Shdr"],"kind":"struct"},"11:840:3201":{"crate_id":11,"path":["hashbrown","map","RawOccupiedEntryMut"],"kind":"struct"},"1:8047:3330":{"crate_id":1,"path":["std","io","readbuf","BorrowedCursor"],"kind":"struct"},"32:5087:13487":{"crate_id":32,"path":["libc","unix","linux_like","linux","input_absinfo"],"kind":"struct"},"2:4251:207":{"crate_id":2,"path":["core","cell","RefCell"],"kind":"struct"},"6:4546:13500":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_ff_erase"],"kind":"struct"},"18:96:20647":{"crate_id":18,"path":["memchr","memchr","iter","Memchr2"],"kind":"struct"},"40:7029:37674":{"crate_id":40,"path":["gimli","read","lookup","LookupEntryIter"],"kind":"struct"},"41:8966:3361":{"crate_id":41,"path":["object","read","util","Bytes"],"kind":"struct"},"14:31:15354":{"crate_id":14,"path":["rustc_demangle","v0","Demangle"],"kind":"struct"},"41:11959:19812":{"crate_id":41,"path":["object","macho","SegmentCommand32"],"kind":"struct"},"5:7164:102":{"crate_id":5,"path":["alloc","ffi","c_str","CString"],"kind":"struct"},"5:7211:3287":{"crate_id":5,"path":["alloc","ffi","c_str","FromVecWithNulError"],"kind":"struct"},"34:5661:22382":{"crate_id":34,"path":["linux_raw_sys","general","ipv6hdr__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"1:5067:191":{"crate_id":1,"path":["std","path","PathBuf"],"kind":"struct"},"48:6569:22431":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1"],"kind":"union"},"40:5071:16142":{"crate_id":40,"path":["gimli","constants","DwMacro"],"kind":"struct"},"17:13257:20587":{"crate_id":17,"path":["object","pe","ImageBaseRelocation"],"kind":"struct"},"17:11615:19320":{"crate_id":17,"path":["object","elf","NoteHeader32"],"kind":"struct"},"48:6711:22447":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_2"],"kind":"union"},"41:13878:20630":{"crate_id":41,"path":["object","pe","ImageSeparateDebugHeader"],"kind":"struct"},"15:198:15373":{"crate_id":15,"path":["addr2line","LocationRangeUnitIter"],"kind":"struct"},"33:4086:39594":{"crate_id":33,"path":["rustix","process","prctl","DumpableBehavior"],"kind":"enum"},"2:47666:8798":{"crate_id":2,"path":["core","core_arch","x86","__m128i"],"kind":"struct"},"32:5008:13483":{"crate_id":32,"path":["libc","unix","linux_like","linux","msginfo"],"kind":"struct"},"20:3650:2652":{"crate_id":20,"path":["clap_builder","builder","command","Command"],"kind":"struct"},"41:11396:19301":{"crate_id":41,"path":["object","elf","CompressionHeader32"],"kind":"struct"},"20:4837:20685":{"crate_id":20,"path":["clap_builder","output","fmt","Colorizer"],"kind":"struct"},"2:20760:3636":{"crate_id":2,"path":["core","core_simd","elements","const_ptr","SimdConstPtr"],"kind":"trait"},"32:5699:13515":{"crate_id":32,"path":["libc","unix","linux_like","linux","in6_pktinfo"],"kind":"struct"},"32:9291:14988":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","align","max_align_t"],"kind":"struct"},"5:4399:35285":{"crate_id":5,"path":["alloc","collections","vec_deque","truncate","Dropper"],"kind":"struct"},"42:681:20665":{"crate_id":42,"path":["memchr","memmem","Finder"],"kind":"struct"},"41:12506:19846":{"crate_id":41,"path":["object","macho","BuildToolVersion"],"kind":"struct"},"6:4653:13509":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Shdr"],"kind":"struct"},"2:6977:3556":{"crate_id":2,"path":["core","iter","sources","once","once"],"kind":"function"},"5:2189:35131":{"crate_id":5,"path":["alloc","collections","btree","navigate","LazyLeafRange"],"kind":"struct"},"1:7677:3272":{"crate_id":1,"path":["std","env","VarError"],"kind":"enum"},"25:210:20742":{"crate_id":25,"path":["anstyle","color","AnsiColor"],"kind":"enum"},"48:5983:22411":{"crate_id":48,"path":["linux_raw_sys","general","tcp_word_hdr"],"kind":"union"},"7:79:15201":{"crate_id":7,"path":["unwind","libunwind","_Unwind_Action"],"kind":"enum"},"47:3476:20829":{"crate_id":47,"path":["rustix","backend","io","types","EventfdFlags"],"kind":"struct"},"5:5239:8866":{"crate_id":5,"path":["alloc","slice","Join"],"kind":"trait"},"47:4024:39536":{"crate_id":47,"path":["rustix","backend","time","types","TimerfdTimerFlags"],"kind":"struct"},"20:68:2663":{"crate_id":20,"path":["clap_builder","derive","Subcommand"],"kind":"trait"},"2:10203:8893":{"crate_id":2,"path":["core","slice","iter","RSplitMut"],"kind":"struct"},"41:13413:20595":{"crate_id":41,"path":["object","pe","ImageImportDescriptor"],"kind":"struct"},"32:6254:13544":{"crate_id":32,"path":["libc","unix","linux_like","linux","dirent64"],"kind":"struct"},"5:6999:3191":{"crate_id":5,"path":["alloc","collections","binary_heap","IntoIter"],"kind":"struct"},"17:11339:19301":{"crate_id":17,"path":["object","elf","CompressionHeader32"],"kind":"struct"},"20:3364:2655":{"crate_id":20,"path":["clap_builder","builder","arg_group","ArgGroup"],"kind":"struct"},"40:6132:16368":{"crate_id":40,"path":["gimli","read","cfi","CallFrameInstructionIter"],"kind":"struct"},"16:5944:16363":{"crate_id":16,"path":["gimli","read","cfi","UnwindTable"],"kind":"struct"},"41:9010:16529":{"crate_id":41,"path":["object","read","util","StringTable"],"kind":"struct"},"16:8170:16446":{"crate_id":16,"path":["gimli","read","unit","DebugTypesUnitHeadersIter"],"kind":"struct"},"17:10080:16696":{"crate_id":17,"path":["object","read","macho","file","MachOComdat"],"kind":"struct"},"20:1142:2983":{"crate_id":20,"path":["clap_builder","builder","value_parser","ValueParser"],"kind":"struct"},"2:3142:9280":{"crate_id":2,"path":["core","ops","range","OneSidedRange"],"kind":"trait"},"17:10735:16751":{"crate_id":17,"path":["object","read","pe","rich","RichHeaderEntry"],"kind":"struct"},"34:6152:22400":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"5:1382:3191":{"crate_id":5,"path":["alloc","collections","btree","map","IntoIter"],"kind":"struct"},"1:10657:3325":{"crate_id":1,"path":["std","sys","unix","fs","OpenOptions"],"kind":"struct"},"2:44376:8820":{"crate_id":2,"path":["core","alloc","AllocError"],"kind":"struct"},"41:9710:16609":{"crate_id":41,"path":["object","read","elf","file","ElfFile"],"kind":"struct"},"25:127:39333":{"crate_id":25,"path":["anstyle","reset","ResetDisplay"],"kind":"struct"},"16:7683:16429":{"crate_id":16,"path":["gimli","read","str","DebugStrOffsets"],"kind":"struct"},"41:3480:16725":{"crate_id":41,"path":["object","read","pe","file","ImageOptionalHeader"],"kind":"trait"},"18:564:20676":{"crate_id":18,"path":["memchr","memmem","rarebytes","RareNeedleBytes"],"kind":"struct"},"1:844:3189":{"crate_id":1,"path":["std","collections","hash","map","Iter"],"kind":"struct"},"6:6776:14613":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","mcontext_t"],"kind":"struct"},"5:4818:204":{"crate_id":5,"path":["alloc","rc","Rc"],"kind":"struct"},"2:43461:8896":{"crate_id":2,"path":["core","str","iter","SplitN"],"kind":"struct"},"32:7335:14142":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","mallinfo"],"kind":"struct"},"1:5179:190":{"crate_id":1,"path":["std","path","Path"],"kind":"struct"},"17:11653:19323":{"crate_id":17,"path":["object","elf","GnuHashHeader"],"kind":"struct"},"27:132:3524":{"crate_id":27,"path":["anstyle_parse","state","definitions","State"],"kind":"enum"},"16:6460:16386":{"crate_id":16,"path":["gimli","read","index","DebugCuIndex"],"kind":"struct"},"34:5284:22358":{"crate_id":34,"path":["linux_raw_sys","general","ip_msfilter__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"2:40473:9232":{"crate_id":2,"path":["core","iter","adapters","take_while","TakeWhile"],"kind":"struct"},"34:4853:14604":{"crate_id":34,"path":["linux_raw_sys","general","flock64"],"kind":"struct"},"41:12050:19816":{"crate_id":41,"path":["object","macho","Fvmlib"],"kind":"struct"},"1:9981:3264":{"crate_id":1,"path":["std","sys","unix","os","SplitPaths"],"kind":"struct"},"2:10272:8897":{"crate_id":2,"path":["core","slice","iter","SplitNMut"],"kind":"struct"},"1:7659:3174":{"crate_id":1,"path":["std","backtrace","RawFrame"],"kind":"enum"},"16:2905:15450":{"crate_id":16,"path":["gimli","common","EhFrameOffset"],"kind":"struct"},"6:4371:13479":{"crate_id":6,"path":["libc","unix","linux_like","linux","itimerspec"],"kind":"struct"},"35:0:2640":{"crate_id":35,"path":["anstyle_query"],"kind":"module"},"1:8220:3463":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryError"],"kind":"enum"},"40:8090:16441":{"crate_id":40,"path":["gimli","read","unit","EntriesCursor"],"kind":"struct"},"6:526:10031":{"crate_id":6,"path":["libc","unix","ipv6_mreq"],"kind":"struct"},"32:560:10030":{"crate_id":32,"path":["libc","unix","rusage"],"kind":"struct"},"31:28:20797":{"crate_id":31,"path":["io_lifetimes","portability","AsSocketlike"],"kind":"trait"},"20:4893:39043":{"crate_id":20,"path":["clap_builder","util","flat_set","FlatSet"],"kind":"struct"},"1:4639:3492":{"crate_id":1,"path":["std","os","linux","process","ChildExt"],"kind":"trait"},"17:13135:20576":{"crate_id":17,"path":["object","pe","ImageSymbolBytes"],"kind":"struct"},"2:11712:8907":{"crate_id":2,"path":["core","str","pattern"],"kind":"module"},"1:8800:3191":{"crate_id":1,"path":["std","sync","mpsc","IntoIter"],"kind":"struct"},"48:4467:22323":{"crate_id":48,"path":["linux_raw_sys","general","__BindgenBitfieldUnit"],"kind":"struct"},"36:551:23970":{"crate_id":36,"path":["backtrace","print","PrintFmt"],"kind":"enum"},"41:13072:20568":{"crate_id":41,"path":["object","pe","ImageNtHeaders64"],"kind":"struct"},"41:12155:19824":{"crate_id":41,"path":["object","macho","PreboundDylibCommand"],"kind":"struct"},"43:421:15225":{"crate_id":43,"path":["miniz_oxide","MZStatus"],"kind":"enum"},"16:4568:15999":{"crate_id":16,"path":["gimli","constants","DwAccess"],"kind":"struct"},"2:9609:26937":{"crate_id":2,"path":["core","slice","sort","merge_sort","BufGuard"],"kind":"struct"},"2:10130:8899":{"crate_id":2,"path":["core","slice","iter","SplitInclusiveMut"],"kind":"struct"},"17:9148:38748":{"crate_id":17,"path":["object","read","any","ComdatIteratorInternal"],"kind":"enum"},"17:12059:19821":{"crate_id":17,"path":["object","macho","SubClientCommand"],"kind":"struct"},"41:10897:16542":{"crate_id":41,"path":["object","read","SymbolIndex"],"kind":"struct"},"2:30836:183":{"crate_id":2,"path":["core","cmp","Ordering"],"kind":"enum"},"16:7317:37729":{"crate_id":16,"path":["gimli","read","op","EvaluationState"],"kind":"enum"},"33:4594:39626":{"crate_id":33,"path":["rustix","process","prctl","SpeculationFeature"],"kind":"enum"},"16:7467:16415":{"crate_id":16,"path":["gimli","read","pubnames","PubNamesEntry"],"kind":"struct"},"41:8655:16524":{"crate_id":41,"path":["object","common","SymbolFlags"],"kind":"enum"},"20:4349:20701":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","SubCommand"],"kind":"struct"},"34:5539:15178":{"crate_id":34,"path":["linux_raw_sys","general","in6_addr"],"kind":"struct"},"6:6848:14619":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ucontext_t"],"kind":"struct"},"2:39302:3181":{"crate_id":2,"path":["core","ops","range","Bound"],"kind":"enum"},"6:5816:14181":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","termios"],"kind":"struct"},"2:47464:3701":{"crate_id":2,"path":["core","core_arch","simd","u32x16"],"kind":"struct"},"17:11785:19806":{"crate_id":17,"path":["object","macho","DyldCacheImageInfo"],"kind":"struct"},"1:3933:3428":{"crate_id":1,"path":["std","os","unix","fs","OpenOptionsExt"],"kind":"trait"},"41:12593:19852":{"crate_id":41,"path":["object","macho","EntryPointCommand"],"kind":"struct"},"16:7859:16437":{"crate_id":16,"path":["gimli","read","unit","AttributeValue"],"kind":"enum"},"1:8410:3525":{"crate_id":1,"path":["std","path","PrefixComponent"],"kind":"struct"},"6:6553:10880":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs"],"kind":"struct"},"48:6640:22440":{"crate_id":48,"path":["linux_raw_sys","general","uffdio_register"],"kind":"struct"},"5:7181:3289":{"crate_id":5,"path":["alloc","ffi","c_str","NulError"],"kind":"struct"},"34:5889:10034":{"crate_id":34,"path":["linux_raw_sys","general","pollfd"],"kind":"struct"},"34:6137:22398":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5"],"kind":"struct"},"2:20879:9293":{"crate_id":2,"path":["core","core_simd","elements","mut_ptr","SimdMutPtr","from_exposed_addr"],"kind":"foreign_type"},"34:6252:14114":{"crate_id":34,"path":["linux_raw_sys","general","statx"],"kind":"struct"},"1:8960:24689":{"crate_id":1,"path":["std","sync","mpmc","select","Token"],"kind":"struct"},"20:1394:2984":{"crate_id":20,"path":["clap_builder","builder","value_parser","ValueParserFactory"],"kind":"trait"},"41:12553:19849":{"crate_id":41,"path":["object","macho","SymsegCommand"],"kind":"struct"},"5:2906:35191":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Dying"],"kind":"enum"},"6:4952:13542":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_nl"],"kind":"struct"},"40:5797:37853":{"crate_id":40,"path":["gimli","read","cfi","AugmentationData"],"kind":"struct"},"6:6800:14615":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","shmid_ds"],"kind":"struct"},"48:4806:22352":{"crate_id":48,"path":["linux_raw_sys","general","robust_list"],"kind":"struct"},"2:45437:3651":{"crate_id":2,"path":["core","core_arch","simd","i8x4"],"kind":"struct"},"17:8632:16495":{"crate_id":17,"path":["object","endian","Endianness"],"kind":"enum"},"17:11891:19811":{"crate_id":17,"path":["object","macho","LcStr"],"kind":"struct"},"5:1716:3195":{"crate_id":5,"path":["alloc","collections","btree","map","DrainFilter"],"kind":"struct"},"1:3449:26359":{"crate_id":1,"path":["std","io","Write","write_fmt","Adapter"],"kind":"struct"},"34:5918:22386":{"crate_id":34,"path":["linux_raw_sys","general","rand_pool_info"],"kind":"struct"},"16:4845:16084":{"crate_id":16,"path":["gimli","constants","DwOrd"],"kind":"struct"},"17:13344:20594":{"crate_id":17,"path":["object","pe","ImageTlsDirectory32"],"kind":"struct"},"1:3132:26520":{"crate_id":1,"path":["std","io","stdio","StdoutRaw"],"kind":"struct"},"6:1715:10961":{"crate_id":6,"path":["libc","unix","linux_like","epoll_event"],"kind":"struct"},"41:13834:20626":{"crate_id":41,"path":["object","pe","ImageCoffSymbolsHeader"],"kind":"struct"},"2:40296:9220":{"crate_id":2,"path":["core","iter","adapters","enumerate","Enumerate"],"kind":"struct"},"5:2116:35129":{"crate_id":5,"path":["alloc","collections","btree","navigate","LeafRange"],"kind":"struct"},"28:0:2634":{"crate_id":28,"path":["utf8parse"],"kind":"module"},"41:11339:19298":{"crate_id":41,"path":["object","elf","Ident"],"kind":"struct"},"16:6935:16404":{"crate_id":16,"path":["gimli","read","loclists","RawLocListIter"],"kind":"struct"},"16:5708:16355":{"crate_id":16,"path":["gimli","read","cfi","SectionBaseAddresses"],"kind":"struct"},"17:13879:20634":{"crate_id":17,"path":["object","pe","ImageCor20Header"],"kind":"struct"},"2:4183:8861":{"crate_id":2,"path":["core","cell","Cell"],"kind":"struct"},"6:4947:13541":{"crate_id":6,"path":["libc","unix","linux_like","linux","sctp_authinfo"],"kind":"struct"},"6:4449:13488":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_keymap_entry"],"kind":"struct"},"16:5071:16142":{"crate_id":16,"path":["gimli","constants","DwMacro"],"kind":"struct"},"40:7519:16420":{"crate_id":40,"path":["gimli","read","pubtypes","PubTypesEntryIter"],"kind":"struct"},"21:126:20716":{"crate_id":21,"path":["once_cell","unsync","Lazy"],"kind":"struct"},"48:5551:10034":{"crate_id":48,"path":["linux_raw_sys","general","pollfd"],"kind":"struct"},"17:10798:16540":{"crate_id":17,"path":["object","read","ObjectKind"],"kind":"enum"},"16:7029:37674":{"crate_id":16,"path":["gimli","read","lookup","LookupEntryIter"],"kind":"struct"},"1:5502:3541":{"crate_id":1,"path":["std","process","Termination"],"kind":"trait"},"41:10637:16743":{"crate_id":41,"path":["object","read","pe","import","ImportDescriptorIterator"],"kind":"struct"},"5:2636:35377":{"crate_id":5,"path":["alloc","collections","btree","node","Handle"],"kind":"struct"},"5:6097:3770":{"crate_id":5,"path":["alloc","task","Wake"],"kind":"trait"},"16:8156:16445":{"crate_id":16,"path":["gimli","read","unit","DebugTypes"],"kind":"struct"},"6:4911:13537":{"crate_id":6,"path":["libc","unix","linux_like","linux","sctp_sndinfo"],"kind":"struct"},"40:5630:16350":{"crate_id":40,"path":["gimli","read","cfi","EhHdrTableIter"],"kind":"struct"},"2:47721:8803":{"crate_id":2,"path":["core","core_arch","x86","__m256d"],"kind":"struct"},"41:9165:38744":{"crate_id":41,"path":["object","read","any","SectionIteratorInternal"],"kind":"enum"},"34:5119:22353":{"crate_id":34,"path":["linux_raw_sys","general","robust_list_head"],"kind":"struct"},"47:5181:39602":{"crate_id":47,"path":["rustix","process","rlimit","Rlimit"],"kind":"struct"},"1:7937:24687":{"crate_id":1,"path":["std","io","error","Custom"],"kind":"struct"},"26:319:20778":{"crate_id":26,"path":["anstream","adapter","strip","Utf8Parser"],"kind":"struct"},"6:1721:3451":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_un"],"kind":"struct"},"2:2812:9268":{"crate_id":2,"path":["core","ops","bit","BitAnd"],"kind":"trait"},"47:5210:39547":{"crate_id":47,"path":["rustix","process","wait","WaitOptions"],"kind":"struct"},"48:6649:22441":{"crate_id":48,"path":["linux_raw_sys","general","uffdio_copy"],"kind":"struct"},"6:5058:13552":{"crate_id":6,"path":["libc","unix","linux_like","linux","hwtstamp_config"],"kind":"struct"},"16:2524:15434":{"crate_id":16,"path":["gimli","common","DebugLineStrOffset"],"kind":"struct"},"41:487:16512":{"crate_id":41,"path":["object","read","any","Comdat"],"kind":"struct"},"2:39192:198":{"crate_id":2,"path":["core","ops","range","Range"],"kind":"struct"},"0:8:1844":{"crate_id":0,"path":["clap","_cookbook","cargo_example"],"kind":"module"},"11:1879:3213":{"crate_id":11,"path":["hashbrown","set","Union"],"kind":"struct"},"2:42705:34238":{"crate_id":2,"path":["core","hash","sip","Sip13Rounds"],"kind":"struct"},"6:6545:10076":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","sigaction"],"kind":"struct"},"26:231:20764":{"crate_id":26,"path":["anstream","adapter","strip","StripStr"],"kind":"struct"},"40:7652:198":{"crate_id":40,"path":["gimli","read","rnglists","Range"],"kind":"struct"},"2:43579:8925":{"crate_id":2,"path":["core","str","iter","RMatches"],"kind":"struct"},"2:40076:9033":{"crate_id":2,"path":["core","char","ToUppercase"],"kind":"struct"},"2:39216:199":{"crate_id":2,"path":["core","ops","range","RangeFrom"],"kind":"struct"},"47:4115:39590":{"crate_id":47,"path":["rustix","backend","time","types","TimerfdClockId"],"kind":"enum"},"32:7664:14194":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_exit"],"kind":"struct"},"1:2832:25275":{"crate_id":1,"path":["std","io","error","repr_bitpacked","Repr"],"kind":"struct"},"32:6264:13545":{"crate_id":32,"path":["libc","unix","linux_like","linux","sockaddr_alg"],"kind":"struct"},"29:21:2657":{"crate_id":29,"path":["colorchoice","ColorChoice"],"kind":"enum"},"2:21107:3336":{"crate_id":2,"path":["core","core_simd","masks","sealed","Sealed"],"kind":"trait"},"32:7744:14197":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_data"],"kind":"union"},"20:4404:38957":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","GroupedValues"],"kind":"struct"},"32:6097:13535":{"crate_id":32,"path":["libc","unix","linux_like","linux","sctp_initmsg"],"kind":"struct"},"41:13735:20620":{"crate_id":41,"path":["object","pe","ImageAlphaRuntimeFunctionEntry"],"kind":"struct"},"17:12592:19856":{"crate_id":17,"path":["object","macho","Nlist32"],"kind":"struct"},"1:11331:3410":{"crate_id":1,"path":["std","sys_common","net","TcpStream"],"kind":"struct"},"32:9653:13704":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_cond_t"],"kind":"struct"},"32:1901:10950":{"crate_id":32,"path":["libc","unix","linux_like","tm"],"kind":"struct"},"1:3995:3434":{"crate_id":1,"path":["std","os","unix","fs","DirBuilderExt"],"kind":"trait"},"42:699:20667":{"crate_id":42,"path":["memchr","memmem","FinderBuilder"],"kind":"struct"},"1:9062:3340":{"crate_id":1,"path":["std","time","SystemTime"],"kind":"struct"},"37:215:15363":{"crate_id":37,"path":["rustc_demangle","TryDemangleError"],"kind":"struct"},"41:8365:16515":{"crate_id":41,"path":["object","common","SectionKind"],"kind":"enum"},"48:4771:22349":{"crate_id":48,"path":["linux_raw_sys","general","inodes_stat_t"],"kind":"struct"},"1:8748:3543":{"crate_id":1,"path":["std","process","ExitStatus"],"kind":"struct"},"32:7310:14181":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","termios"],"kind":"struct"},"2:39982:32730":{"crate_id":2,"path":["core","char","convert","CharErrorKind"],"kind":"enum"},"2:42683:145":{"crate_id":2,"path":["core","hash","sip","Hasher"],"kind":"struct"},"16:5402:15391":{"crate_id":16,"path":["gimli","endianity","BigEndian"],"kind":"struct"},"32:6140:13537":{"crate_id":32,"path":["libc","unix","linux_like","linux","sctp_sndinfo"],"kind":"struct"},"16:7652:198":{"crate_id":16,"path":["gimli","read","rnglists","Range"],"kind":"struct"},"41:10980:16546":{"crate_id":41,"path":["object","read","ObjectMap"],"kind":"struct"},"33:4538:39677":{"crate_id":33,"path":["rustix","process","prctl","PrctlMmMap"],"kind":"struct"},"41:13860:20628":{"crate_id":41,"path":["object","pe","ImageFunctionEntry"],"kind":"struct"},"41:9332:38733":{"crate_id":41,"path":["object","read","any","SymbolIteratorInternal"],"kind":"enum"},"1:10209:2652":{"crate_id":1,"path":["std","sys","unix","process","process_common","Command"],"kind":"struct"},"16:8090:16441":{"crate_id":16,"path":["gimli","read","unit","EntriesCursor"],"kind":"struct"},"40:3782:15477":{"crate_id":40,"path":["gimli","constants","DwSectV2"],"kind":"struct"},"1:6296:166":{"crate_id":1,"path":["std","sync","mutex","Mutex"],"kind":"struct"},"1:7697:25570":{"crate_id":1,"path":["std","error","private","Internal"],"kind":"struct"},"26:423:39352":{"crate_id":26,"path":["anstream","auto","StreamInner"],"kind":"enum"},"40:2764:15444":{"crate_id":40,"path":["gimli","common","DebugStrOffset"],"kind":"struct"},"2:42031:3562":{"crate_id":2,"path":["core","sync","exclusive","Exclusive"],"kind":"struct"},"6:123:9709":{"crate_id":6,"path":["libc","unix","fpos_t"],"kind":"enum"},"17:386:16511":{"crate_id":17,"path":["object","read","any","Segment"],"kind":"struct"},"2:44334:3767":{"crate_id":2,"path":["core","task","wake","RawWakerVTable"],"kind":"struct"},"17:9683:16594":{"crate_id":17,"path":["object","read","elf","segment","ElfSegment"],"kind":"struct"},"17:10635:16736":{"crate_id":17,"path":["object","read","pe","relocation","RelocationBlockIterator"],"kind":"struct"},"32:805:9708":{"crate_id":32,"path":["libc","unix","FILE"],"kind":"enum"},"34:4826:22331":{"crate_id":34,"path":["linux_raw_sys","general","vfs_ns_cap_data__bindgen_ty_1"],"kind":"struct"},"41:1787:16597":{"crate_id":41,"path":["object","read","elf","symbol","ElfSymbolIterator"],"kind":"struct"},"6:4486:13493":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_constant_effect"],"kind":"struct"},"32:8729:14613":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","mcontext_t"],"kind":"struct"},"2:42167:8848":{"crate_id":2,"path":["core","fmt","num","LowerHex"],"kind":"struct"},"2:47072:3689":{"crate_id":2,"path":["core","core_arch","simd","u8x64"],"kind":"struct"},"34:6421:22416":{"crate_id":34,"path":["linux_raw_sys","general","tcp_fastopen_client_fail"],"kind":"enum"},"6:5015:13548":{"crate_id":6,"path":["libc","unix","linux_like","linux","af_alg_iv"],"kind":"struct"},"40:5305:16328":{"crate_id":40,"path":["gimli","constants","DwOp"],"kind":"struct"},"41:13490:20603":{"crate_id":41,"path":["object","pe","ImageResourceDataEntry"],"kind":"struct"},"16:7411:16412":{"crate_id":16,"path":["gimli","read","op","Expression"],"kind":"struct"},"1:11913:13":{"crate_id":1,"path":["std","fn"],"kind":"primitive"},"1:3208:3383":{"crate_id":1,"path":["std","io","stdio","Stdout"],"kind":"struct"},"1:1062:3205":{"crate_id":1,"path":["std","collections","hash","map","OccupiedEntry"],"kind":"struct"},"2:42898:9399":{"crate_id":2,"path":["core","slice","sort","TimSortRun"],"kind":"struct"},"40:2742:15443":{"crate_id":40,"path":["gimli","common","DebugRngListsIndex"],"kind":"struct"},"16:7519:16420":{"crate_id":16,"path":["gimli","read","pubtypes","PubTypesEntryIter"],"kind":"struct"},"42:515:20673":{"crate_id":42,"path":["memchr","memmem","prefilter","PrefilterFn"],"kind":"struct"},"2:21114:3638":{"crate_id":2,"path":["core","core_simd","masks","MaskElement"],"kind":"trait"},"6:595:10041":{"crate_id":6,"path":["libc","unix","protoent"],"kind":"struct"},"1:7616:3146":{"crate_id":1,"path":["std","thread","Thread"],"kind":"struct"},"38:0:2491":{"crate_id":38,"path":["cfg_if"],"kind":"module"},"1:3383:3333":{"crate_id":1,"path":["std","io","Read"],"kind":"trait"},"2:2758:3622":{"crate_id":2,"path":["core","ops","arith","Sub"],"kind":"trait"},"40:6767:16397":{"crate_id":40,"path":["gimli","read","line","IncompleteLineProgram"],"kind":"struct"},"2:7161:9210":{"crate_id":2,"path":["core","iter","traits","accum","Sum"],"kind":"trait"},"33:4576:39630":{"crate_id":33,"path":["rustix","process","prctl","FloatingPointMode"],"kind":"enum"},"5:3158:3210":{"crate_id":5,"path":["alloc","collections","btree","set","Intersection"],"kind":"struct"},"11:2087:3206":{"crate_id":11,"path":["hashbrown","set","VacantEntry"],"kind":"struct"},"48:4615:22336":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_get_policy_ex_arg"],"kind":"struct"},"2:43357:3362":{"crate_id":2,"path":["core","str","iter","Split"],"kind":"struct"},"6:568:10037":{"crate_id":6,"path":["libc","unix","sigval"],"kind":"struct"},"11:2198:34676":{"crate_id":11,"path":["hashbrown","raw","bitmask","BitMask"],"kind":"struct"},"34:7864:22486":{"crate_id":34,"path":["linux_raw_sys","general","user_desc"],"kind":"struct"},"17:12915:20564":{"crate_id":17,"path":["object","pe","ImageDataDirectory"],"kind":"struct"},"1:5021:27421":{"crate_id":1,"path":["std","path","fmt","DebugHelper"],"kind":"struct"},"47:3193:20832":{"crate_id":47,"path":["rustix","backend","io","types","SpliceFlags"],"kind":"struct"},"34:7740:10944":{"crate_id":34,"path":["linux_raw_sys","general","sockaddr"],"kind":"struct"},"2:45968:3665":{"crate_id":2,"path":["core","core_arch","simd","i32x4"],"kind":"struct"},"2:12357:192":{"crate_id":2,"path":["core","future","pending","Pending"],"kind":"struct"},"6:4813:13526":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_filter"],"kind":"struct"},"1:5370:3538":{"crate_id":1,"path":["std","process","ChildStderr"],"kind":"struct"},"17:10649:16746":{"crate_id":17,"path":["object","read","pe","relocation","RelocationIterator"],"kind":"struct"},"41:12518:19847":{"crate_id":41,"path":["object","macho","DyldInfoCommand"],"kind":"struct"},"41:12691:19858":{"crate_id":41,"path":["object","macho","RelocationInfo"],"kind":"struct"},"34:7895:14180":{"crate_id":34,"path":["linux_raw_sys","general","cmsghdr"],"kind":"struct"},"41:13922:20633":{"crate_id":41,"path":["object","pe","ImportObjectHeader"],"kind":"struct"},"13:110:37644":{"crate_id":13,"path":["std_detect","detect","arch","x86","Feature"],"kind":"enum"},"5:1413:3193":{"crate_id":5,"path":["alloc","collections","btree","map","Values"],"kind":"struct"},"43:169:15325":{"crate_id":43,"path":["miniz_oxide","inflate","stream","FullReset"],"kind":"struct"},"41:11126:16552":{"crate_id":41,"path":["object","read","CompressionFormat"],"kind":"enum"},"20:4702:38954":{"crate_id":20,"path":["clap_builder","parser","validator","Conflicts"],"kind":"struct"},"11:652:3190":{"crate_id":11,"path":["hashbrown","map","IterMut"],"kind":"struct"},"41:11559:19312":{"crate_id":41,"path":["object","elf","ProgramHeader64"],"kind":"struct"},"2:4110:9014":{"crate_id":2,"path":["core","cell","lazy","LazyCell"],"kind":"struct"},"34:6042:13473":{"crate_id":34,"path":["linux_raw_sys","general","rlimit64"],"kind":"struct"},"1:11035:9426":{"crate_id":1,"path":["std","sys","unix","time","Nanoseconds"],"kind":"struct"},"17:10705:16749":{"crate_id":17,"path":["object","read","pe","resource","ResourceName"],"kind":"struct"},"34:6971:22438":{"crate_id":34,"path":["linux_raw_sys","general","uffdio_api"],"kind":"struct"},"17:9218:16534":{"crate_id":17,"path":["object","read","any","SymbolTable"],"kind":"struct"},"16:4540:15995":{"crate_id":16,"path":["gimli","constants","DwEnd"],"kind":"struct"},"41:13869:20629":{"crate_id":41,"path":["object","pe","ImageFunctionEntry64"],"kind":"struct"},"40:5920:16362":{"crate_id":40,"path":["gimli","read","cfi","UnwindContext"],"kind":"struct"},"48:5275:13534":{"crate_id":48,"path":["linux_raw_sys","general","in6_ifreq"],"kind":"struct"},"42:564:20676":{"crate_id":42,"path":["memchr","memmem","rarebytes","RareNeedleBytes"],"kind":"struct"},"32:5501:13507":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf32_Phdr"],"kind":"struct"},"40:535:37864":{"crate_id":40,"path":["gimli","read","cfi","RegisterRuleMap"],"kind":"struct"},"40:2546:15435":{"crate_id":40,"path":["gimli","common","LocationListsOffset"],"kind":"struct"},"2:43946:8946":{"crate_id":2,"path":["core","str","pattern","EmptyNeedle"],"kind":"struct"},"2:44389:34240":{"crate_id":2,"path":["core","escape","EscapeIterInner"],"kind":"struct"},"41:11166:16554":{"crate_id":41,"path":["object","read","CompressedData"],"kind":"struct"},"40:2404:15429":{"crate_id":40,"path":["gimli","common","DebugAddrBase"],"kind":"struct"},"40:6904:16403":{"crate_id":40,"path":["gimli","read","loclists","LocationLists"],"kind":"struct"},"2:45844:3705":{"crate_id":2,"path":["core","core_arch","simd","u64x2"],"kind":"struct"},"2:11737:8902":{"crate_id":2,"path":["core","str","pattern","DoubleEndedSearcher"],"kind":"trait"},"17:13101:20558":{"crate_id":17,"path":["object","pe","ImageSectionHeader"],"kind":"struct"},"1:585:3163":{"crate_id":1,"path":["std","ascii","AsciiExt"],"kind":"trait"},"1:10314:3542":{"crate_id":1,"path":["std","sys","unix","process","process_common","CommandArgs"],"kind":"struct"},"17:10026:16694":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCacheImageIterator"],"kind":"struct"},"20:3740:39040":{"crate_id":20,"path":["clap_builder","builder","command","MaxTermWidth"],"kind":"struct"},"16:6981:16406":{"crate_id":16,"path":["gimli","read","loclists","LocListIter"],"kind":"struct"},"17:9340:16537":{"crate_id":17,"path":["object","read","any","SectionRelocationIterator"],"kind":"struct"},"5:280:2682":{"crate_id":5,"path":["alloc","boxed","Box"],"kind":"struct"},"17:9670:16595":{"crate_id":17,"path":["object","read","elf","segment","ElfSegmentIterator"],"kind":"struct"},"2:46528:3654":{"crate_id":2,"path":["core","core_arch","simd","i8x32"],"kind":"struct"},"2:4007:33203":{"crate_id":2,"path":["core","asserting","TryCaptureWithDebug"],"kind":"struct"},"44:44:15331":{"crate_id":44,"path":["adler","Adler32"],"kind":"struct"},"1:1783:3253":{"crate_id":1,"path":["std","env","Vars"],"kind":"struct"},"2:1916:3233":{"crate_id":2,"path":["core","ptr","unique","Unique"],"kind":"struct"},"16:2642:15439":{"crate_id":16,"path":["gimli","common","DebugMacroOffset"],"kind":"struct"},"34:5593:13534":{"crate_id":34,"path":["linux_raw_sys","general","in6_ifreq"],"kind":"struct"},"48:6590:22434":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"42:96:20647":{"crate_id":42,"path":["memchr","memchr","iter","Memchr2"],"kind":"struct"},"41:10030:16619":{"crate_id":41,"path":["object","read","elf","version","VerneedIterator"],"kind":"struct"},"2:21665:32465":{"crate_id":2,"path":["core","num","bignum","Big32x40"],"kind":"struct"},"32:8353:9910":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock"],"kind":"struct"},"2:32060:9326":{"crate_id":2,"path":["core","error","Source"],"kind":"struct"},"18:671:20664":{"crate_id":18,"path":["memchr","memmem","FindRevIter"],"kind":"struct"},"1:4760:3439":{"crate_id":1,"path":["std","os","fd","owned","AsFd"],"kind":"trait"},"17:12282:19834":{"crate_id":17,"path":["object","macho","DylibReference"],"kind":"struct"},"32:9257:9986":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","not_x32","statvfs"],"kind":"struct"},"34:5059:22347":{"crate_id":34,"path":["linux_raw_sys","general","file_dedupe_range"],"kind":"struct"},"40:2967:15452":{"crate_id":40,"path":["gimli","common","SectionId"],"kind":"enum"},"6:5870:14184":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_hdr"],"kind":"struct"},"40:7077:16408":{"crate_id":40,"path":["gimli","read","op","DieReference"],"kind":"enum"},"17:10068:16695":{"crate_id":17,"path":["object","read","macho","file","MachOComdatIterator"],"kind":"struct"},"41:13251:20581":{"crate_id":41,"path":["object","pe","ImageAuxSymbolFunctionBeginEnd"],"kind":"struct"},"5:1213:3206":{"crate_id":5,"path":["alloc","collections","btree","map","entry","VacantEntry"],"kind":"struct"},"5:1228:3205":{"crate_id":5,"path":["alloc","collections","btree","map","entry","OccupiedEntry"],"kind":"struct"},"32:6160:13538":{"crate_id":32,"path":["libc","unix","linux_like","linux","sctp_rcvinfo"],"kind":"struct"},"1:6085:3768":{"crate_id":1,"path":["std","sync","mpmc","waker","Waker"],"kind":"struct"},"41:13226:20579":{"crate_id":41,"path":["object","pe","ImageAuxSymbolTokenDef"],"kind":"struct"},"34:5544:22372":{"crate_id":34,"path":["linux_raw_sys","general","in6_addr__bindgen_ty_1"],"kind":"union"},"40:8142:16444":{"crate_id":40,"path":["gimli","read","unit","EntriesTreeIter"],"kind":"struct"},"1:8838:3584":{"crate_id":1,"path":["std","sync","mpsc","TryRecvError"],"kind":"enum"},"6:6755:14612":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user"],"kind":"struct"},"32:5068:13486":{"crate_id":32,"path":["libc","unix","linux_like","linux","input_id"],"kind":"struct"},"20:3910:2967":{"crate_id":20,"path":["clap_builder","builder","styled_str","Styles"],"kind":"struct"},"34:6182:22403":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_6"],"kind":"struct"},"40:5963:16364":{"crate_id":40,"path":["gimli","read","cfi","RegisterRuleIter"],"kind":"struct"},"2:3169:8997":{"crate_id":2,"path":["core","ops","try_trait","NeverShortCircuit"],"kind":"struct"},"5:7255:8949":{"crate_id":5,"path":["alloc","string","FromUtf8Error"],"kind":"struct"},"17:11502:19312":{"crate_id":17,"path":["object","elf","ProgramHeader64"],"kind":"struct"},"41:19:16477":{"crate_id":41,"path":["object","endian","Endian"],"kind":"trait"},"6:4688:13511":{"crate_id":6,"path":["libc","unix","linux_like","linux","mntent"],"kind":"struct"},"33:3779:3335":{"crate_id":33,"path":["rustix","io","seek_from","SeekFrom"],"kind":"enum"},"2:39334:9281":{"crate_id":2,"path":["core","ops","try_trait","Yeet"],"kind":"struct"},"41:13139:20574":{"crate_id":41,"path":["object","pe","AnonObjectHeaderBigobj"],"kind":"struct"},"2:43173:8883":{"crate_id":2,"path":["core","slice","iter","ChunksExactMut"],"kind":"struct"},"1:7846:26516":{"crate_id":1,"path":["std","io","buffered","linewritershim","LineWriterShim"],"kind":"struct"},"41:9125:38755":{"crate_id":41,"path":["object","read","any","SegmentInternal"],"kind":"enum"},"2:44104:9407":{"crate_id":2,"path":["core","str","BytesIsNotEmpty"],"kind":"struct"},"34:6945:22435":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_3"],"kind":"struct"},"48:4567:10961":{"crate_id":48,"path":["linux_raw_sys","general","epoll_event"],"kind":"struct"},"41:12339:19834":{"crate_id":41,"path":["object","macho","DylibReference"],"kind":"struct"},"41:8845:16526":{"crate_id":41,"path":["object","endian","I16Bytes"],"kind":"struct"},"20:4381:20709":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","ValuesRef"],"kind":"struct"},"11:867:3203":{"crate_id":11,"path":["hashbrown","map","RawEntryBuilder"],"kind":"struct"},"32:663:10035":{"crate_id":32,"path":["libc","unix","winsize"],"kind":"struct"},"17:8521:16521":{"crate_id":17,"path":["object","common","FileFlags"],"kind":"enum"},"33:2928:20833":{"crate_id":33,"path":["rustix","backend","io","types","DupFlags"],"kind":"struct"},"17:10527:16742":{"crate_id":17,"path":["object","read","pe","export","ExportTarget"],"kind":"enum"},"2:43343:3361":{"crate_id":2,"path":["core","str","iter","Bytes"],"kind":"struct"},"34:6734:10035":{"crate_id":34,"path":["linux_raw_sys","general","winsize"],"kind":"struct"},"40:7016:37905":{"crate_id":40,"path":["gimli","read","lookup","DebugLookup"],"kind":"struct"},"41:11193:16756":{"crate_id":41,"path":["object","archive","Header"],"kind":"struct"},"18:624:38776":{"crate_id":18,"path":["memchr","memmem","twoway","SuffixOrdering"],"kind":"enum"},"6:6830:14618":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_fpregs_struct"],"kind":"struct"},"1:3135:26519":{"crate_id":1,"path":["std","io","stdio","StderrRaw"],"kind":"struct"},"2:40356:9234":{"crate_id":2,"path":["core","iter","adapters","intersperse","Intersperse"],"kind":"struct"},"48:5332:22383":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_3"],"kind":"enum"},"0:12:1848":{"crate_id":0,"path":["clap","_cookbook","find"],"kind":"module"},"16:5779:16358":{"crate_id":16,"path":["gimli","read","cfi","Augmentation"],"kind":"struct"},"32:7420:14184":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_hdr"],"kind":"struct"},"17:10092:16697":{"crate_id":17,"path":["object","read","macho","file","MachOComdatSectionIterator"],"kind":"struct"},"2:21854:32596":{"crate_id":2,"path":["core","num","diy_float","Fp"],"kind":"struct"},"48:6677:22444":{"crate_id":48,"path":["linux_raw_sys","general","uffdio_continue"],"kind":"struct"},"1:731:142":{"crate_id":1,"path":["std","collections","hash","map","HashMap"],"kind":"struct"},"17:10000:16692":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCache"],"kind":"struct"},"1:11912:1126":{"crate_id":1,"path":["std","reference"],"kind":"primitive"},"2:47402:3667":{"crate_id":2,"path":["core","core_arch","simd","i32x16"],"kind":"struct"},"16:2546:15435":{"crate_id":16,"path":["gimli","common","LocationListsOffset"],"kind":"struct"},"40:344:15406":{"crate_id":40,"path":["gimli","read","cfi","UnwindSection"],"kind":"trait"},"40:8170:16446":{"crate_id":40,"path":["gimli","read","unit","DebugTypesUnitHeadersIter"],"kind":"struct"},"2:40286:9219":{"crate_id":2,"path":["core","iter","adapters","cycle","Cycle"],"kind":"struct"},"34:6004:10088":{"crate_id":34,"path":["linux_raw_sys","general","timezone"],"kind":"struct"},"1:9028:167":{"crate_id":1,"path":["std","sync","mutex","MutexGuard"],"kind":"struct"},"34:5295:22360":{"crate_id":34,"path":["linux_raw_sys","general","group_req"],"kind":"struct"},"33:4493:39564":{"crate_id":33,"path":["rustix","process","prctl","VirtualMemoryMapAddress"],"kind":"enum"},"9:481:15222":{"crate_id":9,"path":["miniz_oxide","DataFormat"],"kind":"enum"},"20:4281:20682":{"crate_id":20,"path":["clap_builder","error","ErrorInner"],"kind":"struct"},"17:12388:19842":{"crate_id":17,"path":["object","macho","EncryptionInfoCommand32"],"kind":"struct"},"48:4975:22358":{"crate_id":48,"path":["linux_raw_sys","general","ip_msfilter__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"40:7478:16416":{"crate_id":40,"path":["gimli","read","pubnames","DebugPubNames"],"kind":"struct"},"2:20770:9293":{"crate_id":2,"path":["core","core_simd","elements","const_ptr","SimdConstPtr","from_exposed_addr"],"kind":"foreign_type"},"32:7212:14176":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","__exit_status"],"kind":"struct"},"32:5236:13495":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_condition_effect"],"kind":"struct"},"48:7148:22470":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_probe"],"kind":"struct"},"6:4920:13538":{"crate_id":6,"path":["libc","unix","linux_like","linux","sctp_rcvinfo"],"kind":"struct"},"11:1144:3207":{"crate_id":11,"path":["hashbrown","map","OccupiedError"],"kind":"struct"},"2:32147:9242":{"crate_id":2,"path":["core","marker","PhantomPinned"],"kind":"struct"},"2:2963:8834":{"crate_id":2,"path":["core","ops","generator","Generator"],"kind":"trait"},"40:3899:15522":{"crate_id":40,"path":["gimli","constants","DwChildren"],"kind":"struct"},"48:5904:14174":{"crate_id":48,"path":["linux_raw_sys","general","statx_timestamp"],"kind":"struct"},"32:6283:13547":{"crate_id":32,"path":["libc","unix","linux_like","linux","uinput_user_dev"],"kind":"struct"},"40:4445:15972":{"crate_id":40,"path":["gimli","constants","DwAte"],"kind":"struct"},"40:4728:16063":{"crate_id":40,"path":["gimli","constants","DwAddr"],"kind":"struct"},"42:690:20666":{"crate_id":42,"path":["memchr","memmem","FinderRev"],"kind":"struct"},"1:11895:1481":{"crate_id":1,"path":["std","tuple"],"kind":"primitive"},"1:9038:219":{"crate_id":1,"path":["std","sync","rwlock","RwLockWriteGuard"],"kind":"struct"},"37:202:8948":{"crate_id":37,"path":["rustc_demangle","v0","ParseError"],"kind":"enum"},"6:1668:10956":{"crate_id":6,"path":["libc","unix","linux_like","in6_rtmsg"],"kind":"struct"},"6:4641:13508":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Phdr"],"kind":"struct"},"2:40338:9224":{"crate_id":2,"path":["core","iter","adapters","fuse","Fuse"],"kind":"struct"},"2:47572:3673":{"crate_id":2,"path":["core","core_arch","simd","i64x8"],"kind":"struct"},"41:12415:19840":{"crate_id":41,"path":["object","macho","LinkeditDataCommand"],"kind":"struct"},"1:4578:29744":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt","st_ctime"],"kind":"foreign_type"},"5:680:231":{"crate_id":5,"path":["alloc","borrow","ToOwned"],"kind":"trait"},"6:5829:14142":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","mallinfo"],"kind":"struct"},"2:1747:32719":{"crate_id":2,"path":["core","ptr","metadata","PtrComponents"],"kind":"struct"},"2:22458:170":{"crate_id":2,"path":["core","num","nonzero","NonZeroI16"],"kind":"struct"},"40:6854:16400":{"crate_id":40,"path":["gimli","read","line","FileEntryFormat"],"kind":"struct"},"34:5956:22391":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_old_itimerval"],"kind":"struct"},"26:153:20755":{"crate_id":26,"path":["anstream","lockable","Lockable"],"kind":"trait"},"2:43778:8939":{"crate_id":2,"path":["core","str","pattern","MultiCharEqSearcher"],"kind":"struct"},"11:991:3204":{"crate_id":11,"path":["hashbrown","map","Entry"],"kind":"enum"},"40:5655:16352":{"crate_id":40,"path":["gimli","read","cfi","EhFrame"],"kind":"struct"},"47:4969:39535":{"crate_id":47,"path":["rustix","process","prctl","SpeculationFeatureState"],"kind":"struct"},"42:636:38770":{"crate_id":42,"path":["memchr","memmem","twoway","ApproximateByteSet"],"kind":"struct"},"6:4538:13499":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_ff_upload"],"kind":"struct"},"40:7437:16413":{"crate_id":40,"path":["gimli","read","op","OperationIter"],"kind":"struct"},"1:875:3192":{"crate_id":1,"path":["std","collections","hash","map","Keys"],"kind":"struct"},"9:234:3524":{"crate_id":9,"path":["miniz_oxide","inflate","core","State"],"kind":"enum"},"40:2668:15440":{"crate_id":40,"path":["gimli","common","RawRangeListsOffset"],"kind":"struct"},"14:202:8948":{"crate_id":14,"path":["rustc_demangle","v0","ParseError"],"kind":"enum"},"34:6448:22417":{"crate_id":34,"path":["linux_raw_sys","general","tcp_ca_state"],"kind":"enum"},"16:5594:16348":{"crate_id":16,"path":["gimli","read","cfi","EhFrameHdr"],"kind":"struct"},"40:7293:16410":{"crate_id":40,"path":["gimli","read","op","Piece"],"kind":"struct"},"20:3768:184":{"crate_id":20,"path":["clap_builder","builder","os_str","OsStr"],"kind":"struct"},"48:5314:22379":{"crate_id":48,"path":["linux_raw_sys","general","ipv6hdr"],"kind":"struct"},"48:6389:10035":{"crate_id":48,"path":["linux_raw_sys","general","winsize"],"kind":"struct"},"17:3266:16679":{"crate_id":17,"path":["object","read","macho","relocation","MachORelocationIterator"],"kind":"struct"},"1:8134:3360":{"crate_id":1,"path":["std","io","Take"],"kind":"struct"},"41:13820:20625":{"crate_id":41,"path":["object","pe","ImageDebugDirectory"],"kind":"struct"},"32:8435:3495":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat"],"kind":"struct"},"40:6022:16367":{"crate_id":40,"path":["gimli","read","cfi","RegisterRule"],"kind":"enum"},"2:41309:33742":{"crate_id":2,"path":["core","net","parser","AddrKind"],"kind":"enum"},"32:9559:13699":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_mutexattr_t"],"kind":"struct"},"2:2985:3247":{"crate_id":2,"path":["core","ops","index","IndexMut"],"kind":"trait"},"47:4725:39638":{"crate_id":47,"path":["rustix","process","prctl","MachineCheckMemoryCorruptionKillPolicy"],"kind":"enum"},"33:4716:39535":{"crate_id":33,"path":["rustix","process","prctl","SpeculationFeatureState"],"kind":"struct"},"1:6907:25776":{"crate_id":1,"path":["std","sys_common","lazy_box","LazyBox"],"kind":"struct"},"17:9986:16646":{"crate_id":17,"path":["object","read","elf","version","VernauxIterator"],"kind":"struct"},"1:10931:20748":{"crate_id":1,"path":["std","sys","unix","process","process_inner","do_exec","Reset"],"kind":"struct"},"18:0:2500":{"crate_id":18,"path":["memchr"],"kind":"module"},"1:2477:3371":{"crate_id":1,"path":["std","io","buffered","bufreader","BufReader"],"kind":"struct"},"1:6482:3570":{"crate_id":1,"path":["std","sync","poison","PoisonError"],"kind":"struct"},"25:382:20749":{"crate_id":25,"path":["anstyle","style","Style"],"kind":"struct"},"16:2764:15444":{"crate_id":16,"path":["gimli","common","DebugStrOffset"],"kind":"struct"},"17:13169:20579":{"crate_id":17,"path":["object","pe","ImageAuxSymbolTokenDef"],"kind":"struct"},"1:4436:3466":{"crate_id":1,"path":["std","os","unix","process","ExitStatusExt"],"kind":"trait"},"2:6721:32226":{"crate_id":2,"path":["core","iter","adapters","GenericShunt"],"kind":"struct"},"25:360:20748":{"crate_id":25,"path":["anstyle","reset","Reset"],"kind":"struct"},"41:12703:19859":{"crate_id":41,"path":["object","macho","ScatteredRelocationInfo"],"kind":"struct"},"40:7683:16429":{"crate_id":40,"path":["gimli","read","str","DebugStrOffsets"],"kind":"struct"},"34:6766:3451":{"crate_id":34,"path":["linux_raw_sys","general","sockaddr_un"],"kind":"struct"},"2:47695:8801":{"crate_id":2,"path":["core","core_arch","x86","__m256i"],"kind":"struct"},"9:325:15278":{"crate_id":9,"path":["miniz_oxide","inflate","core","LocalVars"],"kind":"struct"},"41:13192:20576":{"crate_id":41,"path":["object","pe","ImageSymbolBytes"],"kind":"struct"},"16:55:15392":{"crate_id":16,"path":["gimli","endianity","Endianity"],"kind":"trait"},"41:10057:16692":{"crate_id":41,"path":["object","read","macho","dyld_cache","DyldCache"],"kind":"struct"},"1:8260:3493":{"crate_id":1,"path":["std","os","linux","process","PidFd"],"kind":"struct"},"41:12251:19830":{"crate_id":41,"path":["object","macho","DysymtabCommand"],"kind":"struct"},"41:1217:16608":{"crate_id":41,"path":["object","read","elf","file","FileHeader"],"kind":"trait"},"32:7360:14143":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","mallinfo2"],"kind":"struct"},"11:665:3191":{"crate_id":11,"path":["hashbrown","map","IntoIter"],"kind":"struct"},"6:4991:13546":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_setup"],"kind":"struct"},"17:11434:19307":{"crate_id":17,"path":["object","elf","Rel32"],"kind":"struct"},"9:52:15242":{"crate_id":9,"path":["miniz_oxide","inflate","core","DecompressorOxide"],"kind":"struct"},"48:6497:22428":{"crate_id":48,"path":["linux_raw_sys","general","membarrier_cmd"],"kind":"enum"},"41:9407:38747":{"crate_id":41,"path":["object","read","any","SectionRelocationIteratorInternal"],"kind":"enum"},"6:1546:10945":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_in"],"kind":"struct"},"2:43265:8890":{"crate_id":2,"path":["core","slice","iter","RChunksExactMut"],"kind":"struct"},"2:41380:3405":{"crate_id":2,"path":["core","net","socket_addr","SocketAddrV6"],"kind":"struct"},"2:41530:193":{"crate_id":2,"path":["core","pin","Pin"],"kind":"struct"},"33:2488:20831":{"crate_id":33,"path":["rustix","backend","io","poll_fd","PollFlags"],"kind":"struct"},"41:3266:16679":{"crate_id":41,"path":["object","read","macho","relocation","MachORelocationIterator"],"kind":"struct"},"33:4107:39543":{"crate_id":33,"path":["rustix","process","prctl","UnalignedAccessControl"],"kind":"struct"},"6:1594:10950":{"crate_id":6,"path":["libc","unix","linux_like","tm"],"kind":"struct"},"2:39955:3165":{"crate_id":2,"path":["core","ascii","EscapeDefault"],"kind":"struct"},"41:11491:19307":{"crate_id":41,"path":["object","elf","Rel32"],"kind":"struct"},"1:10948:27091":{"crate_id":1,"path":["std","sys","unix","process","process_inner","posix_spawn","PosixSpawnattr"],"kind":"struct"},"2:5380:3347":{"crate_id":2,"path":["core","iter","adapters","filter","next_chunk","Guard"],"kind":"struct"},"34:6143:22399":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1"],"kind":"union"},"40:2337:15426":{"crate_id":40,"path":["gimli","common","LineEncoding"],"kind":"struct"},"48:6108:22417":{"crate_id":48,"path":["linux_raw_sys","general","tcp_ca_state"],"kind":"enum"},"5:4005:35280":{"crate_id":5,"path":["alloc","collections","vec_deque","drain","drop","DropGuard"],"kind":"struct"},"2:20536:9050":{"crate_id":2,"path":["core","core_simd","swizzle","reverse","Reverse"],"kind":"struct"},"2:2696:109":{"crate_id":2,"path":["core","marker","Copy"],"kind":"trait"},"6:7230:9986":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","not_x32","statvfs"],"kind":"struct"},"32:628:10033":{"crate_id":32,"path":["libc","unix","iovec"],"kind":"struct"},"1:8337:3523":{"crate_id":1,"path":["std","path","Prefix"],"kind":"enum"},"1:11837:25778":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","parse_running_mmaps","MapsEntry"],"kind":"struct"},"41:12679:16551":{"crate_id":41,"path":["object","macho","Relocation"],"kind":"struct"},"34:7904:3423":{"crate_id":34,"path":["linux_raw_sys","general","ucred"],"kind":"struct"},"1:9374:129":{"crate_id":1,"path":["std","sys","unix","fs","File"],"kind":"struct"},"41:11901:19808":{"crate_id":41,"path":["object","macho","MachHeader32"],"kind":"struct"},"17:487:16512":{"crate_id":17,"path":["object","read","any","Comdat"],"kind":"struct"},"17:9275:38733":{"crate_id":17,"path":["object","read","any","SymbolIteratorInternal"],"kind":"enum"},"1:8469:3527":{"crate_id":1,"path":["std","path","Components"],"kind":"struct"},"17:10626:16745":{"crate_id":17,"path":["object","read","pe","import","DelayLoadDescriptorIterator"],"kind":"struct"},"1:11072:24299":{"crate_id":1,"path":["std","sys","unix","time","Timespec"],"kind":"struct"},"24:247:15425":{"crate_id":24,"path":["unicase","Encoding"],"kind":"enum"},"20:2744:3189":{"crate_id":20,"path":["clap_builder","util","flat_map","Iter"],"kind":"struct"},"34:6199:22405":{"crate_id":34,"path":["linux_raw_sys","general","siginfo"],"kind":"struct"},"16:2694:15441":{"crate_id":16,"path":["gimli","common","RangeListsOffset"],"kind":"struct"},"2:45644:3664":{"crate_id":2,"path":["core","core_arch","simd","i32x2"],"kind":"struct"},"2:3197:8832":{"crate_id":2,"path":["core","ops","unsize","CoerceUnsized"],"kind":"trait"},"18:80:20646":{"crate_id":18,"path":["memchr","memchr","iter","Memchr"],"kind":"struct"},"1:11168:3549":{"crate_id":1,"path":["std","sys_common","process","CommandEnvs"],"kind":"struct"},"2:41289:32592":{"crate_id":2,"path":["core","net","ip_addr","fmt","Span"],"kind":"struct"},"2:21443:34654":{"crate_id":2,"path":["core","core_simd","vector","splat","Splat"],"kind":"struct"},"2:21771:32721":{"crate_id":2,"path":["core","num","dec2flt","common","BiasedFp"],"kind":"struct"},"2:11783:8931":{"crate_id":2,"path":["core","str","pattern","MultiCharEqPattern"],"kind":"struct"},"2:47770:8806":{"crate_id":2,"path":["core","core_arch","x86","__m512d"],"kind":"struct"},"17:8195:16496":{"crate_id":17,"path":["object","common","Architecture"],"kind":"enum"},"39:180:15372":{"crate_id":39,"path":["addr2line","LocationRangeIter"],"kind":"struct"},"41:8880:16527":{"crate_id":41,"path":["object","endian","I32Bytes"],"kind":"struct"},"34:4894:22334":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_key"],"kind":"struct"},"17:11813:16701":{"crate_id":17,"path":["object","macho","FatHeader"],"kind":"struct"},"1:8124:3359":{"crate_id":1,"path":["std","io","Chain"],"kind":"struct"},"2:2509:74":{"crate_id":2,"path":["core","convert","AsMut"],"kind":"trait"},"2:8356:8903":{"crate_id":2,"path":["core","panicking","assert_matches_failed","Pattern"],"kind":"struct"},"32:2157:10962":{"crate_id":32,"path":["libc","unix","linux_like","sockaddr_storage"],"kind":"struct"},"40:8156:16445":{"crate_id":40,"path":["gimli","read","unit","DebugTypes"],"kind":"struct"},"17:562:16513":{"crate_id":17,"path":["object","read","any","Symbol"],"kind":"struct"},"16:2879:15449":{"crate_id":16,"path":["gimli","common","DebugFrameOffset"],"kind":"struct"},"9:352:15239":{"crate_id":9,"path":["miniz_oxide","inflate","TINFLStatus"],"kind":"enum"},"2:41332:3412":{"crate_id":2,"path":["core","net","parser","AddrParseError"],"kind":"struct"},"42:644:38764":{"crate_id":42,"path":["memchr","memmem","x86","avx","nostd","Forward"],"kind":"struct"},"16:6293:16374":{"crate_id":16,"path":["gimli","read","reader","ReaderOffsetId"],"kind":"struct"},"6:4851:13531":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlattr"],"kind":"struct"},"48:4833:22356":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"47:2713:20864":{"crate_id":47,"path":["rustix","backend","io","epoll","EventFlags"],"kind":"struct"},"40:7244:37746":{"crate_id":40,"path":["gimli","read","op","OperationEvaluationResult"],"kind":"enum"},"41:10683:16745":{"crate_id":41,"path":["object","read","pe","import","DelayLoadDescriptorIterator"],"kind":"struct"},"41:10612:16707":{"crate_id":41,"path":["object","read","pe","export","ExportTable"],"kind":"struct"},"40:6662:16394":{"crate_id":40,"path":["gimli","read","line","LineInstructions"],"kind":"struct"},"16:7478:16416":{"crate_id":16,"path":["gimli","read","pubnames","DebugPubNames"],"kind":"struct"},"6:4803:13525":{"crate_id":6,"path":["libc","unix","linux_like","linux","j1939_filter"],"kind":"struct"},"16:8142:16444":{"crate_id":16,"path":["gimli","read","unit","EntriesTreeIter"],"kind":"struct"},"41:9634:16578":{"crate_id":41,"path":["object","read","coff","symbol","CoffSymbolTable"],"kind":"struct"},"1:676:3172":{"crate_id":1,"path":["std","backtrace","LazilyResolvedCapture"],"kind":"struct"},"20:3969:2981":{"crate_id":20,"path":["clap_builder","builder","value_parser","StringValueParser"],"kind":"struct"},"2:43084:33055":{"crate_id":2,"path":["core","slice","iter","GenericSplitN"],"kind":"struct"},"16:4480:15983":{"crate_id":16,"path":["gimli","constants","DwLle"],"kind":"struct"},"32:5130:13489":{"crate_id":32,"path":["libc","unix","linux_like","linux","input_mask"],"kind":"struct"},"34:5372:22365":{"crate_id":34,"path":["linux_raw_sys","general","iphdr__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"48:7097:22463":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_files_update"],"kind":"struct"},"6:6605:3495":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat"],"kind":"struct"},"2:11732:8904":{"crate_id":2,"path":["core","str","pattern","ReverseSearcher"],"kind":"trait"},"2:22293:176":{"crate_id":2,"path":["core","num","nonzero","NonZeroU32"],"kind":"struct"},"11:279:37581":{"crate_id":11,"path":["hashbrown","raw","RawIterRange"],"kind":"struct"},"34:6643:22420":{"crate_id":34,"path":["linux_raw_sys","general","tcp_md5sig"],"kind":"struct"},"41:10792:16751":{"crate_id":41,"path":["object","read","pe","rich","RichHeaderEntry"],"kind":"struct"},"33:3749:39590":{"crate_id":33,"path":["rustix","backend","time","types","TimerfdClockId"],"kind":"enum"},"0:16:1852":{"crate_id":0,"path":["clap","_cookbook","multicall_hostname"],"kind":"module"},"41:11528:19310":{"crate_id":41,"path":["object","elf","Rela64"],"kind":"struct"},"48:7387:10960":{"crate_id":48,"path":["linux_raw_sys","general","mmsghdr"],"kind":"struct"},"2:44100:9413":{"crate_id":2,"path":["core","str","IsNotEmpty"],"kind":"struct"},"41:13268:20582":{"crate_id":41,"path":["object","pe","ImageAuxSymbolWeak"],"kind":"struct"},"41:13216:20578":{"crate_id":41,"path":["object","pe","ImageSymbolExBytes"],"kind":"struct"},"2:9803:3336":{"crate_id":2,"path":["core","slice","index","private_slice_index","Sealed"],"kind":"trait"},"2:3182:35055":{"crate_id":2,"path":["core","ops","try_trait","NeverShortCircuitResidual"],"kind":"enum"},"32:6203:13540":{"crate_id":32,"path":["libc","unix","linux_like","linux","sctp_prinfo"],"kind":"struct"},"48:6431:22425":{"crate_id":48,"path":["linux_raw_sys","general","oldold_utsname"],"kind":"struct"},"31:183:20816":{"crate_id":31,"path":["io_lifetimes","views","FilelikeView"],"kind":"struct"},"41:9235:16533":{"crate_id":41,"path":["object","read","any","ComdatSectionIterator"],"kind":"struct"},"11:1852:3195":{"crate_id":11,"path":["hashbrown","set","DrainFilter"],"kind":"struct"},"17:11556:19316":{"crate_id":17,"path":["object","elf","Verdef"],"kind":"struct"},"16:5000:16119":{"crate_id":16,"path":["gimli","constants","DwLne"],"kind":"struct"},"2:21337:3645":{"crate_id":2,"path":["core","core_simd","ord","SimdOrd"],"kind":"trait"},"34:5251:10940":{"crate_id":34,"path":["linux_raw_sys","general","in_addr"],"kind":"struct"},"1:11493:15381":{"crate_id":1,"path":["std","backtrace_rs","backtrace","Frame"],"kind":"struct"},"1:11308:25278":{"crate_id":1,"path":["std","sys_common","net","LookupHost"],"kind":"struct"},"17:13121:20575":{"crate_id":17,"path":["object","pe","ImageSymbol"],"kind":"struct"},"17:13053:20572":{"crate_id":17,"path":["object","pe","AnonObjectHeader"],"kind":"struct"},"17:8931:16497":{"crate_id":17,"path":["object","read","util","ByteString"],"kind":"struct"},"41:9883:16590":{"crate_id":41,"path":["object","read","elf","comdat","ElfComdatIterator"],"kind":"struct"},"1:10226:25273":{"crate_id":1,"path":["std","sys","unix","process","process_common","Argv"],"kind":"struct"},"5:7136:3187":{"crate_id":5,"path":["alloc","collections","TryReserveError"],"kind":"struct"},"33:5159:39676":{"crate_id":33,"path":["rustix","process","wait","WaitStatus"],"kind":"struct"},"5:4914:3347":{"crate_id":5,"path":["alloc","rc","from_iter_exact","Guard"],"kind":"struct"},"17:12307:19836":{"crate_id":17,"path":["object","macho","TwolevelHint"],"kind":"struct"},"34:4966:22342":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_get_key_status_arg"],"kind":"struct"},"40:6351:16379":{"crate_id":40,"path":["gimli","read","abbrev","Attributes"],"kind":"enum"},"1:11892:312":{"crate_id":1,"path":["std","array"],"kind":"primitive"},"16:5305:16328":{"crate_id":16,"path":["gimli","constants","DwOp"],"kind":"struct"},"40:6179:16369":{"crate_id":40,"path":["gimli","read","dwarf","Dwarf"],"kind":"struct"},"42:0:2500":{"crate_id":42,"path":["memchr"],"kind":"module"},"40:7543:16422":{"crate_id":40,"path":["gimli","read","rnglists","DebugRngLists"],"kind":"struct"},"41:12633:19855":{"crate_id":41,"path":["object","macho","NoteCommand"],"kind":"struct"},"1:11195:24247":{"crate_id":1,"path":["std","sys_common","wtf8","CodePoint"],"kind":"struct"},"32:5339:13500":{"crate_id":32,"path":["libc","unix","linux_like","linux","uinput_ff_erase"],"kind":"struct"},"16:2572:15436":{"crate_id":16,"path":["gimli","common","DebugLocListsBase"],"kind":"struct"},"1:10682:3329":{"crate_id":1,"path":["std","sys","unix","fs","FileTimes"],"kind":"struct"},"17:9350:38747":{"crate_id":17,"path":["object","read","any","SectionRelocationIteratorInternal"],"kind":"enum"},"1:3615:3406":{"crate_id":1,"path":["std","net","socket_addr","ToSocketAddrs"],"kind":"trait"},"2:11265:9371":{"crate_id":2,"path":["core","slice","GetManyMutError"],"kind":"struct"},"6:1622:10953":{"crate_id":6,"path":["libc","unix","linux_like","lconv"],"kind":"struct"},"32:8777:14615":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","shmid_ds"],"kind":"struct"},"1:1931:653":{"crate_id":1,"path":["std","ffi"],"kind":"module"},"5:3753:3195":{"crate_id":5,"path":["alloc","collections","linked_list","DrainFilter"],"kind":"struct"},"2:2763:9262":{"crate_id":2,"path":["core","ops","arith","Mul"],"kind":"trait"},"48:4813:22353":{"crate_id":48,"path":["linux_raw_sys","general","robust_list_head"],"kind":"struct"},"16:4624:16007":{"crate_id":16,"path":["gimli","constants","DwVirtuality"],"kind":"struct"},"33:3413:39675":{"crate_id":33,"path":["rustix","backend","process","types","RawCpuSet"],"kind":"struct"},"11:1847:3194":{"crate_id":11,"path":["hashbrown","set","Drain"],"kind":"struct"},"40:7697:16430":{"crate_id":40,"path":["gimli","read","str","DebugLineStr"],"kind":"struct"},"1:922:3197":{"crate_id":1,"path":["std","collections","hash","map","IntoKeys"],"kind":"struct"},"32:9325:14990":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","align","sem_t"],"kind":"struct"},"40:2905:15450":{"crate_id":40,"path":["gimli","common","EhFrameOffset"],"kind":"struct"},"43:158:15322":{"crate_id":43,"path":["miniz_oxide","inflate","stream","ResetPolicy"],"kind":"trait"},"17:13249:20586":{"crate_id":17,"path":["object","pe","ImageLinenumber"],"kind":"struct"},"1:7257:24688":{"crate_id":1,"path":["std","panicking","Hook"],"kind":"enum"},"20:2961:39019":{"crate_id":20,"path":["clap_builder","builder","app_settings","AppSettings"],"kind":"enum"},"5:6990:3236":{"crate_id":5,"path":["alloc","alloc","Global"],"kind":"struct"},"17:11234:19296":{"crate_id":17,"path":["object","elf","FileHeader32"],"kind":"struct"},"5:1314:94":{"crate_id":5,"path":["alloc","collections","btree","map","BTreeMap"],"kind":"struct"},"20:3750:39079":{"crate_id":20,"path":["clap_builder","builder","ext","Extensions"],"kind":"struct"},"41:2187:16587":{"crate_id":41,"path":["object","read","elf","compression","CompressionHeader"],"kind":"trait"},"2:2926:2677":{"crate_id":2,"path":["core","ops","function","Fn"],"kind":"trait"},"17:11924:19813":{"crate_id":17,"path":["object","macho","SegmentCommand64"],"kind":"struct"},"17:13219:20583":{"crate_id":17,"path":["object","pe","ImageAuxSymbolSection"],"kind":"struct"},"6:5747:14174":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","statx_timestamp"],"kind":"struct"},"5:5235:8865":{"crate_id":5,"path":["alloc","slice","Concat"],"kind":"trait"},"20:1647:20694":{"crate_id":20,"path":["clap_builder","error","format","RichFormatter"],"kind":"struct"},"40:6506:16389":{"crate_id":40,"path":["gimli","read","index","UnitIndexSectionIterator"],"kind":"struct"},"41:4105:16509":{"crate_id":41,"path":["object","read","traits","ObjectSymbol"],"kind":"trait"},"1:10652:29725":{"crate_id":1,"path":["std","sys","unix","fs","StatxExtraFields"],"kind":"struct"},"41:2157:16588":{"crate_id":41,"path":["object","read","elf","dynamic","Dyn"],"kind":"trait"},"2:45543:3698":{"crate_id":2,"path":["core","core_arch","simd","u32x2"],"kind":"struct"},"47:4686:39635":{"crate_id":47,"path":["rustix","process","prctl","EndianMode"],"kind":"enum"},"2:8838:33680":{"crate_id":2,"path":["core","fmt","builders","PadAdapter"],"kind":"struct"},"49:28:24115":{"crate_id":49,"path":["unicode_width","UnicodeWidthStr"],"kind":"trait"},"40:6307:16375":{"crate_id":40,"path":["gimli","read","abbrev","DebugAbbrev"],"kind":"struct"},"16:8214:16448":{"crate_id":16,"path":["gimli","read","value","Value"],"kind":"enum"},"43:52:15242":{"crate_id":43,"path":["miniz_oxide","inflate","core","DecompressorOxide"],"kind":"struct"},"32:751:10040":{"crate_id":32,"path":["libc","unix","servent"],"kind":"struct"},"1:8925:25634":{"crate_id":1,"path":["std","sync","mpmc","error","SendTimeoutError"],"kind":"enum"},"17:11800:19807":{"crate_id":17,"path":["object","macho","DyldSubCacheInfo"],"kind":"struct"},"27:89:20773":{"crate_id":27,"path":["anstyle_parse","CharAccumulator"],"kind":"trait"},"1:7838:119":{"crate_id":1,"path":["std","fs","DirBuilder"],"kind":"struct"},"48:4628:22338":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_key_specifier"],"kind":"struct"},"1:11210:24305":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8Buf"],"kind":"struct"},"17:13803:20628":{"crate_id":17,"path":["object","pe","ImageFunctionEntry"],"kind":"struct"},"40:3446:15458":{"crate_id":40,"path":["gimli","arch","RiscV"],"kind":"struct"},"16:7697:16430":{"crate_id":16,"path":["gimli","read","str","DebugLineStr"],"kind":"struct"},"41:12063:19817":{"crate_id":41,"path":["object","macho","FvmlibCommand"],"kind":"struct"},"34:4842:9910":{"crate_id":34,"path":["linux_raw_sys","general","flock"],"kind":"struct"},"11:1873:3212":{"crate_id":11,"path":["hashbrown","set","SymmetricDifference"],"kind":"struct"},"34:5632:22379":{"crate_id":34,"path":["linux_raw_sys","general","ipv6hdr"],"kind":"struct"},"31:69:20795":{"crate_id":31,"path":["io_lifetimes","traits","FromFd"],"kind":"trait"},"1:3458:3334":{"crate_id":1,"path":["std","io","Seek"],"kind":"trait"},"34:4873:10961":{"crate_id":34,"path":["linux_raw_sys","general","epoll_event"],"kind":"struct"},"33:4433:39635":{"crate_id":33,"path":["rustix","process","prctl","EndianMode"],"kind":"enum"},"48:0:2639":{"crate_id":48,"path":["linux_raw_sys"],"kind":"module"},"34:6718:22423":{"crate_id":34,"path":["linux_raw_sys","general","ktermios"],"kind":"struct"},"5:5035:3561":{"crate_id":5,"path":["alloc","rc","Weak"],"kind":"struct"},"2:4332:9009":{"crate_id":2,"path":["core","cell","Ref"],"kind":"struct"},"34:7406:22461":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_10"],"kind":"enum"},"1:5563:3577":{"crate_id":1,"path":["std","sync","mpsc","Sender"],"kind":"struct"},"41:12429:19841":{"crate_id":41,"path":["object","macho","FilesetEntryCommand"],"kind":"struct"},"17:11410:19305":{"crate_id":17,"path":["object","elf","Syminfo32"],"kind":"struct"},"2:46189:32718":{"crate_id":2,"path":["core","core_arch","simd","m32x4"],"kind":"struct"},"6:5947:14188":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","regex_t"],"kind":"struct"},"1:2869:128":{"crate_id":1,"path":["std","io","error","Error"],"kind":"struct"},"2:22326:177":{"crate_id":2,"path":["core","num","nonzero","NonZeroU64"],"kind":"struct"},"31:19:20791":{"crate_id":31,"path":["io_lifetimes","portability","AsFilelike"],"kind":"trait"},"17:13499:20610":{"crate_id":17,"path":["object","pe","ImagePrologueDynamicRelocationHeader"],"kind":"struct"},"2:40246:3244":{"crate_id":2,"path":["core","iter","adapters","by_ref_sized","ByRefSized"],"kind":"struct"},"41:13510:20605":{"crate_id":41,"path":["object","pe","ImageDynamicRelocationTable"],"kind":"struct"},"21:0:1715":{"crate_id":21,"path":["once_cell"],"kind":"module"},"34:6219:10964":{"crate_id":34,"path":["linux_raw_sys","general","sigevent"],"kind":"struct"},"1:9184:2659":{"crate_id":1,"path":["std","sys","unix","args","Args"],"kind":"struct"},"2:41243:3401":{"crate_id":2,"path":["core","net","ip_addr","Ipv6Addr"],"kind":"struct"},"16:5557:16346":{"crate_id":16,"path":["gimli","read","addr","DebugAddr"],"kind":"struct"},"2:41368:3404":{"crate_id":2,"path":["core","net","socket_addr","SocketAddrV4"],"kind":"struct"},"1:888:3193":{"crate_id":1,"path":["std","collections","hash","map","Values"],"kind":"struct"},"16:6132:16368":{"crate_id":16,"path":["gimli","read","cfi","CallFrameInstructionIter"],"kind":"struct"},"2:4:1014":{"crate_id":2,"path":["core","panic"],"kind":"macro"},"17:11459:19309":{"crate_id":17,"path":["object","elf","Rel64"],"kind":"struct"},"17:13812:20629":{"crate_id":17,"path":["object","pe","ImageFunctionEntry64"],"kind":"struct"},"1:8854:3582":{"crate_id":1,"path":["std","sync","mpsc","RecvTimeoutError"],"kind":"enum"},"2:47800:8808":{"crate_id":2,"path":["core","core_arch","x86","__m256bh"],"kind":"struct"},"2:4141:9015":{"crate_id":2,"path":["core","cell","once","OnceCell"],"kind":"struct"},"32:6236:13542":{"crate_id":32,"path":["libc","unix","linux_like","linux","sockaddr_nl"],"kind":"struct"},"34:5964:22392":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_sock_timeval"],"kind":"struct"},"40:7065:37799":{"crate_id":40,"path":["gimli","read","lookup","PubStuffParser"],"kind":"struct"},"48:6932:22457":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_9"],"kind":"enum"},"34:4788:22327":{"crate_id":34,"path":["linux_raw_sys","general","__user_cap_data_struct"],"kind":"struct"},"48:7138:22469":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_probe_op"],"kind":"struct"},"20:4049:2970":{"crate_id":20,"path":["clap_builder","builder","value_parser","BoolValueParser"],"kind":"struct"},"17:9453:16564":{"crate_id":17,"path":["object","read","archive","MemberHeader"],"kind":"enum"},"48:6310:22421":{"crate_id":48,"path":["linux_raw_sys","general","tcp_diag_md5sig"],"kind":"struct"},"41:13899:20631":{"crate_id":41,"path":["object","pe","NonPagedDebugInfo"],"kind":"struct"},"27:96:20775":{"crate_id":27,"path":["anstyle_parse","VtUtf8Receiver"],"kind":"struct"},"36:364:27097":{"crate_id":36,"path":["backtrace","symbolize","gimli","mmap","Mmap"],"kind":"struct"},"41:10646:16744":{"crate_id":41,"path":["object","read","pe","import","ImportThunkList"],"kind":"struct"},"5:6578:8971":{"crate_id":5,"path":["alloc","vec","set_len_on_drop","SetLenOnDrop"],"kind":"struct"},"33:2229:20863":{"crate_id":33,"path":["rustix","backend","io","epoll","CreateFlags"],"kind":"struct"},"41:10199:16698":{"crate_id":41,"path":["object","read","macho","load_command","LoadCommandVariant"],"kind":"enum"},"40:6696:16395":{"crate_id":40,"path":["gimli","read","line","ColumnType"],"kind":"enum"},"33:3658:39536":{"crate_id":33,"path":["rustix","backend","time","types","TimerfdTimerFlags"],"kind":"struct"},"2:22491:171":{"crate_id":2,"path":["core","num","nonzero","NonZeroI32"],"kind":"struct"},"41:9466:16561":{"crate_id":41,"path":["object","read","archive","Members"],"kind":"enum"},"5:3276:3195":{"crate_id":5,"path":["alloc","collections","btree","set","DrainFilter"],"kind":"struct"},"2:40367:9226":{"crate_id":2,"path":["core","iter","adapters","map","Map"],"kind":"struct"},"48:6998:22461":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_10"],"kind":"enum"},"41:13778:20623":{"crate_id":41,"path":["object","pe","ImageEnclaveConfig64"],"kind":"struct"},"41:11630:19317":{"crate_id":41,"path":["object","elf","Verdaux"],"kind":"struct"},"2:2805:9271":{"crate_id":2,"path":["core","ops","bit","Not"],"kind":"trait"},"17:10465:16712":{"crate_id":17,"path":["object","read","pe","section","PeSegment"],"kind":"struct"},"40:6327:16377":{"crate_id":40,"path":["gimli","read","abbrev","Abbreviations"],"kind":"struct"},"34:7111:22453":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_7"],"kind":"enum"},"17:13376:20597":{"crate_id":17,"path":["object","pe","ImageBoundForwarderRef"],"kind":"struct"},"16:2337:15426":{"crate_id":16,"path":["gimli","common","LineEncoding"],"kind":"struct"},"33:2635:20834":{"crate_id":33,"path":["rustix","backend","io","types","FdFlags"],"kind":"struct"},"1:7798:3329":{"crate_id":1,"path":["std","fs","FileTimes"],"kind":"struct"},"17:9443:16563":{"crate_id":17,"path":["object","read","archive","ArchiveMemberIterator"],"kind":"struct"},"32:5459:13505":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf32_Sym"],"kind":"struct"},"2:9370:145":{"crate_id":2,"path":["core","hash","Hasher"],"kind":"trait"},"48:5070:22367":{"crate_id":48,"path":["linux_raw_sys","general","ip_auth_hdr"],"kind":"struct"},"2:9405:9060":{"crate_id":2,"path":["core","hash","BuildHasher"],"kind":"trait"},"1:1071:3206":{"crate_id":1,"path":["std","collections","hash","map","VacantEntry"],"kind":"struct"},"34:6330:22412":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_4"],"kind":"enum"},"0:14:1850":{"crate_id":0,"path":["clap","_cookbook","git_derive"],"kind":"module"},"43:164:15324":{"crate_id":43,"path":["miniz_oxide","inflate","stream","ZeroReset"],"kind":"struct"},"48:5990:22412":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_4"],"kind":"enum"},"2:40677:33067":{"crate_id":2,"path":["core","iter","sources","from_generator","FromGenerator"],"kind":"struct"},"1:3677:3410":{"crate_id":1,"path":["std","net","tcp","TcpStream"],"kind":"struct"},"5:2916:35168":{"crate_id":5,"path":["alloc","collections","btree","node","marker","ValMut"],"kind":"struct"},"40:7259:3508":{"crate_id":40,"path":["gimli","read","op","Location"],"kind":"enum"},"32:473:10025":{"crate_id":32,"path":["libc","unix","group"],"kind":"struct"},"2:2522:237":{"crate_id":2,"path":["core","convert","TryFrom"],"kind":"trait"},"2:42421:110":{"crate_id":2,"path":["core","fmt","rt","Count"],"kind":"enum"},"40:7042:37863":{"crate_id":40,"path":["gimli","read","lookup","PubStuffHeader"],"kind":"struct"},"16:3585:15459":{"crate_id":16,"path":["gimli","arch","X86"],"kind":"struct"},"48:5041:13517":{"crate_id":48,"path":["linux_raw_sys","general","inotify_event"],"kind":"struct"},"18:548:141":{"crate_id":18,"path":["memchr","memmem","rabinkarp","Hash"],"kind":"struct"},"41:9974:3061":{"crate_id":41,"path":["object","read","elf","version","Version"],"kind":"struct"},"2:21978:3420":{"crate_id":2,"path":["core","num","error","IntErrorKind"],"kind":"enum"},"34:7091:22451":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_5__bindgen_ty_1"],"kind":"struct"},"32:5428:13504":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf64_Ehdr"],"kind":"struct"},"16:7016:37905":{"crate_id":16,"path":["gimli","read","lookup","DebugLookup"],"kind":"struct"},"17:11422:19306":{"crate_id":17,"path":["object","elf","Syminfo64"],"kind":"struct"},"1:8082:3390":{"crate_id":1,"path":["std","io","util","Sink"],"kind":"struct"},"1:8091:3331":{"crate_id":1,"path":["std","io","IoSlice"],"kind":"struct"},"41:9910:16642":{"crate_id":41,"path":["object","read","elf","comdat","ElfComdatSectionIterator"],"kind":"struct"},"17:12113:19825":{"crate_id":17,"path":["object","macho","DylinkerCommand"],"kind":"struct"},"2:5468:3347":{"crate_id":2,"path":["core","iter","adapters","filter_map","next_chunk","Guard"],"kind":"struct"},"26:262:20766":{"crate_id":26,"path":["anstream","adapter","strip","StrippedBytes"],"kind":"struct"},"16:6218:16371":{"crate_id":16,"path":["gimli","read","dwarf","Unit"],"kind":"struct"},"48:4827:22355":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_sockaddr_storage__bindgen_ty_1"],"kind":"union"},"33:0:2638":{"crate_id":33,"path":["rustix"],"kind":"module"},"40:1633:15421":{"crate_id":40,"path":["gimli","read","op","EvaluationStorage"],"kind":"trait"},"40:6460:16386":{"crate_id":40,"path":["gimli","read","index","DebugCuIndex"],"kind":"struct"},"2:41462:3190":{"crate_id":2,"path":["core","option","IterMut"],"kind":"struct"},"32:7441:14185":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","rtentry"],"kind":"struct"},"48:5704:13473":{"crate_id":48,"path":["linux_raw_sys","general","rlimit64"],"kind":"struct"},"41:12620:19854":{"crate_id":41,"path":["object","macho","DataInCodeEntry"],"kind":"struct"},"1:5439:3539":{"crate_id":1,"path":["std","process","Stdio"],"kind":"struct"},"21:300:20719":{"crate_id":21,"path":["once_cell","race","OnceRef"],"kind":"struct"},"1:7665:3208":{"crate_id":1,"path":["std","collections","hash","map","RandomState"],"kind":"struct"},"1:4112:3458":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryData"],"kind":"enum"},"41:9085:16530":{"crate_id":41,"path":["object","read","any","SegmentIterator"],"kind":"struct"},"17:13469:20607":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation64"],"kind":"struct"},"1:5320:3535":{"crate_id":1,"path":["std","process","Child"],"kind":"struct"},"40:1280:15410":{"crate_id":40,"path":["gimli","read","line","LineProgram"],"kind":"trait"},"31:42:20803":{"crate_id":31,"path":["io_lifetimes","portability","IntoSocketlike"],"kind":"trait"},"17:10857:16543":{"crate_id":17,"path":["object","read","SymbolSection"],"kind":"enum"},"20:3758:39033":{"crate_id":20,"path":["clap_builder","builder","ext","BoxedExtension"],"kind":"struct"},"5:2087:35416":{"crate_id":5,"path":["alloc","collections","btree","merge_iter","MergeIterInner"],"kind":"struct"},"17:12959:20566":{"crate_id":17,"path":["object","pe","ImageRomOptionalHeader"],"kind":"struct"},"48:5696:10029":{"crate_id":48,"path":["linux_raw_sys","general","rlimit"],"kind":"struct"},"40:8256:16449":{"crate_id":40,"path":["gimli","read","StoreOnHeap"],"kind":"struct"},"25:305:33681":{"crate_id":25,"path":["anstyle","color","DisplayBuffer"],"kind":"struct"},"7:0:1543":{"crate_id":7,"path":["unwind"],"kind":"module"},"17:13461:20606":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation32"],"kind":"struct"},"48:6623:22438":{"crate_id":48,"path":["linux_raw_sys","general","uffdio_api"],"kind":"struct"},"1:6332:27447":{"crate_id":1,"path":["std","sync","mutex","fmt","LockedPlaceholder"],"kind":"struct"},"1:8154:3358":{"crate_id":1,"path":["std","io","Lines"],"kind":"struct"},"17:12622:16551":{"crate_id":17,"path":["object","macho","Relocation"],"kind":"struct"},"32:6116:13536":{"crate_id":32,"path":["libc","unix","linux_like","linux","sctp_sndrcvinfo"],"kind":"struct"},"1:8968:16409":{"crate_id":1,"path":["std","sync","mpmc","select","Operation"],"kind":"struct"},"33:2179:39689":{"crate_id":33,"path":["rustix","process","uname","Uname"],"kind":"struct"},"41:11448:19304":{"crate_id":41,"path":["object","elf","Sym64"],"kind":"struct"},"20:943:2964":{"crate_id":20,"path":["clap_builder","builder","resettable","IntoResettable"],"kind":"trait"},"43:481:15222":{"crate_id":43,"path":["miniz_oxide","DataFormat"],"kind":"enum"},"41:13708:20617":{"crate_id":41,"path":["object","pe","ImageArmRuntimeFunctionEntry"],"kind":"struct"},"0:13:1849":{"crate_id":0,"path":["clap","_cookbook","git"],"kind":"module"},"17:12293:19835":{"crate_id":17,"path":["object","macho","TwolevelHintsCommand"],"kind":"struct"},"2:21083:3336":{"crate_id":2,"path":["core","core_simd","masks","to_bitmask","sealed","Sealed"],"kind":"trait"},"40:3749:15468":{"crate_id":40,"path":["gimli","constants","DwSect"],"kind":"struct"},"2:41512:3509":{"crate_id":2,"path":["core","panic","panic_info","PanicInfo"],"kind":"struct"},"34:5380:22366":{"crate_id":34,"path":["linux_raw_sys","general","iphdr__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"1:11091:3587":{"crate_id":1,"path":["std","sys","unix","time","inner","Instant"],"kind":"struct"},"1:11911:1553":{"crate_id":1,"path":["std","usize"],"kind":"primitive"},"41:10914:16543":{"crate_id":41,"path":["object","read","SymbolSection"],"kind":"enum"},"1:9043:3587":{"crate_id":1,"path":["std","time","Instant"],"kind":"struct"},"5:1242:3207":{"crate_id":5,"path":["alloc","collections","btree","map","entry","OccupiedError"],"kind":"struct"},"41:2933:16656":{"crate_id":41,"path":["object","read","macho","section","MachOSectionIterator"],"kind":"struct"},"2:1733:9305":{"crate_id":2,"path":["core","ptr","metadata","Pointee"],"kind":"trait"},"17:12550:19853":{"crate_id":17,"path":["object","macho","SourceVersionCommand"],"kind":"struct"},"1:7590:3147":{"crate_id":1,"path":["std","thread","Builder"],"kind":"struct"},"2:3163:8998":{"crate_id":2,"path":["core","ops","try_trait","Residual"],"kind":"trait"},"32:2144:10961":{"crate_id":32,"path":["libc","unix","linux_like","epoll_event"],"kind":"struct"},"32:5320:13499":{"crate_id":32,"path":["libc","unix","linux_like","linux","uinput_ff_upload"],"kind":"struct"},"42:582:9050":{"crate_id":42,"path":["memchr","memmem","twoway","Reverse"],"kind":"struct"},"11:1866:3211":{"crate_id":11,"path":["hashbrown","set","Difference"],"kind":"struct"},"47:4668:39674":{"crate_id":47,"path":["rustix","process","prctl","TimingMethod"],"kind":"enum"},"48:5729:10076":{"crate_id":48,"path":["linux_raw_sys","general","sigaction"],"kind":"struct"},"41:8500:16519":{"crate_id":41,"path":["object","common","RelocationKind"],"kind":"enum"},"6:4941:13540":{"crate_id":6,"path":["libc","unix","linux_like","linux","sctp_prinfo"],"kind":"struct"},"46:0:2642":{"crate_id":46,"path":["terminal_size"],"kind":"module"},"6:7578:15178":{"crate_id":6,"path":["libc","unix","align","in6_addr"],"kind":"struct"},"2:41751:88":{"crate_id":2,"path":["core","sync","atomic","AtomicU16"],"kind":"struct"},"6:1650:10954":{"crate_id":6,"path":["libc","unix","linux_like","in_pktinfo"],"kind":"struct"},"2:45459:3657":{"crate_id":2,"path":["core","core_arch","simd","i16x2"],"kind":"struct"},"48:5748:10037":{"crate_id":48,"path":["linux_raw_sys","general","sigval"],"kind":"union"},"32:8393:14605":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","siginfo_t"],"kind":"struct"},"25:182:20741":{"crate_id":25,"path":["anstyle","color","Color"],"kind":"enum"},"32:9577:13700":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_rwlockattr_t"],"kind":"struct"},"1:8242:3464":{"crate_id":1,"path":["std","os","unix","ucred","UCred"],"kind":"struct"},"36:156:40041":{"crate_id":36,"path":["backtrace","lock","LockGuard"],"kind":"struct"},"40:5386:15393":{"crate_id":40,"path":["gimli","endianity","LittleEndian"],"kind":"struct"},"21:383:20722":{"crate_id":21,"path":["once_cell","race","OnceBool"],"kind":"struct"},"6:5843:14143":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","mallinfo2"],"kind":"struct"},"17:11861:19809":{"crate_id":17,"path":["object","macho","MachHeader64"],"kind":"struct"},"41:0:2499":{"crate_id":41,"path":["object"],"kind":"module"},"41:8630:16523":{"crate_id":41,"path":["object","common","SectionFlags"],"kind":"enum"},"34:6067:10076":{"crate_id":34,"path":["linux_raw_sys","general","sigaction"],"kind":"struct"},"41:9805:16534":{"crate_id":41,"path":["object","read","elf","symbol","SymbolTable"],"kind":"struct"},"17:11069:16552":{"crate_id":17,"path":["object","read","CompressionFormat"],"kind":"enum"},"2:43884:8943":{"crate_id":2,"path":["core","str","pattern","CharPredicateSearcher"],"kind":"struct"},"33:466:3189":{"crate_id":33,"path":["rustix","backend","io","epoll","Iter"],"kind":"struct"},"40:2808:15446":{"crate_id":40,"path":["gimli","common","DebugStrOffsetsIndex"],"kind":"struct"},"2:9592:34195":{"crate_id":2,"path":["core","slice","sort","merge","MergeHole"],"kind":"struct"},"6:5995:14193":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_entry"],"kind":"struct"},"1:638:3170":{"crate_id":1,"path":["std","backtrace","BacktraceSymbol"],"kind":"struct"},"41:10473:16738":{"crate_id":41,"path":["object","read","pe","file","PeComdatIterator"],"kind":"struct"},"41:9778:16593":{"crate_id":41,"path":["object","read","elf","section","ElfSectionIterator"],"kind":"struct"},"2:43327:8914":{"crate_id":2,"path":["core","str","iter","Chars"],"kind":"struct"},"19:0:1031":{"crate_id":19,"path":["panic_unwind"],"kind":"module"},"2:43301:8920":{"crate_id":2,"path":["core","str","error","Utf8Error"],"kind":"struct"},"16:6919:37679":{"crate_id":16,"path":["gimli","read","loclists","LocListsFormat"],"kind":"enum"},"2:9362:141":{"crate_id":2,"path":["core","hash","Hash"],"kind":"trait"},"17:975:16577":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbolIterator"],"kind":"struct"},"48:6035:22413":{"crate_id":48,"path":["linux_raw_sys","general","tcp_repair_opt"],"kind":"struct"},"10:44:15331":{"crate_id":10,"path":["adler","Adler32"],"kind":"struct"},"41:9535:16582":{"crate_id":41,"path":["object","read","coff","file","CoffCommon"],"kind":"struct"},"48:5580:22386":{"crate_id":48,"path":["linux_raw_sys","general","rand_pool_info"],"kind":"struct"},"6:4439:13487":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_absinfo"],"kind":"struct"},"2:44326:3766":{"crate_id":2,"path":["core","task","wake","RawWaker"],"kind":"struct"},"1:11243:26156":{"crate_id":1,"path":["std","sys_common","wtf8","EncodeWide"],"kind":"struct"},"2:46606:3660":{"crate_id":2,"path":["core","core_arch","simd","i16x16"],"kind":"struct"},"34:7340:22457":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_9"],"kind":"enum"},"40:3047:15454":{"crate_id":40,"path":["gimli","common","DwarfFileType"],"kind":"enum"},"17:13564:20613":{"crate_id":17,"path":["object","pe","ImageLoadConfigDirectory64"],"kind":"struct"},"17:8651:15393":{"crate_id":17,"path":["object","endian","LittleEndian"],"kind":"struct"},"34:7708:22480":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sync_cancel_reg"],"kind":"struct"},"16:6376:16381":{"crate_id":16,"path":["gimli","read","aranges","DebugAranges"],"kind":"struct"},"2:2847:9276":{"crate_id":2,"path":["core","ops","bit","BitXorAssign"],"kind":"trait"},"2:3157:135":{"crate_id":2,"path":["core","ops","try_trait","FromResidual"],"kind":"trait"},"2:39341:8984":{"crate_id":2,"path":["core","any","TypeId"],"kind":"struct"},"41:9322:16535":{"crate_id":41,"path":["object","read","any","SymbolIterator"],"kind":"struct"},"2:44096:9412":{"crate_id":2,"path":["core","str","IsAsciiWhitespace"],"kind":"struct"},"2:45592:3652":{"crate_id":2,"path":["core","core_arch","simd","i8x8"],"kind":"struct"},"6:6047:14197":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_data"],"kind":"union"},"1:917:3196":{"crate_id":1,"path":["std","collections","hash","map","ValuesMut"],"kind":"struct"},"2:43631:8910":{"crate_id":2,"path":["core","str","iter","SplitWhitespace"],"kind":"struct"},"41:8250:16496":{"crate_id":41,"path":["object","common","Architecture"],"kind":"enum"},"41:10003:16618":{"crate_id":41,"path":["object","read","elf","version","VerdefIterator"],"kind":"struct"},"32:4767:13473":{"crate_id":32,"path":["libc","unix","linux_like","linux","rlimit64"],"kind":"struct"},"17:13433:20603":{"crate_id":17,"path":["object","pe","ImageResourceDataEntry"],"kind":"struct"},"26:245:20765":{"crate_id":26,"path":["anstream","adapter","strip","StripStrIter"],"kind":"struct"},"17:11520:19313":{"crate_id":17,"path":["object","elf","Dyn32"],"kind":"struct"},"40:5571:16347":{"crate_id":40,"path":["gimli","read","cfi","DebugFrame"],"kind":"struct"},"16:4510:15989":{"crate_id":16,"path":["gimli","constants","DwDs"],"kind":"struct"},"3:0:443":{"crate_id":3,"path":["compiler_builtins"],"kind":"module"},"2:21827:3416":{"crate_id":2,"path":["core","num","dec2flt","ParseFloatError"],"kind":"struct"},"20:4062:2971":{"crate_id":20,"path":["clap_builder","builder","value_parser","BoolishValueParser"],"kind":"struct"},"1:11904:740":{"crate_id":1,"path":["std","i128"],"kind":"primitive"},"2:9151:8839":{"crate_id":2,"path":["core","fmt","Binary"],"kind":"trait"},"2:46716:3721":{"crate_id":2,"path":["core","core_arch","simd","f32x8"],"kind":"struct"},"2:39280:203":{"crate_id":2,"path":["core","ops","range","RangeToInclusive"],"kind":"struct"},"2:3995:33205":{"crate_id":2,"path":["core","asserting","TryCaptureWithoutDebug"],"kind":"struct"},"2:41470:3191":{"crate_id":2,"path":["core","option","IntoIter"],"kind":"struct"},"2:41871:83":{"crate_id":2,"path":["core","sync","atomic","AtomicI64"],"kind":"struct"},"15:180:15372":{"crate_id":15,"path":["addr2line","LocationRangeIter"],"kind":"struct"},"41:10497:16740":{"crate_id":41,"path":["object","read","pe","file","PeComdatSectionIterator"],"kind":"struct"},"2:3079:3248":{"crate_id":2,"path":["core","ops","range","RangeBounds"],"kind":"trait"},"6:4307:13475":{"crate_id":6,"path":["libc","unix","linux_like","linux","passwd"],"kind":"struct"},"6:4416:13484":{"crate_id":6,"path":["libc","unix","linux_like","linux","sembuf"],"kind":"struct"},"16:8180:16447":{"crate_id":16,"path":["gimli","read","value","ValueType"],"kind":"enum"},"34:5932:22388":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_itimerspec"],"kind":"struct"},"48:5835:22402":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3"],"kind":"struct"},"2:2898:117":{"crate_id":2,"path":["core","ops","deref","Deref"],"kind":"trait"},"20:3976:2976":{"crate_id":20,"path":["clap_builder","builder","value_parser","OsStringValueParser"],"kind":"struct"},"32:5928:13527":{"crate_id":32,"path":["libc","unix","linux_like","linux","sock_fprog"],"kind":"struct"},"16:7635:16427":{"crate_id":16,"path":["gimli","read","rnglists","RawRange"],"kind":"struct"},"34:5972:10028":{"crate_id":34,"path":["linux_raw_sys","general","timespec"],"kind":"struct"},"41:12142:19823":{"crate_id":41,"path":["object","macho","SubLibraryCommand"],"kind":"struct"},"2:47747:8805":{"crate_id":2,"path":["core","core_arch","x86","__m512"],"kind":"struct"},"16:3300:15457":{"crate_id":16,"path":["gimli","arch","LoongArch"],"kind":"struct"},"17:9557:16534":{"crate_id":17,"path":["object","read","coff","symbol","SymbolTable"],"kind":"struct"},"40:6201:16370":{"crate_id":40,"path":["gimli","read","dwarf","DwarfPackage"],"kind":"struct"},"1:10942:27092":{"crate_id":1,"path":["std","sys","unix","process","process_inner","posix_spawn","PosixSpawnFileActions"],"kind":"struct"},"1:4990:27421":{"crate_id":1,"path":["std","path","fmt","DebugHelper"],"kind":"struct"},"6:62:9654":{"crate_id":6,"path":["libc","unix","DIR"],"kind":"enum"},"21:51:3347":{"crate_id":21,"path":["once_cell","imp","Guard"],"kind":"struct"},"16:2448:15431":{"crate_id":16,"path":["gimli","common","DebugArangesOffset"],"kind":"struct"},"6:6821:14617":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ptrace_rseq_configuration"],"kind":"struct"},"17:12894:20562":{"crate_id":17,"path":["object","pe","MaskedRichHeaderEntry"],"kind":"struct"},"47:4829:39630":{"crate_id":47,"path":["rustix","process","prctl","FloatingPointMode"],"kind":"enum"},"33:3567:39541":{"crate_id":33,"path":["rustix","backend","time","types","TimerfdFlags"],"kind":"struct"},"48:5009:22362":{"crate_id":48,"path":["linux_raw_sys","general","group_filter__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"26:382:3524":{"crate_id":26,"path":["anstream","adapter","wincon","State"],"kind":"enum"},"2:43333:8913":{"crate_id":2,"path":["core","str","iter","CharIndices"],"kind":"struct"},"32:6078:1001":{"crate_id":32,"path":["libc","unix","linux_like","linux","option"],"kind":"struct"},"48:5049:22363":{"crate_id":48,"path":["linux_raw_sys","general","iphdr"],"kind":"struct"},"1:1821:3264":{"crate_id":1,"path":["std","env","SplitPaths"],"kind":"struct"},"24:223:20734":{"crate_id":24,"path":["unicase","UniCase"],"kind":"struct"},"48:7219:10036":{"crate_id":48,"path":["linux_raw_sys","general","linger"],"kind":"struct"},"34:6670:22422":{"crate_id":34,"path":["linux_raw_sys","general","tcp_zerocopy_receive"],"kind":"struct"},"6:1539:10944":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr"],"kind":"struct"},"17:11544:19315":{"crate_id":17,"path":["object","elf","Versym"],"kind":"struct"},"2:20549:34656":{"crate_id":2,"path":["core","core_simd","swizzle","rotate_lanes_left","Rotate"],"kind":"struct"},"1:11909:1495":{"crate_id":1,"path":["std","u128"],"kind":"primitive"},"1:8736:186":{"crate_id":1,"path":["std","process","Output"],"kind":"struct"},"15:219:15377":{"crate_id":15,"path":["addr2line","RangeAttributes"],"kind":"struct"},"2:41479:3508":{"crate_id":2,"path":["core","panic","location","Location"],"kind":"struct"},"5:6739:35296":{"crate_id":5,"path":["alloc","vec","retain_mut","BackshiftOnDrop"],"kind":"struct"},"26:0:2632":{"crate_id":26,"path":["anstream"],"kind":"module"},"2:2470:9054":{"crate_id":2,"path":["core","convert","num","FloatToInt"],"kind":"trait"},"2:47706:8802":{"crate_id":2,"path":["core","core_arch","x86","__m256"],"kind":"struct"},"20:4414:39081":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","Occurrences"],"kind":"struct"},"2:21966:3417":{"crate_id":2,"path":["core","num","error","ParseIntError"],"kind":"struct"},"6:4377:13480":{"crate_id":6,"path":["libc","unix","linux_like","linux","fsid_t"],"kind":"struct"},"17:13821:20630":{"crate_id":17,"path":["object","pe","ImageSeparateDebugHeader"],"kind":"struct"},"1:1048:3204":{"crate_id":1,"path":["std","collections","hash","map","Entry"],"kind":"enum"},"2:40684:3176":{"crate_id":2,"path":["core","iter","sources","once","Once"],"kind":"struct"},"23:28:3336":{"crate_id":23,"path":["clap_lex","ext","private","Sealed"],"kind":"trait"},"48:7174:22478":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_12"],"kind":"enum"},"6:6110:14225":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","sigset_t"],"kind":"struct"},"2:3152:234":{"crate_id":2,"path":["core","ops","try_trait","Try"],"kind":"trait"},"2:21004:3634":{"crate_id":2,"path":["core","core_simd","masks","mask_impl","Mask"],"kind":"struct"},"16:6164:37696":{"crate_id":16,"path":["gimli","read","cfi","PointerEncodingParameters"],"kind":"struct"},"1:8160:3408":{"crate_id":1,"path":["std","net","tcp","Incoming"],"kind":"struct"},"2:40408:9229":{"crate_id":2,"path":["core","iter","adapters","scan","Scan"],"kind":"struct"},"5:7241:224":{"crate_id":5,"path":["alloc","string","String"],"kind":"struct"},"2:2515:133":{"crate_id":2,"path":["core","convert","From"],"kind":"trait"},"24:205:33028":{"crate_id":24,"path":["unicase","unicode","fold","Fold"],"kind":"enum"},"34:4905:22335":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_policy_v2"],"kind":"struct"},"17:11372:19303":{"crate_id":17,"path":["object","elf","Sym32"],"kind":"struct"},"42:652:38764":{"crate_id":42,"path":["memchr","memmem","x86","sse","Forward"],"kind":"struct"},"1:11899:643":{"crate_id":1,"path":["std","f64"],"kind":"primitive"},"1:4681:3443":{"crate_id":1,"path":["std","os","fd","raw","FromRawFd"],"kind":"trait"},"41:12215:19828":{"crate_id":41,"path":["object","macho","RoutinesCommand64"],"kind":"struct"},"32:8751:14614":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ipc_perm"],"kind":"struct"},"17:10052:16674":{"crate_id":17,"path":["object","read","macho","file","MachOFile"],"kind":"struct"},"11:828:3200":{"crate_id":11,"path":["hashbrown","map","RawEntryMut"],"kind":"enum"},"41:11094:16550":{"crate_id":41,"path":["object","read","RelocationTarget"],"kind":"enum"},"6:4590:13504":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Ehdr"],"kind":"struct"},"1:11225:24296":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8"],"kind":"struct"},"1:11854:24645":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","Cache"],"kind":"struct"},"6:4960:13543":{"crate_id":6,"path":["libc","unix","linux_like","linux","dirent"],"kind":"struct"},"16:2720:15442":{"crate_id":16,"path":["gimli","common","DebugRngListsBase"],"kind":"struct"},"40:6336:16378":{"crate_id":40,"path":["gimli","read","abbrev","Abbreviation"],"kind":"struct"},"37:221:15364":{"crate_id":37,"path":["rustc_demangle","SizeLimitExhausted"],"kind":"struct"},"31:67:20796":{"crate_id":31,"path":["io_lifetimes","traits","IntoFd"],"kind":"trait"},"17:9322:38759":{"crate_id":17,"path":["object","read","any","DynamicRelocationIteratorInternal"],"kind":"enum"},"6:562:10036":{"crate_id":6,"path":["libc","unix","linger"],"kind":"struct"},"32:5218:13494":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_ramp_effect"],"kind":"struct"},"41:13314:20587":{"crate_id":41,"path":["object","pe","ImageBaseRelocation"],"kind":"struct"},"40:6544:16391":{"crate_id":40,"path":["gimli","read","line","DebugLine"],"kind":"struct"},"41:9614:16534":{"crate_id":41,"path":["object","read","coff","symbol","SymbolTable"],"kind":"struct"},"11:731:3192":{"crate_id":11,"path":["hashbrown","map","Keys"],"kind":"struct"},"16:2830:15447":{"crate_id":16,"path":["gimli","common","DebugTypesOffset"],"kind":"struct"},"2:40718:9205":{"crate_id":2,"path":["core","iter","sources","repeat_with","RepeatWith"],"kind":"struct"},"2:11535:8898":{"crate_id":2,"path":["core","str","iter","SplitInclusive"],"kind":"struct"},"41:4060:16508":{"crate_id":41,"path":["object","read","traits","ObjectSegment"],"kind":"trait"},"17:10691:16748":{"crate_id":17,"path":["object","read","pe","resource","ResourceDirectoryEntryData"],"kind":"enum"},"1:11910:789":{"crate_id":1,"path":["std","isize"],"kind":"primitive"},"17:9696:16579":{"crate_id":17,"path":["object","read","elf","section","SectionTable"],"kind":"struct"},"2:40693:9203":{"crate_id":2,"path":["core","iter","sources","once_with","OnceWith"],"kind":"struct"},"6:7258:14989":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","align","clone_args"],"kind":"struct"},"6:7544:13708":{"crate_id":6,"path":["libc","unix","linux_like","linux","can_frame"],"kind":"struct"},"34:7761:3495":{"crate_id":34,"path":["linux_raw_sys","general","stat"],"kind":"struct"},"32:7270:14179":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","msghdr"],"kind":"struct"},"32:5636:13512":{"crate_id":32,"path":["libc","unix","linux_like","linux","posix_spawn_file_actions_t"],"kind":"struct"},"32:1836:10947":{"crate_id":32,"path":["libc","unix","linux_like","addrinfo"],"kind":"struct"},"1:635:3169":{"crate_id":1,"path":["std","backtrace","BacktraceFrame"],"kind":"struct"},"5:7224:3288":{"crate_id":5,"path":["alloc","ffi","c_str","IntoStringError"],"kind":"struct"},"11:859:3202":{"crate_id":11,"path":["hashbrown","map","RawVacantEntryMut"],"kind":"struct"},"41:13110:20572":{"crate_id":41,"path":["object","pe","AnonObjectHeader"],"kind":"struct"},"34:4927:22337":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_get_policy_ex_arg__bindgen_ty_1"],"kind":"union"},"34:5948:22390":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_old_timespec"],"kind":"struct"},"47:466:24051":{"crate_id":47,"path":["rustix","backend","io","epoll","Borrowing"],"kind":"struct"},"1:8319:3504":{"crate_id":1,"path":["std","panic","BacktraceStyle"],"kind":"enum"},"6:119:9708":{"crate_id":6,"path":["libc","unix","FILE"],"kind":"enum"},"1:8479:3189":{"crate_id":1,"path":["std","path","Iter"],"kind":"struct"},"5:3117:3189":{"crate_id":5,"path":["alloc","collections","btree","set","Iter"],"kind":"struct"},"5:7321:3195":{"crate_id":5,"path":["alloc","vec","drain_filter","DrainFilter"],"kind":"struct"},"17:1919:16631":{"crate_id":17,"path":["object","read","elf","relocation","ElfRelaIterator"],"kind":"enum"},"2:6585:9211":{"crate_id":2,"path":["core","iter","adapters","zip","zip"],"kind":"function"},"40:8214:16448":{"crate_id":40,"path":["gimli","read","value","Value"],"kind":"enum"},"11:2076:3205":{"crate_id":11,"path":["hashbrown","set","OccupiedEntry"],"kind":"struct"},"1:4679:3440":{"crate_id":1,"path":["std","os","fd","raw","AsRawFd"],"kind":"trait"},"41:1919:16631":{"crate_id":41,"path":["object","read","elf","relocation","ElfRelaIterator"],"kind":"enum"},"41:11613:19316":{"crate_id":41,"path":["object","elf","Verdef"],"kind":"struct"},"48:6373:22423":{"crate_id":48,"path":["linux_raw_sys","general","ktermios"],"kind":"struct"},"1:8141:3361":{"crate_id":1,"path":["std","io","Bytes"],"kind":"struct"},"6:4875:13534":{"crate_id":6,"path":["libc","unix","linux_like","linux","in6_ifreq"],"kind":"struct"},"2:43407:8927":{"crate_id":2,"path":["core","str","iter","SplitTerminator"],"kind":"struct"},"2:40012:9037":{"crate_id":2,"path":["core","char","decode","DecodeUtf16"],"kind":"struct"},"1:4854:3491":{"crate_id":1,"path":["std","os","net","linux_ext","tcp","TcpStreamExt"],"kind":"trait"},"40:4818:16081":{"crate_id":40,"path":["gimli","constants","DwInl"],"kind":"struct"},"11:2204:37585":{"crate_id":11,"path":["hashbrown","raw","Fallibility"],"kind":"enum"},"41:9205:38748":{"crate_id":41,"path":["object","read","any","ComdatIteratorInternal"],"kind":"enum"},"11:821:3199":{"crate_id":11,"path":["hashbrown","map","RawEntryBuilderMut"],"kind":"struct"},"41:146:16484":{"crate_id":41,"path":["object","pod","Pod"],"kind":"trait"},"17:13453:20605":{"crate_id":17,"path":["object","pe","ImageDynamicRelocationTable"],"kind":"struct"},"40:897:15403":{"crate_id":40,"path":["gimli","read","reader","ReaderOffset"],"kind":"trait"},"5:1042:36412":{"crate_id":5,"path":["alloc","collections","btree","append","MergeIter"],"kind":"struct"},"41:10672:16735":{"crate_id":41,"path":["object","read","pe","import","DelayLoadImportTable"],"kind":"struct"},"2:39970:9036":{"crate_id":2,"path":["core","char","convert","ParseCharError"],"kind":"struct"},"34:7698:22479":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_getevents_arg"],"kind":"struct"},"41:13424:20596":{"crate_id":41,"path":["object","pe","ImageBoundImportDescriptor"],"kind":"struct"},"25:282:20744":{"crate_id":25,"path":["anstyle","color","RgbColor"],"kind":"struct"},"2:41521:9355":{"crate_id":2,"path":["core","panicking","AssertKind"],"kind":"enum"},"17:10270:16657":{"crate_id":17,"path":["object","read","macho","segment","MachOSegment"],"kind":"struct"},"16:5976:16365":{"crate_id":16,"path":["gimli","read","cfi","UnwindTableRow"],"kind":"struct"},"34:4834:22332":{"crate_id":34,"path":["linux_raw_sys","general","f_owner_ex"],"kind":"struct"},"48:6452:22426":{"crate_id":48,"path":["linux_raw_sys","general","old_utsname"],"kind":"struct"},"34:5258:10941":{"crate_id":34,"path":["linux_raw_sys","general","ip_mreq"],"kind":"struct"},"2:46652:3666":{"crate_id":2,"path":["core","core_arch","simd","i32x8"],"kind":"struct"},"34:5348:22363":{"crate_id":34,"path":["linux_raw_sys","general","iphdr"],"kind":"struct"},"1:9381:3328":{"crate_id":1,"path":["std","sys","unix","fs","ReadDir"],"kind":"struct"},"48:5642:10027":{"crate_id":48,"path":["linux_raw_sys","general","timeval"],"kind":"struct"},"41:10182:16673":{"crate_id":41,"path":["object","read","macho","load_command","LoadCommandData"],"kind":"struct"},"40:6474:16387":{"crate_id":40,"path":["gimli","read","index","DebugTuIndex"],"kind":"struct"},"16:3063:15455":{"crate_id":16,"path":["gimli","arch","Arm"],"kind":"struct"},"40:154:15402":{"crate_id":40,"path":["gimli","read","util","ArrayVec"],"kind":"struct"},"5:2407:35187":{"crate_id":5,"path":["alloc","collections","btree","node","NodeRef"],"kind":"struct"},"2:5528:9223":{"crate_id":2,"path":["core","iter","adapters","flatten","FlatMap"],"kind":"struct"},"48:5221:15178":{"crate_id":48,"path":["linux_raw_sys","general","in6_addr"],"kind":"struct"},"2:39161:9279":{"crate_id":2,"path":["core","ops","index_range","IndexRange"],"kind":"struct"},"48:5805:22399":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1"],"kind":"union"},"48:5865:22406":{"crate_id":48,"path":["linux_raw_sys","general","siginfo__bindgen_ty_1"],"kind":"union"},"14:187:15362":{"crate_id":14,"path":["rustc_demangle","SizeLimitedFmtAdapter"],"kind":"struct"},"6:541:10033":{"crate_id":6,"path":["libc","unix","iovec"],"kind":"struct"},"5:7005:3217":{"crate_id":5,"path":["alloc","collections","binary_heap","IntoIterSorted"],"kind":"struct"},"41:2651:16672":{"crate_id":41,"path":["object","read","macho","file","MachHeader"],"kind":"trait"},"41:9753:16579":{"crate_id":41,"path":["object","read","elf","section","SectionTable"],"kind":"struct"},"1:11870:23970":{"crate_id":1,"path":["std","backtrace_rs","print","PrintFmt"],"kind":"enum"},"1:10628:3494":{"crate_id":1,"path":["std","sys","unix","fd","FileDesc"],"kind":"struct"},"6:4344:13478":{"crate_id":6,"path":["libc","unix","linux_like","linux","signalfd_siginfo"],"kind":"struct"},"34:7526:22463":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_files_update"],"kind":"struct"},"6:6002:14194":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_exit"],"kind":"struct"},"18:538:20675":{"crate_id":18,"path":["memchr","memmem","rabinkarp","NeedleHash"],"kind":"struct"},"16:6351:16379":{"crate_id":16,"path":["gimli","read","abbrev","Attributes"],"kind":"enum"},"47:3671:39668":{"crate_id":47,"path":["rustix","backend","process","types","Signal"],"kind":"enum"},"33:3245:39580":{"crate_id":33,"path":["rustix","backend","process","types","Resource"],"kind":"enum"},"2:4260:9003":{"crate_id":2,"path":["core","cell","BorrowMutError"],"kind":"struct"},"17:1947:16591":{"crate_id":17,"path":["object","read","elf","relocation","ElfDynamicRelocationIterator"],"kind":"struct"},"40:6400:16383":{"crate_id":40,"path":["gimli","read","aranges","ArangeHeader"],"kind":"struct"},"17:11446:19308":{"crate_id":17,"path":["object","elf","Rela32"],"kind":"struct"},"16:535:37864":{"crate_id":16,"path":["gimli","read","cfi","RegisterRuleMap"],"kind":"struct"},"17:12483:19848":{"crate_id":17,"path":["object","macho","LinkerOptionCommand"],"kind":"struct"},"48:5269:22374":{"crate_id":48,"path":["linux_raw_sys","general","ip6_mtuinfo"],"kind":"struct"},"6:4527:13498":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_effect"],"kind":"struct"},"48:4651:22341":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_remove_key_arg"],"kind":"struct"},"2:9410:9061":{"crate_id":2,"path":["core","hash","BuildHasherDefault"],"kind":"struct"},"16:4596:16003":{"crate_id":16,"path":["gimli","constants","DwVis"],"kind":"struct"},"2:2827:9272":{"crate_id":2,"path":["core","ops","bit","Shl"],"kind":"trait"},"20:750:39241":{"crate_id":20,"path":["clap_builder","builder","ext","Extension"],"kind":"trait"},"2:9149:8840":{"crate_id":2,"path":["core","fmt","Octal"],"kind":"trait"},"2:9961:3189":{"crate_id":2,"path":["core","slice","iter","Iter"],"kind":"struct"},"31:132:20809":{"crate_id":31,"path":["io_lifetimes","raw","AsRawSocketlike"],"kind":"trait"},"32:5182:13492":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_envelope"],"kind":"struct"},"41:11778:19804":{"crate_id":41,"path":["object","macho","DyldCacheHeader"],"kind":"struct"},"40:4540:15995":{"crate_id":40,"path":["gimli","constants","DwEnd"],"kind":"struct"},"20:4456:39047":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","RawOccurrences"],"kind":"struct"},"2:12542:140":{"crate_id":2,"path":["core","alloc","global","GlobalAlloc"],"kind":"trait"},"1:4125:3459":{"crate_id":1,"path":["std","os","unix","net","ancillary","Messages"],"kind":"struct"},"1:7509:23969":{"crate_id":1,"path":["std","backtrace_rs","print","BacktraceFrameFmt"],"kind":"struct"},"41:9685:16570":{"crate_id":41,"path":["object","read","coff","comdat","CoffComdat"],"kind":"struct"},"1:3355:3347":{"crate_id":1,"path":["std","io","Guard"],"kind":"struct"},"17:11641:19322":{"crate_id":17,"path":["object","elf","HashHeader"],"kind":"struct"},"6:0:816":{"crate_id":6,"path":["libc"],"kind":"module"},"42:548:141":{"crate_id":42,"path":["memchr","memmem","rabinkarp","Hash"],"kind":"struct"},"32:1758:10943":{"crate_id":32,"path":["libc","unix","linux_like","ip_mreq_source"],"kind":"struct"},"2:39236:202":{"crate_id":2,"path":["core","ops","range","RangeTo"],"kind":"struct"},"2:21088:3630":{"crate_id":2,"path":["core","core_simd","masks","to_bitmask","ToBitMask"],"kind":"trait"},"40:3815:15486":{"crate_id":40,"path":["gimli","constants","DwUt"],"kind":"struct"},"5:783:3214":{"crate_id":5,"path":["alloc","collections","binary_heap","PeekMut"],"kind":"struct"},"20:4201:20693":{"crate_id":20,"path":["clap_builder","error","context","ContextValue"],"kind":"enum"},"17:13857:20632":{"crate_id":17,"path":["object","pe","ImageArchitectureEntry"],"kind":"struct"},"41:13401:20594":{"crate_id":41,"path":["object","pe","ImageTlsDirectory32"],"kind":"struct"},"40:2378:15428":{"crate_id":40,"path":["gimli","common","DebugAbbrevOffset"],"kind":"struct"},"41:13724:20619":{"crate_id":41,"path":["object","pe","ImageAlpha64RuntimeFunctionEntry"],"kind":"struct"},"2:30272:9254":{"crate_id":2,"path":["core","mem","transmutability","Assume"],"kind":"struct"},"2:45662:3670":{"crate_id":2,"path":["core","core_arch","simd","i64x1"],"kind":"struct"},"2:40324:32879":{"crate_id":2,"path":["core","iter","adapters","flatten","FlattenCompat"],"kind":"struct"},"41:11878:16699":{"crate_id":41,"path":["object","macho","FatArch32"],"kind":"struct"},"1:1561:3189":{"crate_id":1,"path":["std","collections","hash","set","Iter"],"kind":"struct"},"48:4988:24104":{"crate_id":48,"path":["linux_raw_sys","general","ip_msfilter__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"17:3142:16661":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbolIterator"],"kind":"struct"},"40:4789:16076":{"crate_id":40,"path":["gimli","constants","DwCc"],"kind":"struct"},"2:41345:3403":{"crate_id":2,"path":["core","net","socket_addr","SocketAddr"],"kind":"enum"},"2:21900:32619":{"crate_id":2,"path":["core","num","flt2dec","Sign"],"kind":"enum"},"32:6361:13555":{"crate_id":32,"path":["libc","unix","linux_like","linux","sockaddr_can"],"kind":"struct"},"17:12576:19855":{"crate_id":17,"path":["object","macho","NoteCommand"],"kind":"struct"},"1:3465:3356":{"crate_id":1,"path":["std","io","BufRead"],"kind":"trait"},"11:1524:15346":{"crate_id":11,"path":["hashbrown","rustc_entry","RustcEntry"],"kind":"enum"},"16:4327:15902":{"crate_id":16,"path":["gimli","constants","DwAt"],"kind":"struct"},"41:10327:16657":{"crate_id":41,"path":["object","read","macho","segment","MachOSegment"],"kind":"struct"},"5:2908:35169":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Immut"],"kind":"struct"},"17:11391:19304":{"crate_id":17,"path":["object","elf","Sym64"],"kind":"struct"},"41:12579:19851":{"crate_id":41,"path":["object","macho","FvmfileCommand"],"kind":"struct"},"17:13791:20627":{"crate_id":17,"path":["object","pe","ImageDebugMisc"],"kind":"struct"},"1:7791:3325":{"crate_id":1,"path":["std","fs","OpenOptions"],"kind":"struct"},"2:21:681":{"crate_id":2,"path":["core","format_args"],"kind":"macro"},"16:4400:15951":{"crate_id":16,"path":["gimli","constants","DwForm"],"kind":"struct"},"32:645:10034":{"crate_id":32,"path":["libc","unix","pollfd"],"kind":"struct"},"41:2234:16599":{"crate_id":41,"path":["object","read","elf","note","NoteHeader"],"kind":"trait"},"27:304:20778":{"crate_id":27,"path":["anstyle_parse","Utf8Parser"],"kind":"struct"},"31:47:20800":{"crate_id":31,"path":["io_lifetimes","portability","FromFilelike"],"kind":"trait"},"30:0:2636":{"crate_id":30,"path":["is_terminal"],"kind":"module"},"2:40315:9222":{"crate_id":2,"path":["core","iter","adapters","filter_map","FilterMap"],"kind":"struct"},"6:4478:13492":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_envelope"],"kind":"struct"},"41:247:38730":{"crate_id":41,"path":["object","read","util","DebugLen"],"kind":"struct"},"17:11037:16550":{"crate_id":17,"path":["object","read","RelocationTarget"],"kind":"enum"},"2:39258:201":{"crate_id":2,"path":["core","ops","range","RangeInclusive"],"kind":"struct"},"34:6034:10029":{"crate_id":34,"path":["linux_raw_sys","general","rlimit"],"kind":"struct"},"34:4719:22323":{"crate_id":34,"path":["linux_raw_sys","general","__BindgenBitfieldUnit"],"kind":"struct"},"5:3184:3213":{"crate_id":5,"path":["alloc","collections","btree","set","Union"],"kind":"struct"},"48:7076:22462":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_11"],"kind":"enum"},"14:221:15364":{"crate_id":14,"path":["rustc_demangle","SizeLimitExhausted"],"kind":"struct"},"1:1433:144":{"crate_id":1,"path":["std","collections","hash","set","HashSet"],"kind":"struct"},"1:7572:3162":{"crate_id":1,"path":["std","thread","local","AccessError"],"kind":"struct"},"36:661:3170":{"crate_id":36,"path":["backtrace","capture","BacktraceSymbol"],"kind":"struct"},"48:5029:10945":{"crate_id":48,"path":["linux_raw_sys","general","sockaddr_in"],"kind":"struct"},"48:5781:22396":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_3"],"kind":"struct"},"43:325:15278":{"crate_id":43,"path":["miniz_oxide","inflate","core","LocalVars"],"kind":"struct"},"47:3933:39541":{"crate_id":47,"path":["rustix","backend","time","types","TimerfdFlags"],"kind":"struct"},"41:8988:16497":{"crate_id":41,"path":["object","read","util","ByteString"],"kind":"struct"},"16:5655:16352":{"crate_id":16,"path":["gimli","read","cfi","EhFrame"],"kind":"struct"},"2:3317:69":{"crate_id":2,"path":["core","any","Any"],"kind":"trait"},"17:11532:19314":{"crate_id":17,"path":["object","elf","Dyn64"],"kind":"struct"},"16:6990:16407":{"crate_id":16,"path":["gimli","read","loclists","LocationListEntry"],"kind":"struct"},"48:4822:22354":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_sockaddr_storage"],"kind":"struct"},"6:6578:14604":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock64"],"kind":"struct"},"2:9526:9382":{"crate_id":2,"path":["core","slice","sort","InsertionHole"],"kind":"struct"},"40:6488:16388":{"crate_id":40,"path":["gimli","read","index","UnitIndex"],"kind":"struct"},"34:203:20891":{"crate_id":34,"path":["linux_raw_sys","general","__BindgenUnionField"],"kind":"struct"},"30:5:3368":{"crate_id":30,"path":["is_terminal","IsTerminal"],"kind":"trait"},"48:6413:10033":{"crate_id":48,"path":["linux_raw_sys","general","iovec"],"kind":"struct"},"32:6306:13549":{"crate_id":32,"path":["libc","unix","linux_like","linux","mq_attr"],"kind":"struct"},"20:1640:20690":{"crate_id":20,"path":["clap_builder","error","format","ErrorFormatter"],"kind":"trait"},"31:152:20813":{"crate_id":31,"path":["io_lifetimes","raw","FromRawSocketlike"],"kind":"trait"},"40:7757:16433":{"crate_id":40,"path":["gimli","read","unit","DebugInfoUnitHeadersIter"],"kind":"struct"},"41:13476:20601":{"crate_id":41,"path":["object","pe","ImageResourceDirectoryString"],"kind":"struct"},"25:347:20747":{"crate_id":25,"path":["anstyle","effect","EffectIndexIter"],"kind":"struct"},"1:11901:742":{"crate_id":1,"path":["std","i16"],"kind":"primitive"},"2:40022:9038":{"crate_id":2,"path":["core","char","decode","DecodeUtf16Error"],"kind":"struct"},"17:10440:16740":{"crate_id":17,"path":["object","read","pe","file","PeComdatSectionIterator"],"kind":"struct"},"6:1728:10962":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_storage"],"kind":"struct"},"5:7081:3191":{"crate_id":5,"path":["alloc","collections","linked_list","IntoIter"],"kind":"struct"},"2:43255:8889":{"crate_id":2,"path":["core","slice","iter","RChunksExact"],"kind":"struct"},"26:366:39348":{"crate_id":26,"path":["anstream","adapter","wincon","WinconCapture"],"kind":"struct"},"40:2642:15439":{"crate_id":40,"path":["gimli","common","DebugMacroOffset"],"kind":"struct"},"41:8775:16500":{"crate_id":41,"path":["object","endian","U32Bytes"],"kind":"struct"},"16:3815:15486":{"crate_id":16,"path":["gimli","constants","DwUt"],"kind":"struct"},"42:538:20675":{"crate_id":42,"path":["memchr","memmem","rabinkarp","NeedleHash"],"kind":"struct"},"17:9188:38746":{"crate_id":17,"path":["object","read","any","ComdatSectionIteratorInternal"],"kind":"enum"},"32:9722:15178":{"crate_id":32,"path":["libc","unix","align","in6_addr"],"kind":"struct"},"6:6057:14198":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","utmpx"],"kind":"struct"},"41:12364:19836":{"crate_id":41,"path":["object","macho","TwolevelHint"],"kind":"struct"},"0:11:1847":{"crate_id":0,"path":["clap","_cookbook","escaped_positional_derive"],"kind":"module"},"17:12138:19827":{"crate_id":17,"path":["object","macho","RoutinesCommand32"],"kind":"struct"},"17:1787:16597":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbolIterator"],"kind":"struct"},"34:5587:22374":{"crate_id":34,"path":["linux_raw_sys","general","ip6_mtuinfo"],"kind":"struct"},"40:4845:16084":{"crate_id":40,"path":["gimli","constants","DwOrd"],"kind":"struct"},"32:7542:14188":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","regex_t"],"kind":"struct"},"2:12308:151":{"crate_id":2,"path":["core","future","into_future","IntoFuture"],"kind":"trait"},"2:43525:8923":{"crate_id":2,"path":["core","str","iter","RMatchIndices"],"kind":"struct"},"34:4762:20890":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_fd_set"],"kind":"struct"},"6:6628:10907":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat64"],"kind":"struct"},"32:7119:14114":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","statx"],"kind":"struct"},"6:4553:13501":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_abs_setup"],"kind":"struct"},"2:20729:3639":{"crate_id":2,"path":["core","core_simd","cast","SimdCast"],"kind":"trait"},"6:4383:13481":{"crate_id":6,"path":["libc","unix","linux_like","linux","packet_mreq"],"kind":"struct"},"34:4864:15177":{"crate_id":34,"path":["linux_raw_sys","general","open_how"],"kind":"struct"},"41:13801:20624":{"crate_id":41,"path":["object","pe","ImageEnclaveImport"],"kind":"struct"},"17:9895:16616":{"crate_id":17,"path":["object","read","elf","hash","GnuHashTable"],"kind":"struct"},"1:8792:3586":{"crate_id":1,"path":["std","sync","mpsc","TryIter"],"kind":"struct"},"21:339:20723":{"crate_id":21,"path":["once_cell","race","once_box","OnceBox"],"kind":"struct"},"20:3326:2654":{"crate_id":20,"path":["clap_builder","builder","arg","Arg"],"kind":"struct"},"48:7157:22471":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_restriction"],"kind":"struct"},"48:4645:22340":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_provisioning_key_payload"],"kind":"struct"},"32:6039:13533":{"crate_id":32,"path":["libc","unix","linux_like","linux","__c_anonymous_ifru_map"],"kind":"struct"},"25:113:39334":{"crate_id":25,"path":["anstyle","effect","EffectsDisplay"],"kind":"struct"},"17:11471:19310":{"crate_id":17,"path":["object","elf","Rela64"],"kind":"struct"},"31:56:20801":{"crate_id":31,"path":["io_lifetimes","portability","FromSocketlike"],"kind":"trait"},"17:10743:16538":{"crate_id":17,"path":["object","read","traits","NoDynamicRelocationIterator"],"kind":"struct"},"34:5301:22361":{"crate_id":34,"path":["linux_raw_sys","general","group_source_req"],"kind":"struct"},"6:7443:15149":{"crate_id":6,"path":["libc","unix","linux_like","linux","arch","generic","termios2"],"kind":"struct"},"31:147:20812":{"crate_id":31,"path":["io_lifetimes","raw","FromRawFilelike"],"kind":"trait"},"6:1532:10943":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreq_source"],"kind":"struct"},"17:1978:16615":{"crate_id":17,"path":["object","read","elf","relocation","ElfSectionRelocationIterator"],"kind":"struct"},"2:42917:8874":{"crate_id":2,"path":["core","slice","ascii","EscapeAscii"],"kind":"struct"},"48:4528:22332":{"crate_id":48,"path":["linux_raw_sys","general","f_owner_ex"],"kind":"struct"},"1:11898:642":{"crate_id":1,"path":["std","f32"],"kind":"primitive"},"1:4683:3444":{"crate_id":1,"path":["std","os","fd","raw","IntoRawFd"],"kind":"trait"},"17:10491:16710":{"crate_id":17,"path":["object","read","pe","section","PeSection"],"kind":"struct"},"2:41260:3402":{"crate_id":2,"path":["core","net","ip_addr","Ipv6MulticastScope"],"kind":"enum"},"6:7538:13707":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_barrier_t"],"kind":"struct"},"48:7227:22483":{"crate_id":48,"path":["linux_raw_sys","general","linux_dirent64"],"kind":"struct"},"48:4501:22324":{"crate_id":48,"path":["linux_raw_sys","general","__IncompleteArrayField"],"kind":"struct"},"5:2912:35167":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Mut"],"kind":"struct"},"17:9566:16535":{"crate_id":17,"path":["object","read","coff","symbol","SymbolIterator"],"kind":"struct"},"16:5677:16353":{"crate_id":16,"path":["gimli","read","cfi","CieOffsetEncoding"],"kind":"enum"},"17:9933:16620":{"crate_id":17,"path":["object","read","elf","version","VersionTable"],"kind":"struct"},"14:7:15354":{"crate_id":14,"path":["rustc_demangle","legacy","Demangle"],"kind":"struct"},"40:2572:15436":{"crate_id":40,"path":["gimli","common","DebugLocListsBase"],"kind":"struct"},"41:9727:16595":{"crate_id":41,"path":["object","read","elf","segment","ElfSegmentIterator"],"kind":"struct"},"41:13349:20589":{"crate_id":41,"path":["object","pe","ImageExportDirectory"],"kind":"struct"},"20:4742:39083":{"crate_id":20,"path":["clap_builder","mkeymap","KeyType"],"kind":"enum"},"40:5677:16353":{"crate_id":40,"path":["gimli","read","cfi","CieOffsetEncoding"],"kind":"enum"},"0:15:1851":{"crate_id":0,"path":["clap","_cookbook","multicall_busybox"],"kind":"module"},"34:5600:22375":{"crate_id":34,"path":["linux_raw_sys","general","ipv6_rt_hdr"],"kind":"struct"},"16:6506:16389":{"crate_id":16,"path":["gimli","read","index","UnitIndexSectionIterator"],"kind":"struct"},"2:46111:32749":{"crate_id":2,"path":["core","core_arch","simd","m8x16"],"kind":"struct"},"40:2616:15438":{"crate_id":40,"path":["gimli","common","DebugMacinfoOffset"],"kind":"struct"},"17:13024:20569":{"crate_id":17,"path":["object","pe","ImageNtHeaders32"],"kind":"struct"},"17:9907:16644":{"crate_id":17,"path":["object","read","elf","version","VersionIndex"],"kind":"struct"},"2:21803:32722":{"crate_id":2,"path":["core","num","dec2flt","number","Number"],"kind":"struct"},"1:2346:3312":{"crate_id":1,"path":["std","fs","symlink_metadata"],"kind":"function"},"6:4882:1001":{"crate_id":6,"path":["libc","unix","linux_like","linux","option"],"kind":"struct"},"16:7767:16434":{"crate_id":16,"path":["gimli","read","unit","UnitType"],"kind":"enum"},"32:6316:13550":{"crate_id":32,"path":["libc","unix","linux_like","linux","__c_anonymous_ifr_ifru"],"kind":"union"},"2:45681:3719":{"crate_id":2,"path":["core","core_arch","simd","f32x2"],"kind":"struct"},"2:46292:3688":{"crate_id":2,"path":["core","core_arch","simd","u8x32"],"kind":"struct"},"17:12259:19833":{"crate_id":17,"path":["object","macho","DylibModule64"],"kind":"struct"},"14:160:15354":{"crate_id":14,"path":["rustc_demangle","Demangle"],"kind":"struct"},"2:43649:8908":{"crate_id":2,"path":["core","str","iter","EncodeUtf16"],"kind":"struct"},"2:21945:34249":{"crate_id":2,"path":["core","num","fmt","Formatted"],"kind":"struct"},"6:5974:14191":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","seminfo"],"kind":"struct"},"41:2450:16651":{"crate_id":41,"path":["object","read","macho","fat","FatArch"],"kind":"trait"},"16:7626:16426":{"crate_id":16,"path":["gimli","read","rnglists","RngListIter"],"kind":"struct"},"17:12646:19859":{"crate_id":17,"path":["object","macho","ScatteredRelocationInfo"],"kind":"struct"},"0:0:1716":{"crate_id":0,"path":["clap"],"kind":"module"},"0:7:1709":{"crate_id":0,"path":["clap","_cookbook"],"kind":"module"},"34:7607:22471":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_restriction"],"kind":"struct"},"2:44084:9411":{"crate_id":2,"path":["core","str","CharEscapeUnicode"],"kind":"struct"},"6:7497:13701":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_condattr_t"],"kind":"struct"},"2:11500:9419":{"crate_id":2,"path":["core","str","iter","MatchesInternal"],"kind":"struct"},"2:2312:188":{"crate_id":2,"path":["core","cmp","PartialEq"],"kind":"trait"},"40:7711:16431":{"crate_id":40,"path":["gimli","read","UnitOffset"],"kind":"struct"},"20:1666:28211":{"crate_id":20,"path":["clap_builder","error","format","Escape"],"kind":"struct"},"34:6962:22437":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_5"],"kind":"struct"},"34:6190:22404":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_7"],"kind":"struct"},"1:7942:3375":{"crate_id":1,"path":["std","io","error","ErrorKind"],"kind":"enum"},"34:5139:22356":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_sockaddr_storage__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"34:4797:22328":{"crate_id":34,"path":["linux_raw_sys","general","vfs_cap_data"],"kind":"struct"},"17:12536:19852":{"crate_id":17,"path":["object","macho","EntryPointCommand"],"kind":"struct"},"25:313:20745":{"crate_id":25,"path":["anstyle","effect","Effects"],"kind":"struct"},"2:9624:32110":{"crate_id":2,"path":["core","slice","sort","merge_sort","RunVec"],"kind":"struct"},"17:13332:20593":{"crate_id":17,"path":["object","pe","ImageTlsDirectory64"],"kind":"struct"},"17:9628:16570":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdat"],"kind":"struct"},"20:4432:39082":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","OccurrencesRef"],"kind":"struct"},"34:6818:22427":{"crate_id":34,"path":["linux_raw_sys","general","new_utsname"],"kind":"struct"},"2:43375:8892":{"crate_id":2,"path":["core","str","iter","RSplit"],"kind":"struct"},"20:4030:2980":{"crate_id":20,"path":["clap_builder","builder","value_parser","RangedU64ValueParser"],"kind":"struct"},"2:46036:3726":{"crate_id":2,"path":["core","core_arch","simd","f64x2"],"kind":"struct"},"40:2931:15451":{"crate_id":40,"path":["gimli","common","UnitSectionOffset"],"kind":"enum"},"41:10727:16737":{"crate_id":41,"path":["object","read","pe","resource","ResourceDirectory"],"kind":"struct"},"41:12490:19845":{"crate_id":41,"path":["object","macho","BuildVersionCommand"],"kind":"struct"},"17:9312:16536":{"crate_id":17,"path":["object","read","any","DynamicRelocationIterator"],"kind":"struct"},"17:10402:16726":{"crate_id":17,"path":["object","read","pe","file","PeFile"],"kind":"struct"},"40:5594:16348":{"crate_id":40,"path":["gimli","read","cfi","EhFrameHdr"],"kind":"struct"},"32:8470:10907":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","stat64"],"kind":"struct"},"32:8534:10884":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statvfs64"],"kind":"struct"},"41:12170:19825":{"crate_id":41,"path":["object","macho","DylinkerCommand"],"kind":"struct"},"17:9228:38757":{"crate_id":17,"path":["object","read","any","SymbolTableInternal"],"kind":"enum"},"40:5724:16356":{"crate_id":40,"path":["gimli","read","cfi","CfiEntriesIter"],"kind":"struct"},"48:6542:22429":{"crate_id":48,"path":["linux_raw_sys","general","membarrier_cmd_flag"],"kind":"enum"},"2:22260:175":{"crate_id":2,"path":["core","num","nonzero","NonZeroU16"],"kind":"struct"},"48:7214:10944":{"crate_id":48,"path":["linux_raw_sys","general","sockaddr"],"kind":"struct"},"41:9653:16576":{"crate_id":41,"path":["object","read","coff","symbol","CoffSymbol"],"kind":"struct"},"1:6369:3176":{"crate_id":1,"path":["std","sync","once","Once"],"kind":"struct"},"32:5108:13488":{"crate_id":32,"path":["libc","unix","linux_like","linux","input_keymap_entry"],"kind":"struct"},"2:40424:9230":{"crate_id":2,"path":["core","iter","adapters","skip","Skip"],"kind":"struct"},"32:8621:14610":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpstate"],"kind":"struct"},"41:12388:19838":{"crate_id":41,"path":["object","macho","UuidCommand"],"kind":"struct"},"17:13659:20618":{"crate_id":17,"path":["object","pe","ImageArm64RuntimeFunctionEntry"],"kind":"struct"},"48:5712:14989":{"crate_id":48,"path":["linux_raw_sys","general","clone_args"],"kind":"struct"},"11:326:37579":{"crate_id":11,"path":["hashbrown","raw","RawIntoIter"],"kind":"struct"},"37:165:15355":{"crate_id":37,"path":["rustc_demangle","DemangleStyle"],"kind":"enum"},"5:3688:3229":{"crate_id":5,"path":["alloc","collections","linked_list","CursorMut"],"kind":"struct"},"34:7668:22478":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_12"],"kind":"enum"},"6:7568:15177":{"crate_id":6,"path":["libc","unix","linux_like","linux","non_exhaustive","open_how"],"kind":"struct"},"34:6086:10037":{"crate_id":34,"path":["linux_raw_sys","general","sigval"],"kind":"union"},"34:5988:13479":{"crate_id":34,"path":["linux_raw_sys","general","itimerspec"],"kind":"struct"},"6:7532:13706":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_rwlock_t"],"kind":"struct"},"1:1895:3284":{"crate_id":1,"path":["std","error","Report"],"kind":"struct"},"41:10706:16746":{"crate_id":41,"path":["object","read","pe","relocation","RelocationIterator"],"kind":"struct"},"41:10161:16653":{"crate_id":41,"path":["object","read","macho","load_command","LoadCommandIterator"],"kind":"struct"},"26:170:3336":{"crate_id":26,"path":["anstream","raw","private","Sealed"],"kind":"trait"},"47:4707:39622":{"crate_id":47,"path":["rustix","process","prctl","TimeStampCounterReadability"],"kind":"enum"},"2:2780:9263":{"crate_id":2,"path":["core","ops","arith","Neg"],"kind":"trait"},"32:2066:10957":{"crate_id":32,"path":["libc","unix","linux_like","arpreq"],"kind":"struct"},"6:4466:13490":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_replay"],"kind":"struct"},"16:6793:16398":{"crate_id":16,"path":["gimli","read","line","CompleteLineProgram"],"kind":"struct"},"20:3922:2653":{"crate_id":20,"path":["clap_builder","builder","value_hint","ValueHint"],"kind":"enum"},"16:2378:15428":{"crate_id":16,"path":["gimli","common","DebugAbbrevOffset"],"kind":"struct"},"1:9081:3619":{"crate_id":1,"path":["std","time","SystemTimeError"],"kind":"struct"},"20:3399:2988":{"crate_id":20,"path":["clap_builder","builder","arg_settings","ArgFlags"],"kind":"struct"},"2:42658:9063":{"crate_id":2,"path":["core","hash","sip","SipHasher13"],"kind":"struct"},"33:2624:20830":{"crate_id":33,"path":["rustix","backend","io","poll_fd","PollFd"],"kind":"struct"},"5:6446:35280":{"crate_id":5,"path":["alloc","vec","into_iter","drop","DropGuard"],"kind":"struct"},"20:4152:20692":{"crate_id":20,"path":["clap_builder","error","context","ContextKind"],"kind":"enum"},"2:41597:3191":{"crate_id":2,"path":["core","result","IntoIter"],"kind":"struct"},"48:5814:22400":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"11:97:37578":{"crate_id":11,"path":["hashbrown","raw","Bucket"],"kind":"struct"},"41:9036:38740":{"crate_id":41,"path":["object","read","any","FileInternal"],"kind":"enum"},"17:10967:16548":{"crate_id":17,"path":["object","read","Import"],"kind":"struct"},"2:6768:9199":{"crate_id":2,"path":["core","iter","range","Step"],"kind":"trait"},"1:5910:3577":{"crate_id":1,"path":["std","sync","mpmc","counter","Sender"],"kind":"struct"},"1:3881:3424":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStrExt"],"kind":"trait"},"16:2502:15433":{"crate_id":16,"path":["gimli","common","DebugLineOffset"],"kind":"struct"},"2:2512:149":{"crate_id":2,"path":["core","convert","Into"],"kind":"trait"},"2:2746:106":{"crate_id":2,"path":["core","marker","ConstParamTy"],"kind":"trait"},"6:4980:13545":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_alg"],"kind":"struct"},"1:3875:3425":{"crate_id":1,"path":["std","os","unix","ffi","os_str","OsStringExt"],"kind":"trait"},"1:7471:23966":{"crate_id":1,"path":["std","backtrace_rs","symbolize","SymbolName"],"kind":"struct"},"41:11827:19805":{"crate_id":41,"path":["object","macho","DyldCacheMappingInfo"],"kind":"struct"},"41:9095:38741":{"crate_id":41,"path":["object","read","any","SegmentIteratorInternal"],"kind":"enum"},"1:11905:1499":{"crate_id":1,"path":["std","u8"],"kind":"primitive"},"42:609:38793":{"crate_id":42,"path":["memchr","memmem","twoway","Suffix"],"kind":"struct"},"2:2800:9267":{"crate_id":2,"path":["core","ops","arith","RemAssign"],"kind":"trait"},"25:334:20746":{"crate_id":25,"path":["anstyle","effect","EffectIter"],"kind":"struct"},"2:46014:3720":{"crate_id":2,"path":["core","core_arch","simd","f32x4"],"kind":"struct"},"34:6933:22433":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"],"kind":"union"},"16:2404:15429":{"crate_id":16,"path":["gimli","common","DebugAddrBase"],"kind":"struct"},"1:8955:24671":{"crate_id":1,"path":["std","sync","mpmc","list","ListToken"],"kind":"struct"},"2:11424:9418":{"crate_id":2,"path":["core","str","iter","SplitInternal"],"kind":"struct"},"17:9068:38755":{"crate_id":17,"path":["object","read","any","SegmentInternal"],"kind":"enum"},"39:198:15373":{"crate_id":39,"path":["addr2line","LocationRangeUnitIter"],"kind":"struct"},"5:1078:36410":{"crate_id":5,"path":["alloc","collections","btree","dedup_sorted_iter","DedupSortedIter"],"kind":"struct"},"1:6133:24657":{"crate_id":1,"path":["std","sync","mpmc","zero","ZeroToken"],"kind":"struct"},"41:10748:16748":{"crate_id":41,"path":["object","read","pe","resource","ResourceDirectoryEntryData"],"kind":"enum"},"41:10762:16749":{"crate_id":41,"path":["object","read","pe","resource","ResourceName"],"kind":"struct"},"2:20577:34999":{"crate_id":2,"path":["core","core_simd","swizzle","interleave","Lo"],"kind":"struct"},"6:4751:13518":{"crate_id":6,"path":["libc","unix","linux_like","linux","fanotify_response"],"kind":"struct"},"32:699:10037":{"crate_id":32,"path":["libc","unix","sigval"],"kind":"struct"},"2:21952:3418":{"crate_id":2,"path":["core","num","error","TryFromIntError"],"kind":"struct"},"17:10257:16659":{"crate_id":17,"path":["object","read","macho","segment","MachOSegmentIterator"],"kind":"struct"},"41:11918:19809":{"crate_id":41,"path":["object","macho","MachHeader64"],"kind":"struct"},"1:11907:1497":{"crate_id":1,"path":["std","u32"],"kind":"primitive"},"10:0:2493":{"crate_id":10,"path":["adler"],"kind":"module"},"1:11889:1515":{"crate_id":1,"path":["std","unit"],"kind":"primitive"},"1:413:165":{"crate_id":1,"path":["std","thread","local","LocalKey"],"kind":"struct"},"40:5847:16360":{"crate_id":40,"path":["gimli","read","cfi","PartialFrameDescriptionEntry"],"kind":"struct"},"1:3983:3431":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt"],"kind":"trait"},"1:926:3198":{"crate_id":1,"path":["std","collections","hash","map","IntoValues"],"kind":"struct"},"17:12006:19817":{"crate_id":17,"path":["object","macho","FvmlibCommand"],"kind":"struct"},"16:6390:16382":{"crate_id":16,"path":["gimli","read","aranges","ArangeHeaderIter"],"kind":"struct"},"33:3480:15262":{"crate_id":33,"path":["rustix","backend","termios","types","Action"],"kind":"enum"},"1:618:3167":{"crate_id":1,"path":["std","backtrace","Backtrace"],"kind":"struct"},"2:30232:3224":{"crate_id":2,"path":["core","mem","manually_drop","ManuallyDrop"],"kind":"struct"},"41:13556:20610":{"crate_id":41,"path":["object","pe","ImagePrologueDynamicRelocationHeader"],"kind":"struct"},"41:12959:20563":{"crate_id":41,"path":["object","pe","ImageFileHeader"],"kind":"struct"},"17:10670:16737":{"crate_id":17,"path":["object","read","pe","resource","ResourceDirectory"],"kind":"struct"},"17:10478:16711":{"crate_id":17,"path":["object","read","pe","section","PeSectionIterator"],"kind":"struct"},"18:582:9050":{"crate_id":18,"path":["memchr","memmem","twoway","Reverse"],"kind":"struct"},"2:40133:33734":{"crate_id":2,"path":["core","ffi","c_str","FromBytesWithNulErrorKind"],"kind":"enum"},"6:5717:14114":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","statx"],"kind":"struct"},"34:6776:22425":{"crate_id":34,"path":["linux_raw_sys","general","oldold_utsname"],"kind":"struct"},"9:502:15226":{"crate_id":9,"path":["miniz_oxide","StreamResult"],"kind":"struct"},"20:4293:20683":{"crate_id":20,"path":["clap_builder","error","Message"],"kind":"enum"},"34:5625:22378":{"crate_id":34,"path":["linux_raw_sys","general","ipv6_destopt_hao"],"kind":"struct"},"1:8784:3189":{"crate_id":1,"path":["std","sync","mpsc","Iter"],"kind":"struct"},"1:10822:3273":{"crate_id":1,"path":["std","sys","unix","os","JoinPathsError"],"kind":"struct"},"6:6685:14607":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","pthread_attr_t"],"kind":"struct"},"9:421:15225":{"crate_id":9,"path":["miniz_oxide","MZStatus"],"kind":"enum"},"2:20841:3643":{"crate_id":2,"path":["core","core_simd","elements","int","SimdInt"],"kind":"trait"},"17:13316:20591":{"crate_id":17,"path":["object","pe","ImageThunkData64"],"kind":"struct"},"32:0:816":{"crate_id":32,"path":["libc"],"kind":"module"},"1:3060:3391":{"crate_id":1,"path":["std","io","readbuf","BorrowedBuf"],"kind":"struct"},"48:7356:14179":{"crate_id":48,"path":["linux_raw_sys","general","msghdr"],"kind":"struct"},"47:3380:20836":{"crate_id":47,"path":["rustix","backend","io","types","PipeFlags"],"kind":"struct"},"5:3673:3228":{"crate_id":5,"path":["alloc","collections","linked_list","Cursor"],"kind":"struct"},"48:4558:15177":{"crate_id":48,"path":["linux_raw_sys","general","open_how"],"kind":"struct"},"41:12972:20564":{"crate_id":41,"path":["object","pe","ImageDataDirectory"],"kind":"struct"},"6:7491:13700":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_rwlockattr_t"],"kind":"struct"},"1:10647:26109":{"crate_id":1,"path":["std","sys","unix","fs","FileAttr"],"kind":"struct"},"6:7555:13709":{"crate_id":6,"path":["libc","unix","linux_like","linux","canfd_frame"],"kind":"struct"},"40:7803:16435":{"crate_id":40,"path":["gimli","read","unit","UnitHeader"],"kind":"struct"},"5:5834:9628":{"crate_id":5,"path":["alloc","sync","ArcInner"],"kind":"struct"},"17:8443:16519":{"crate_id":17,"path":["object","common","RelocationKind"],"kind":"enum"},"42:491:20718":{"crate_id":42,"path":["memchr","cow","Imp"],"kind":"struct"},"40:3872:15519":{"crate_id":40,"path":["gimli","constants","DwCfa"],"kind":"struct"},"1:4414:3465":{"crate_id":1,"path":["std","os","unix","process","CommandExt"],"kind":"trait"},"48:6202:22419":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_6"],"kind":"enum"},"6:4619:13506":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Sym"],"kind":"struct"},"1:10835:3539":{"crate_id":1,"path":["std","sys","unix","process","process_common","Stdio"],"kind":"enum"},"20:4594:20704":{"crate_id":20,"path":["clap_builder","parser","parser","ParseState"],"kind":"enum"},"48:6705:22445":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_1"],"kind":"union"},"2:4386:9011":{"crate_id":2,"path":["core","cell","RefMut"],"kind":"struct"},"17:13211:20582":{"crate_id":17,"path":["object","pe","ImageAuxSymbolWeak"],"kind":"struct"},"34:5266:10942":{"crate_id":34,"path":["linux_raw_sys","general","ip_mreqn"],"kind":"struct"},"34:7598:22470":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_probe"],"kind":"struct"},"18:590:34262":{"crate_id":18,"path":["memchr","memmem","twoway","TwoWay"],"kind":"struct"},"17:13477:20608":{"crate_id":17,"path":["object","pe","ImageDynamicRelocation32V2"],"kind":"struct"},"1:4564:3429":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt"],"kind":"trait"},"44:0:2493":{"crate_id":44,"path":["adler"],"kind":"module"},"41:9990:16620":{"crate_id":41,"path":["object","read","elf","version","VersionTable"],"kind":"struct"},"1:1589:3212":{"crate_id":1,"path":["std","collections","hash","set","SymmetricDifference"],"kind":"struct"},"20:4444:39050":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","OccurrenceValuesRef"],"kind":"struct"},"40:6431:16384":{"crate_id":40,"path":["gimli","read","aranges","ArangeEntryIter"],"kind":"struct"},"41:8724:15391":{"crate_id":41,"path":["object","endian","BigEndian"],"kind":"struct"},"16:6943:16405":{"crate_id":16,"path":["gimli","read","loclists","RawLocListEntry"],"kind":"enum"},"40:139:15401":{"crate_id":40,"path":["gimli","read","util","ArrayLike"],"kind":"trait"},"41:10655:16548":{"crate_id":41,"path":["object","read","pe","import","Import"],"kind":"enum"},"17:8310:16515":{"crate_id":17,"path":["object","common","SectionKind"],"kind":"enum"},"1:6101:27096":{"crate_id":1,"path":["std","sync","mpmc","waker","SyncWaker"],"kind":"struct"},"42:80:20646":{"crate_id":42,"path":["memchr","memchr","iter","Memchr"],"kind":"struct"},"48:4942:10940":{"crate_id":48,"path":["linux_raw_sys","general","in_addr"],"kind":"struct"},"2:43507:8922":{"crate_id":2,"path":["core","str","iter","MatchIndices"],"kind":"struct"},"18:644:38764":{"crate_id":18,"path":["memchr","memmem","x86","avx","nostd","Forward"],"kind":"struct"},"2:4406:3150":{"crate_id":2,"path":["core","cell","UnsafeCell"],"kind":"struct"},"20:4474:20710":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","Indices"],"kind":"struct"},"16:3030:15453":{"crate_id":16,"path":["gimli","common","DwoId"],"kind":"struct"},"5:815:3215":{"crate_id":5,"path":["alloc","collections","binary_heap","RebuildOnDrop"],"kind":"struct"},"40:5032:16127":{"crate_id":40,"path":["gimli","constants","DwLnct"],"kind":"struct"},"2:2796:9265":{"crate_id":2,"path":["core","ops","arith","DivAssign"],"kind":"trait"},"20:4919:38946":{"crate_id":20,"path":["clap_builder","util","graph","ChildGraph"],"kind":"struct"},"32:7565:14189":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","Elf64_Chdr"],"kind":"struct"},"32:7473:14186":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","timex"],"kind":"struct"},"17:9876:16643":{"crate_id":17,"path":["object","read","elf","note","Note"],"kind":"struct"},"6:482:10026":{"crate_id":6,"path":["libc","unix","utimbuf"],"kind":"struct"},"2:46416:3700":{"crate_id":2,"path":["core","core_arch","simd","u32x8"],"kind":"struct"},"41:10602:16549":{"crate_id":41,"path":["object","read","pe","export","Export"],"kind":"struct"},"32:2041:10956":{"crate_id":32,"path":["libc","unix","linux_like","in6_rtmsg"],"kind":"struct"},"1:8234:3408":{"crate_id":1,"path":["std","os","unix","net","listener","Incoming"],"kind":"struct"},"17:11721:19804":{"crate_id":17,"path":["object","macho","DyldCacheHeader"],"kind":"struct"},"34:4951:22340":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_provisioning_key_payload"],"kind":"struct"},"16:6696:16395":{"crate_id":16,"path":["gimli","read","line","ColumnType"],"kind":"enum"},"20:3863:2961":{"crate_id":20,"path":["clap_builder","builder","str","Str"],"kind":"struct"},"48:6950:22458":{"crate_id":48,"path":["linux_raw_sys","general","io_sqring_offsets"],"kind":"struct"},"41:11870:16701":{"crate_id":41,"path":["object","macho","FatHeader"],"kind":"struct"},"41:13716:20618":{"crate_id":41,"path":["object","pe","ImageArm64RuntimeFunctionEntry"],"kind":"struct"},"43:174:15326":{"crate_id":43,"path":["miniz_oxide","inflate","stream","InflateState"],"kind":"struct"},"42:719:20660":{"crate_id":42,"path":["memchr","memmem","NeedleInfo"],"kind":"struct"},"34:5397:22368":{"crate_id":34,"path":["linux_raw_sys","general","ip_esp_hdr"],"kind":"struct"},"17:12098:19824":{"crate_id":17,"path":["object","macho","PreboundDylibCommand"],"kind":"struct"},"47:356:39691":{"crate_id":47,"path":["rustix","backend","reg","ArgReg"],"kind":"struct"},"47:2839:20828":{"crate_id":47,"path":["rustix","backend","io","errno","Errno"],"kind":"struct"},"1:11894:1397":{"crate_id":1,"path":["std","str"],"kind":"primitive"},"2:1630:588":{"crate_id":2,"path":["core","mem","drop"],"kind":"function"},"16:6474:16387":{"crate_id":16,"path":["gimli","read","index","DebugTuIndex"],"kind":"struct"},"40:933:15400":{"crate_id":40,"path":["gimli","read","reader","Reader"],"kind":"trait"},"26:63:20775":{"crate_id":26,"path":["anstream","adapter","strip","VtUtf8Receiver"],"kind":"struct"},"32:4761:11107":{"crate_id":32,"path":["libc","unix","linux_like","linux","fpos64_t"],"kind":"enum"},"40:6575:16393":{"crate_id":40,"path":["gimli","read","line","LineInstruction"],"kind":"enum"},"41:9245:38746":{"crate_id":41,"path":["object","read","any","ComdatSectionIteratorInternal"],"kind":"enum"},"11:703:3198":{"crate_id":11,"path":["hashbrown","map","IntoValues"],"kind":"struct"},"34:5019:22344":{"crate_id":34,"path":["linux_raw_sys","general","mount_attr"],"kind":"struct"},"2:9147:120":{"crate_id":2,"path":["core","fmt","Display"],"kind":"trait"},"20:41:2662":{"crate_id":20,"path":["clap_builder","derive","Parser"],"kind":"trait"},"2:8670:79":{"crate_id":2,"path":["core","sync","atomic","AtomicBool"],"kind":"struct"},"2:20804:3642":{"crate_id":2,"path":["core","core_simd","elements","float","SimdFloat"],"kind":"trait"},"2:2981:3246":{"crate_id":2,"path":["core","ops","index","Index"],"kind":"trait"},"20:4465:39037":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","RawOccurrenceValues"],"kind":"struct"},"17:10885:16544":{"crate_id":17,"path":["object","read","SymbolMap"],"kind":"struct"},"32:1927:10951":{"crate_id":32,"path":["libc","unix","linux_like","sched_param"],"kind":"struct"},"1:8387:3524":{"crate_id":1,"path":["std","path","State"],"kind":"enum"},"6:1709:10960":{"crate_id":6,"path":["libc","unix","linux_like","mmsghdr"],"kind":"struct"},"2:2518:238":{"crate_id":2,"path":["core","convert","TryInto"],"kind":"trait"},"16:7596:16425":{"crate_id":16,"path":["gimli","read","rnglists","RawRngListEntry"],"kind":"enum"},"42:574:38764":{"crate_id":42,"path":["memchr","memmem","twoway","Forward"],"kind":"struct"},"47:4451:39540":{"crate_id":47,"path":["rustix","process","prctl","FloatingPointEmulationControl"],"kind":"struct"},"17:11844:19808":{"crate_id":17,"path":["object","macho","MachHeader32"],"kind":"struct"},"40:6793:16398":{"crate_id":40,"path":["gimli","read","line","CompleteLineProgram"],"kind":"struct"},"2:11249:9369":{"crate_id":2,"path":["core","slice","SlicePattern"],"kind":"trait"},"32:5681:13514":{"crate_id":32,"path":["libc","unix","linux_like","linux","genlmsghdr"],"kind":"struct"},"40:6243:37740":{"crate_id":40,"path":["gimli","read","dwarf","RangeIterInner"],"kind":"enum"},"13:0:2489":{"crate_id":13,"path":["std_detect"],"kind":"module"},"32:7182:14175":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","aiocb"],"kind":"struct"},"1:7854:3373":{"crate_id":1,"path":["std","io","buffered","IntoInnerError"],"kind":"struct"},"5:7195:33734":{"crate_id":5,"path":["alloc","ffi","c_str","FromBytesWithNulErrorKind"],"kind":"enum"},"17:9853:16642":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdatSectionIterator"],"kind":"struct"},"2:2242:97":{"crate_id":2,"path":["core","borrow","Borrow"],"kind":"trait"},"5:1197:3204":{"crate_id":5,"path":["alloc","collections","btree","map","entry","Entry"],"kind":"enum"},"17:13265:20588":{"crate_id":17,"path":["object","pe","ImageArchiveMemberHeader"],"kind":"struct"},"32:9659:13705":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_mutex_t"],"kind":"struct"},"1:11903:744":{"crate_id":1,"path":["std","i64"],"kind":"primitive"},"17:10615:16735":{"crate_id":17,"path":["object","read","pe","import","DelayLoadImportTable"],"kind":"struct"},"2:22392:3152":{"crate_id":2,"path":["core","num","nonzero","NonZeroUsize"],"kind":"struct"},"2:40448:9216":{"crate_id":2,"path":["core","iter","adapters","step_by","StepBy"],"kind":"struct"},"6:1555:10946":{"crate_id":6,"path":["libc","unix","linux_like","sockaddr_in6"],"kind":"struct"},"1:7786:3328":{"crate_id":1,"path":["std","fs","ReadDir"],"kind":"struct"},"5:1404:3192":{"crate_id":5,"path":["alloc","collections","btree","map","Keys"],"kind":"struct"},"17:9178:16533":{"crate_id":17,"path":["object","read","any","ComdatSectionIterator"],"kind":"struct"},"47:498:24053":{"crate_id":47,"path":["rustix","backend","io","epoll","Epoll"],"kind":"struct"},"36:530:24645":{"crate_id":36,"path":["backtrace","symbolize","gimli","Cache"],"kind":"struct"},"6:5032:13550":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_ifr_ifru"],"kind":"union"},"34:6997:22441":{"crate_id":34,"path":["linux_raw_sys","general","uffdio_copy"],"kind":"struct"},"2:2695:225":{"crate_id":2,"path":["core","marker","StructuralEq"],"kind":"trait"},"34:6917:22431":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1"],"kind":"union"},"34:7041:22446":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"48:4674:22343":{"crate_id":48,"path":["linux_raw_sys","general","fsconfig_command"],"kind":"enum"},"17:8971:129":{"crate_id":17,"path":["object","read","any","File"],"kind":"struct"},"16:3047:15454":{"crate_id":16,"path":["gimli","common","DwarfFileType"],"kind":"enum"},"32:4854:13477":{"crate_id":32,"path":["libc","unix","linux_like","linux","dqblk"],"kind":"struct"},"41:10373:16655":{"crate_id":41,"path":["object","read","macho","section","MachOSectionInternal"],"kind":"struct"},"2:40438:9231":{"crate_id":2,"path":["core","iter","adapters","skip_while","SkipWhile"],"kind":"struct"},"29:0:2635":{"crate_id":29,"path":["colorchoice"],"kind":"module"},"41:10459:16726":{"crate_id":41,"path":["object","read","pe","file","PeFile"],"kind":"struct"},"6:7275:14990":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","align","sem_t"],"kind":"struct"},"41:10942:16544":{"crate_id":41,"path":["object","read","SymbolMap"],"kind":"struct"},"40:8269:128":{"crate_id":40,"path":["gimli","read","Error"],"kind":"enum"},"41:13936:20634":{"crate_id":41,"path":["object","pe","ImageCor20Header"],"kind":"struct"},"48:4547:14604":{"crate_id":48,"path":["linux_raw_sys","general","flock64"],"kind":"struct"},"31:37:20802":{"crate_id":31,"path":["io_lifetimes","portability","IntoFilelike"],"kind":"trait"},"17:13041:20571":{"crate_id":17,"path":["object","pe","Guid"],"kind":"struct"},"48:5964:22410":{"crate_id":48,"path":["linux_raw_sys","general","tcphdr"],"kind":"struct"},"1:8893:3566":{"crate_id":1,"path":["std","sync","condvar","WaitTimeoutResult"],"kind":"struct"},"16:7065:37799":{"crate_id":16,"path":["gimli","read","lookup","PubStuffParser"],"kind":"struct"},"6:4698:13512":{"crate_id":6,"path":["libc","unix","linux_like","linux","posix_spawn_file_actions_t"],"kind":"struct"},"6:4331:13477":{"crate_id":6,"path":["libc","unix","linux_like","linux","dqblk"],"kind":"struct"},"32:1740:10942":{"crate_id":32,"path":["libc","unix","linux_like","ip_mreqn"],"kind":"struct"},"17:10555:16707":{"crate_id":17,"path":["object","read","pe","export","ExportTable"],"kind":"struct"},"34:6890:22429":{"crate_id":34,"path":["linux_raw_sys","general","membarrier_cmd_flag"],"kind":"enum"},"2:2694:226":{"crate_id":2,"path":["core","marker","StructuralPartialEq"],"kind":"trait"},"17:12799:20560":{"crate_id":17,"path":["object","pe","ImageOs2Header"],"kind":"struct"},"20:4423:38956":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","OccurrenceValues"],"kind":"struct"},"17:13744:20624":{"crate_id":17,"path":["object","pe","ImageEnclaveImport"],"kind":"struct"},"40:4969:16112":{"crate_id":40,"path":["gimli","constants","DwLns"],"kind":"struct"},"1:10416:3381":{"crate_id":1,"path":["std","sys","unix","stdio","Stdin"],"kind":"struct"},"2:47823:8809":{"crate_id":2,"path":["core","core_arch","x86","__m512bh"],"kind":"struct"},"2:40376:9215":{"crate_id":2,"path":["core","iter","adapters","map_while","MapWhile"],"kind":"struct"},"20:3813:2963":{"crate_id":20,"path":["clap_builder","builder","range","ValueRange"],"kind":"struct"},"32:9595:13701":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_condattr_t"],"kind":"struct"},"11:2212:37586":{"crate_id":11,"path":["hashbrown","raw","TableLayout"],"kind":"struct"},"24:0:2630":{"crate_id":24,"path":["unicase"],"kind":"module"},"32:4784:13474":{"crate_id":32,"path":["libc","unix","linux_like","linux","glob_t"],"kind":"struct"},"2:41538:210":{"crate_id":2,"path":["core","result","Result"],"kind":"enum"},"16:6307:16375":{"crate_id":16,"path":["gimli","read","abbrev","DebugAbbrev"],"kind":"struct"},"48:6785:22455":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_8"],"kind":"enum"},"1:4574:29740":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt","st_atime"],"kind":"foreign_type"},"6:7509:13703":{"crate_id":6,"path":["libc","unix","linux_like","linux","fanotify_event_metadata"],"kind":"struct"},"40:6390:16382":{"crate_id":40,"path":["gimli","read","aranges","ArangeHeaderIter"],"kind":"struct"},"41:10314:16659":{"crate_id":41,"path":["object","read","macho","segment","MachOSegmentIterator"],"kind":"struct"},"17:10681:16747":{"crate_id":17,"path":["object","read","pe","resource","ResourceDirectoryTable"],"kind":"struct"},"41:9933:16643":{"crate_id":41,"path":["object","read","elf","note","Note"],"kind":"struct"},"41:13518:20606":{"crate_id":41,"path":["object","pe","ImageDynamicRelocation32"],"kind":"struct"},"48:7278:10880":{"crate_id":48,"path":["linux_raw_sys","general","statfs"],"kind":"struct"},"41:9952:16616":{"crate_id":41,"path":["object","read","elf","hash","GnuHashTable"],"kind":"struct"},"1:1785:3254":{"crate_id":1,"path":["std","env","VarsOs"],"kind":"struct"},"41:8338:16514":{"crate_id":41,"path":["object","common","BinaryFormat"],"kind":"enum"},"2:7263:2680":{"crate_id":2,"path":["core","iter","traits","exact_size","ExactSizeIterator"],"kind":"trait"},"2:43857:8942":{"crate_id":2,"path":["core","str","pattern","CharSliceSearcher"],"kind":"struct"},"2:45521:3692":{"crate_id":2,"path":["core","core_arch","simd","u16x4"],"kind":"struct"},"20:4853:39073":{"crate_id":20,"path":["clap_builder","util","any_value","AnyValue"],"kind":"struct"},"17:10452:16713":{"crate_id":17,"path":["object","read","pe","section","PeSegmentIterator"],"kind":"struct"},"17:13721:20623":{"crate_id":17,"path":["object","pe","ImageEnclaveConfig64"],"kind":"struct"},"34:7921:22487":{"crate_id":34,"path":["linux_raw_sys","general","kernel_sigset_t"],"kind":"struct"},"6:4681:3423":{"crate_id":6,"path":["libc","unix","linux_like","linux","ucred"],"kind":"struct"},"40:6376:16381":{"crate_id":40,"path":["gimli","read","aranges","DebugAranges"],"kind":"struct"},"2:43741:8937":{"crate_id":2,"path":["core","str","pattern","SearchStep"],"kind":"enum"},"33:3823:39597":{"crate_id":33,"path":["rustix","process","id","Gid"],"kind":"struct"},"32:5888:13525":{"crate_id":32,"path":["libc","unix","linux_like","linux","j1939_filter"],"kind":"struct"},"17:11109:16554":{"crate_id":17,"path":["object","read","CompressedData"],"kind":"struct"},"36:513:25778":{"crate_id":36,"path":["backtrace","symbolize","gimli","parse_running_mmaps","MapsEntry"],"kind":"struct"},"2:40206:3304":{"crate_id":2,"path":["core","ffi","VaList"],"kind":"struct"},"36:58:16513":{"crate_id":36,"path":["backtrace","symbolize","Symbol"],"kind":"struct"},"6:4726:13515":{"crate_id":6,"path":["libc","unix","linux_like","linux","in6_pktinfo"],"kind":"struct"},"27:290:20777":{"crate_id":27,"path":["anstyle_parse","AsciiParser"],"kind":"struct"},"11:1126:15345":{"crate_id":11,"path":["hashbrown","map","VacantEntryRef"],"kind":"struct"},"1:2372:3322":{"crate_id":1,"path":["std","fs","read_dir"],"kind":"function"},"2:30288:68":{"crate_id":2,"path":["core","ptr","alignment","Alignment"],"kind":"struct"},"6:5880:14185":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","rtentry"],"kind":"struct"},"11:1561:15348":{"crate_id":11,"path":["hashbrown","rustc_entry","RustcVacantEntry"],"kind":"struct"},"31:142:20811":{"crate_id":31,"path":["io_lifetimes","raw","IntoRawSocketlike"],"kind":"trait"},"5:6367:3191":{"crate_id":5,"path":["alloc","vec","into_iter","IntoIter"],"kind":"struct"},"2:41394:181":{"crate_id":2,"path":["core","option","Option"],"kind":"enum"},"5:7052:198":{"crate_id":5,"path":["alloc","collections","btree","set","Range"],"kind":"struct"},"41:13696:20616":{"crate_id":41,"path":["object","pe","ImageHotPatchHashes"],"kind":"struct"},"2:43153:8884":{"crate_id":2,"path":["core","slice","iter","ChunksMut"],"kind":"struct"},"40:6321:16376":{"crate_id":40,"path":["gimli","read","abbrev","AbbreviationsCache"],"kind":"struct"},"1:5693:3564":{"crate_id":1,"path":["std","sync","barrier","BarrierWaitResult"],"kind":"struct"},"32:6275:13546":{"crate_id":32,"path":["libc","unix","linux_like","linux","uinput_setup"],"kind":"struct"},"1:7644:3173":{"crate_id":1,"path":["std","backtrace","BacktraceStatus"],"kind":"enum"},"48:4635:22339":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_key_specifier__bindgen_ty_1"],"kind":"union"},"2:2768:9261":{"crate_id":2,"path":["core","ops","arith","Div"],"kind":"trait"},"2:2784:3621":{"crate_id":2,"path":["core","ops","arith","AddAssign"],"kind":"trait"},"2:41445:9284":{"crate_id":2,"path":["core","option","Item"],"kind":"struct"},"11:359:37575":{"crate_id":11,"path":["hashbrown","raw","RawDrain"],"kind":"struct"},"34:5029:13532":{"crate_id":34,"path":["linux_raw_sys","general","file_clone_range"],"kind":"struct"},"40:2502:15433":{"crate_id":40,"path":["gimli","common","DebugLineOffset"],"kind":"struct"},"16:6854:16400":{"crate_id":16,"path":["gimli","read","line","FileEntryFormat"],"kind":"struct"},"17:9108:38744":{"crate_id":17,"path":["object","read","any","SectionIteratorInternal"],"kind":"enum"},"17:10936:16547":{"crate_id":17,"path":["object","read","ObjectMapEntry"],"kind":"struct"},"16:6400:16383":{"crate_id":16,"path":["gimli","read","aranges","ArangeHeader"],"kind":"struct"},"41:11541:19311":{"crate_id":41,"path":["object","elf","ProgramHeader32"],"kind":"struct"},"5:265:35280":{"crate_id":5,"path":["alloc","boxed","thin","drop","DropGuard"],"kind":"struct"},"20:4322:20712":{"crate_id":20,"path":["clap_builder","parser","error","MatchesError"],"kind":"enum"},"6:4757:13519":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_vm"],"kind":"struct"},"2:2911:3225":{"crate_id":2,"path":["core","ops","deref","DerefMut"],"kind":"trait"},"1:9003:24681":{"crate_id":1,"path":["std","sync","mpmc","utils","CachePadded"],"kind":"struct"},"11:768:3195":{"crate_id":11,"path":["hashbrown","map","DrainFilter"],"kind":"struct"},"17:8420:16518":{"crate_id":17,"path":["object","common","SymbolScope"],"kind":"enum"},"2:45391:3686":{"crate_id":2,"path":["core","core_arch","simd","u8x4"],"kind":"struct"},"1:2362:3317":{"crate_id":1,"path":["std","fs","canonicalize"],"kind":"function"},"2:43135:8881":{"crate_id":2,"path":["core","slice","iter","Windows"],"kind":"struct"},"32:5716:13516":{"crate_id":32,"path":["libc","unix","linux_like","linux","arpd_request"],"kind":"struct"},"32:6349:13553":{"crate_id":32,"path":["libc","unix","linux_like","linux","sock_txtime"],"kind":"struct"},"2:42674:9062":{"crate_id":2,"path":["core","hash","sip","SipHasher"],"kind":"struct"},"48:4723:13532":{"crate_id":48,"path":["linux_raw_sys","general","file_clone_range"],"kind":"struct"},"20:4865:9223":{"crate_id":20,"path":["clap_builder","util","flat_map","FlatMap"],"kind":"struct"},"16:3872:15519":{"crate_id":16,"path":["gimli","constants","DwCfa"],"kind":"struct"},"5:4207:3189":{"crate_id":5,"path":["alloc","collections","vec_deque","iter","Iter"],"kind":"struct"},"47:4339:39594":{"crate_id":47,"path":["rustix","process","prctl","DumpableBehavior"],"kind":"enum"},"34:5102:22351":{"crate_id":34,"path":["linux_raw_sys","general","futex_waitv"],"kind":"struct"},"2:4377:9010":{"crate_id":2,"path":["core","cell","BorrowRefMut"],"kind":"struct"},"2:40726:9207":{"crate_id":2,"path":["core","iter","sources","successors","Successors"],"kind":"struct"},"5:5818:3561":{"crate_id":5,"path":["alloc","sync","Weak"],"kind":"struct"},"40:6876:16401":{"crate_id":40,"path":["gimli","read","loclists","DebugLoc"],"kind":"struct"},"17:11355:19302":{"crate_id":17,"path":["object","elf","CompressionHeader64"],"kind":"struct"},"5:6607:8973":{"crate_id":5,"path":["alloc","vec","in_place_drop","InPlaceDstBufDrop"],"kind":"struct"},"17:13698:20622":{"crate_id":17,"path":["object","pe","ImageEnclaveConfig32"],"kind":"struct"},"1:530:3141":{"crate_id":1,"path":["std","thread","Packet"],"kind":"struct"},"34:5940:22389":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_old_timeval"],"kind":"struct"},"5:689:111":{"crate_id":5,"path":["alloc","borrow","Cow"],"kind":"enum"},"2:45938:3659":{"crate_id":2,"path":["core","core_arch","simd","i16x8"],"kind":"struct"},"1:857:3190":{"crate_id":1,"path":["std","collections","hash","map","IterMut"],"kind":"struct"},"1:10422:3379":{"crate_id":1,"path":["std","sys","unix","stdio","Stderr"],"kind":"struct"},"41:9964:16644":{"crate_id":41,"path":["object","read","elf","version","VersionIndex"],"kind":"struct"},"16:4037:15636":{"crate_id":16,"path":["gimli","constants","DwTag"],"kind":"struct"},"5:7148:3188":{"crate_id":5,"path":["alloc","collections","TryReserveErrorKind"],"kind":"enum"},"17:9409:16561":{"crate_id":17,"path":["object","read","archive","Members"],"kind":"enum"},"41:9580:16574":{"crate_id":41,"path":["object","read","coff","section","CoffSegment"],"kind":"struct"},"2:10053:8898":{"crate_id":2,"path":["core","slice","iter","SplitInclusive"],"kind":"struct"},"6:4857:13532":{"crate_id":6,"path":["libc","unix","linux_like","linux","file_clone_range"],"kind":"struct"},"20:4331:2656":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","ArgMatches"],"kind":"struct"},"17:9038:38741":{"crate_id":17,"path":["object","read","any","SegmentIteratorInternal"],"kind":"enum"},"5:4366:3347":{"crate_id":5,"path":["alloc","collections","vec_deque","write_iter_wrapping","Guard"],"kind":"struct"},"16:5886:16361":{"crate_id":16,"path":["gimli","read","cfi","FrameDescriptionEntry"],"kind":"struct"},"48:5843:22403":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_6"],"kind":"struct"},"34:6235:22409":{"crate_id":34,"path":["linux_raw_sys","general","sigevent__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"47:4542:39539":{"crate_id":47,"path":["rustix","process","prctl","FloatingPointExceptionMode"],"kind":"struct"},"41:11857:19807":{"crate_id":41,"path":["object","macho","DyldSubCacheInfo"],"kind":"struct"},"41:13573:20612":{"crate_id":41,"path":["object","pe","ImageLoadConfigDirectory32"],"kind":"struct"},"2:7588:3219":{"crate_id":2,"path":["core","iter","traits","marker","FusedIterator"],"kind":"trait"},"17:11969:19815":{"crate_id":17,"path":["object","macho","Section64"],"kind":"struct"},"1:0:1389":{"crate_id":1,"path":["std"],"kind":"module"},"20:3730:39075":{"crate_id":20,"path":["clap_builder","builder","command","TermWidth"],"kind":"struct"},"5:4167:3347":{"crate_id":5,"path":["alloc","collections","vec_deque","into_iter","try_rfold","Guard"],"kind":"struct"},"48:6473:22427":{"crate_id":48,"path":["linux_raw_sys","general","new_utsname"],"kind":"struct"},"2:12512:3768":{"crate_id":2,"path":["core","task","wake","Waker"],"kind":"struct"},"1:11688:27097":{"crate_id":1,"path":["std","backtrace_rs","symbolize","gimli","mmap","Mmap"],"kind":"struct"},"2:44164:9427":{"crate_id":2,"path":["core","time","TryFromFloatSecsErrorKind"],"kind":"enum"},"41:12183:19826":{"crate_id":41,"path":["object","macho","ThreadCommand"],"kind":"struct"},"4:0:2490":{"crate_id":4,"path":["rustc_std_workspace_core"],"kind":"module"},"33:3840:39551":{"crate_id":33,"path":["rustix","process","id","Pid"],"kind":"struct"},"1:3325:3389":{"crate_id":1,"path":["std","io","util","Repeat"],"kind":"struct"},"32:9613:13702":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_barrierattr_t"],"kind":"struct"},"1:5570:3578":{"crate_id":1,"path":["std","sync","mpsc","SyncSender"],"kind":"struct"},"2:47610:3707":{"crate_id":2,"path":["core","core_arch","simd","u64x8"],"kind":"struct"},"16:2808:15446":{"crate_id":16,"path":["gimli","common","DebugStrOffsetsIndex"],"kind":"struct"},"6:1588:10949":{"crate_id":6,"path":["libc","unix","linux_like","fd_set"],"kind":"struct"},"6:4609:13505":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Sym"],"kind":"struct"},"23:5:3424":{"crate_id":23,"path":["clap_lex","ext","OsStrExt"],"kind":"trait"},"17:13082:20574":{"crate_id":17,"path":["object","pe","AnonObjectHeaderBigobj"],"kind":"struct"},"17:13639:20616":{"crate_id":17,"path":["object","pe","ImageHotPatchHashes"],"kind":"struct"},"2:12597:3235":{"crate_id":2,"path":["core","alloc","Allocator"],"kind":"trait"},"34:7312:22455":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_8"],"kind":"enum"},"2:46060:3727":{"crate_id":2,"path":["core","core_arch","simd","f64x4"],"kind":"struct"},"16:4904:16095":{"crate_id":16,"path":["gimli","constants","DwIdx"],"kind":"struct"},"34:6394:22415":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_5"],"kind":"enum"},"33:3014:20836":{"crate_id":33,"path":["rustix","backend","io","types","PipeFlags"],"kind":"struct"},"16:6061:15396":{"crate_id":16,"path":["gimli","read","cfi","CallFrameInstruction"],"kind":"enum"},"1:9120:27327":{"crate_id":1,"path":["std","sys","common","thread_local","fast_local","DtorState"],"kind":"enum"},"32:1816:10946":{"crate_id":32,"path":["libc","unix","linux_like","sockaddr_in6"],"kind":"struct"},"34:4957:22341":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_remove_key_arg"],"kind":"struct"},"43:0:2492":{"crate_id":43,"path":["miniz_oxide"],"kind":"module"},"47:3779:39675":{"crate_id":47,"path":["rustix","backend","process","types","RawCpuSet"],"kind":"struct"},"1:959:3203":{"crate_id":1,"path":["std","collections","hash","map","RawEntryBuilder"],"kind":"struct"},"17:12461:19847":{"crate_id":17,"path":["object","macho","DyldInfoCommand"],"kind":"struct"},"2:43236:8888":{"crate_id":2,"path":["core","slice","iter","RChunks"],"kind":"struct"},"18:660:20663":{"crate_id":18,"path":["memchr","memmem","FindIter"],"kind":"struct"},"1:7015:31344":{"crate_id":1,"path":["std","sys_common","wstr","WStrUnits"],"kind":"struct"},"41:8311:16494":{"crate_id":41,"path":["object","common","AddressSize"],"kind":"enum"},"6:5857:14182":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_pktinfo"],"kind":"struct"},"2:2163:9294":{"crate_id":2,"path":["core","ptr","from_exposed_addr_mut"],"kind":"function"},"5:3521:163":{"crate_id":5,"path":["alloc","collections","linked_list","LinkedList"],"kind":"struct"},"40:6728:16396":{"crate_id":40,"path":["gimli","read","line","LineProgramHeader"],"kind":"struct"},"17:11258:19297":{"crate_id":17,"path":["object","elf","FileHeader64"],"kind":"struct"},"5:5712:3194":{"crate_id":5,"path":["alloc","string","Drain"],"kind":"struct"},"1:11500:15381":{"crate_id":1,"path":["std","backtrace_rs","backtrace","libunwind","Frame"],"kind":"enum"},"17:13015:20568":{"crate_id":17,"path":["object","pe","ImageNtHeaders64"],"kind":"struct"},"13:226:37645":{"crate_id":13,"path":["std_detect","detect","cache","Initializer"],"kind":"struct"},"41:1409:16600":{"crate_id":41,"path":["object","read","elf","segment","ProgramHeader"],"kind":"trait"},"36:145:23961":{"crate_id":36,"path":["backtrace","Bomb"],"kind":"struct"},"40:334:15405":{"crate_id":40,"path":["gimli","read","cfi","_UnwindSectionPrivate"],"kind":"trait"},"40:2720:15442":{"crate_id":40,"path":["gimli","common","DebugRngListsBase"],"kind":"struct"},"41:9397:16537":{"crate_id":41,"path":["object","read","any","SectionRelocationIterator"],"kind":"struct"},"2:41911:90":{"crate_id":2,"path":["core","sync","atomic","AtomicU64"],"kind":"struct"},"34:5924:22387":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_timespec"],"kind":"struct"},"46:35:24048":{"crate_id":46,"path":["terminal_size","Height"],"kind":"struct"},"2:40670:9201":{"crate_id":2,"path":["core","iter","sources","from_fn","FromFn"],"kind":"struct"},"2:43315:8917":{"crate_id":2,"path":["core","str","error","ParseBoolError"],"kind":"struct"},"6:5065:13553":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_txtime"],"kind":"struct"},"14:165:15355":{"crate_id":14,"path":["rustc_demangle","DemangleStyle"],"kind":"enum"},"32:1776:10944":{"crate_id":32,"path":["libc","unix","linux_like","sockaddr"],"kind":"struct"},"2:41991:92":{"crate_id":2,"path":["core","sync","atomic","AtomicUsize"],"kind":"struct"},"16:6336:16378":{"crate_id":16,"path":["gimli","read","abbrev","Abbreviation"],"kind":"struct"},"41:10778:16714":{"crate_id":41,"path":["object","read","pe","rich","RichHeaderInfo"],"kind":"struct"},"41:2027:16602":{"crate_id":41,"path":["object","read","elf","relocation","Rela"],"kind":"trait"},"34:7034:22445":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_1"],"kind":"union"},"5:1981:3228":{"crate_id":5,"path":["alloc","collections","btree","map","Cursor"],"kind":"struct"},"5:35:3249":{"crate_id":5,"path":["alloc","raw_vec","RawVec"],"kind":"struct"},"16:7509:16419":{"crate_id":16,"path":["gimli","read","pubtypes","DebugPubTypes"],"kind":"struct"},"2:32020:3546":{"crate_id":2,"path":["core","convert","Infallible"],"kind":"enum"},"0:21:1713":{"crate_id":0,"path":["clap","_derive","_tutorial"],"kind":"module"},"16:4969:16112":{"crate_id":16,"path":["gimli","constants","DwLns"],"kind":"struct"},"6:7526:13705":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_mutex_t"],"kind":"struct"},"48:7204:22479":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_getevents_arg"],"kind":"struct"},"41:8417:16516":{"crate_id":41,"path":["object","common","ComdatKind"],"kind":"enum"},"48:5282:22375":{"crate_id":48,"path":["linux_raw_sys","general","ipv6_rt_hdr"],"kind":"struct"},"48:4621:22337":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_get_policy_ex_arg__bindgen_ty_1"],"kind":"union"},"41:9943:16617":{"crate_id":41,"path":["object","read","elf","hash","HashTable"],"kind":"struct"},"16:2931:15451":{"crate_id":16,"path":["gimli","common","UnitSectionOffset"],"kind":"enum"},"1:2206:129":{"crate_id":1,"path":["std","fs","File"],"kind":"struct"},"1:7460:16513":{"crate_id":1,"path":["std","backtrace_rs","symbolize","Symbol"],"kind":"struct"},"40:4400:15951":{"crate_id":40,"path":["gimli","constants","DwForm"],"kind":"struct"},"2:10258:8894":{"crate_id":2,"path":["core","slice","iter","RSplitN"],"kind":"struct"},"34:7101:22452":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_6__bindgen_ty_1"],"kind":"struct"},"20:4011:2979":{"crate_id":20,"path":["clap_builder","builder","value_parser","RangedI64ValueParser"],"kind":"struct"},"37:31:15354":{"crate_id":37,"path":["rustc_demangle","v0","Demangle"],"kind":"struct"},"6:6016:14196":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","ptrace_syscall_info"],"kind":"struct"},"48:5602:22389":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_old_timeval"],"kind":"struct"},"18:652:38764":{"crate_id":18,"path":["memchr","memmem","x86","sse","Forward"],"kind":"struct"},"41:12195:19827":{"crate_id":41,"path":["object","macho","RoutinesCommand32"],"kind":"struct"},"17:12923:20565":{"crate_id":17,"path":["object","pe","ImageOptionalHeader32"],"kind":"struct"},"2:39176:200":{"crate_id":2,"path":["core","ops","range","RangeFull"],"kind":"struct"},"1:10462:3146":{"crate_id":1,"path":["std","sys","unix","thread","Thread"],"kind":"struct"},"6:4404:13483":{"crate_id":6,"path":["libc","unix","linux_like","linux","msginfo"],"kind":"struct"},"41:8446:16517":{"crate_id":41,"path":["object","common","SymbolKind"],"kind":"enum"},"5:3124:3211":{"crate_id":5,"path":["alloc","collections","btree","set","Difference"],"kind":"struct"},"34:5581:13515":{"crate_id":34,"path":["linux_raw_sys","general","in6_pktinfo"],"kind":"struct"},"32:6299:13548":{"crate_id":32,"path":["libc","unix","linux_like","linux","af_alg_iv"],"kind":"struct"},"1:4328:3455":{"crate_id":1,"path":["std","os","unix","net","stream","UnixStream"],"kind":"struct"},"17:11770:19805":{"crate_id":17,"path":["object","macho","DyldCacheMappingInfo"],"kind":"struct"},"39:219:15377":{"crate_id":39,"path":["addr2line","RangeAttributes"],"kind":"struct"},"41:13381:20592":{"crate_id":41,"path":["object","pe","ImageThunkData32"],"kind":"struct"},"17:11600:19319":{"crate_id":17,"path":["object","elf","Vernaux"],"kind":"struct"},"45:32:24033":{"crate_id":45,"path":["strsim","StringWrapper"],"kind":"struct"},"32:4917:13479":{"crate_id":32,"path":["libc","unix","linux_like","linux","itimerspec"],"kind":"struct"},"41:13276:20583":{"crate_id":41,"path":["object","pe","ImageAuxSymbolSection"],"kind":"struct"},"31:127:20808":{"crate_id":31,"path":["io_lifetimes","raw","AsRawFilelike"],"kind":"trait"},"1:11900:745":{"crate_id":1,"path":["std","i8"],"kind":"primitive"},"41:11842:19806":{"crate_id":41,"path":["object","macho","DyldCacheImageInfo"],"kind":"struct"},"32:8840:14618":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_fpregs_struct"],"kind":"struct"},"17:9748:16534":{"crate_id":17,"path":["object","read","elf","symbol","SymbolTable"],"kind":"struct"},"2:11717:8903":{"crate_id":2,"path":["core","str","pattern","Pattern"],"kind":"trait"},"6:5022:13549":{"crate_id":6,"path":["libc","unix","linux_like","linux","mq_attr"],"kind":"struct"},"1:1594:3213":{"crate_id":1,"path":["std","collections","hash","set","Union"],"kind":"struct"},"14:0:2496":{"crate_id":14,"path":["rustc_demangle"],"kind":"module"},"18:636:38770":{"crate_id":18,"path":["memchr","memmem","twoway","ApproximateByteSet"],"kind":"struct"},"1:867:3191":{"crate_id":1,"path":["std","collections","hash","map","IntoIter"],"kind":"struct"},"17:10039:16652":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldCacheImage"],"kind":"struct"},"2:40057:9031":{"crate_id":2,"path":["core","char","EscapeDebugInner"],"kind":"enum"},"47:479:24052":{"crate_id":47,"path":["rustix","backend","io","epoll","Owning"],"kind":"struct"},"2:43665:3165":{"crate_id":2,"path":["core","str","iter","EscapeDefault"],"kind":"struct"},"1:10670:25853":{"crate_id":1,"path":["std","sys","unix","fs","FilePermissions"],"kind":"struct"},"41:562:16513":{"crate_id":41,"path":["object","read","any","Symbol"],"kind":"struct"},"2:2817:9269":{"crate_id":2,"path":["core","ops","bit","BitOr"],"kind":"trait"},"32:2001:10954":{"crate_id":32,"path":["libc","unix","linux_like","in_pktinfo"],"kind":"struct"},"26:417:20754":{"crate_id":26,"path":["anstream","auto","AutoStream"],"kind":"struct"},"32:5547:13509":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf32_Shdr"],"kind":"struct"},"1:4256:3461":{"crate_id":1,"path":["std","os","unix","net","listener","UnixListener"],"kind":"struct"},"1:8870:3585":{"crate_id":1,"path":["std","sync","mpsc","TrySendError"],"kind":"enum"},"1:930:3199":{"crate_id":1,"path":["std","collections","hash","map","RawEntryBuilderMut"],"kind":"struct"},"2:40389:9227":{"crate_id":2,"path":["core","iter","adapters","peekable","Peekable"],"kind":"struct"},"41:13202:20577":{"crate_id":41,"path":["object","pe","ImageSymbolEx"],"kind":"struct"},"16:3749:15468":{"crate_id":16,"path":["gimli","constants","DwSect"],"kind":"struct"},"20:1688:128":{"crate_id":20,"path":["clap_builder","error","Error"],"kind":"struct"},"41:1947:16591":{"crate_id":41,"path":["object","read","elf","relocation","ElfDynamicRelocationIterator"],"kind":"struct"},"40:7859:16437":{"crate_id":40,"path":["gimli","read","unit","AttributeValue"],"kind":"enum"},"32:4934:13480":{"crate_id":32,"path":["libc","unix","linux_like","linux","fsid_t"],"kind":"struct"},"41:9526:16565":{"crate_id":41,"path":["object","read","archive","ArchiveMember"],"kind":"struct"},"16:3640:15460":{"crate_id":16,"path":["gimli","arch","X86_64"],"kind":"struct"},"48:7235:3495":{"crate_id":48,"path":["linux_raw_sys","general","stat"],"kind":"struct"},"17:10377:16660":{"crate_id":17,"path":["object","read","macho","symbol","MachOSymbol"],"kind":"struct"},"2:11938:112":{"crate_id":2,"path":["core","str","lossy","Debug"],"kind":"struct"},"16:5963:16364":{"crate_id":16,"path":["gimli","read","cfi","RegisterRuleIter"],"kind":"struct"},"32:5257:13496":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_periodic_effect"],"kind":"struct"},"1:901:3194":{"crate_id":1,"path":["std","collections","hash","map","Drain"],"kind":"struct"},"1:3168:3381":{"crate_id":1,"path":["std","io","stdio","Stdin"],"kind":"struct"},"32:8373:14604":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock64"],"kind":"struct"},"34:7008:22442":{"crate_id":34,"path":["linux_raw_sys","general","uffdio_zeropage"],"kind":"struct"},"16:5386:15393":{"crate_id":16,"path":["gimli","endianity","LittleEndian"],"kind":"struct"},"40:7837:16436":{"crate_id":40,"path":["gimli","read","unit","DebuggingInformationEntry"],"kind":"struct"},"2:7595:9208":{"crate_id":2,"path":["core","iter","traits","marker","TrustedStep"],"kind":"trait"},"2:1544:3347":{"crate_id":2,"path":["core","mem","maybe_uninit","write_slice_cloned","Guard"],"kind":"struct"},"48:4796:22351":{"crate_id":48,"path":["linux_raw_sys","general","futex_waitv"],"kind":"struct"},"33:4415:39674":{"crate_id":33,"path":["rustix","process","prctl","TimingMethod"],"kind":"enum"},"2:4433:9012":{"crate_id":2,"path":["core","cell","SyncUnsafeCell"],"kind":"struct"},"17:8573:16523":{"crate_id":17,"path":["object","common","SectionFlags"],"kind":"enum"},"1:6485:3571":{"crate_id":1,"path":["std","sync","poison","TryLockError"],"kind":"enum"},"2:8843:34721":{"crate_id":2,"path":["core","fmt","builders","PadAdapterState"],"kind":"struct"},"1:10847:25859":{"crate_id":1,"path":["std","sys","unix","process","process_common","ProgramKind"],"kind":"enum"},"47:4213:39545":{"crate_id":47,"path":["rustix","process","membarrier","MembarrierQuery"],"kind":"struct"},"41:11516:19309":{"crate_id":41,"path":["object","elf","Rel64"],"kind":"struct"},"17:8823:16527":{"crate_id":17,"path":["object","endian","I32Bytes"],"kind":"struct"},"48:4762:22348":{"crate_id":48,"path":["linux_raw_sys","general","files_stat_struct"],"kind":"struct"},"32:6342:13552":{"crate_id":32,"path":["libc","unix","linux_like","linux","hwtstamp_config"],"kind":"struct"},"33:5173:39552":{"crate_id":33,"path":["rustix","process","wait","WaitId"],"kind":"enum"},"1:6538:3575":{"crate_id":1,"path":["std","sync","remutex","ReentrantMutex"],"kind":"struct"},"34:5667:22383":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_3"],"kind":"enum"},"42:590:34262":{"crate_id":42,"path":["memchr","memmem","twoway","TwoWay"],"kind":"struct"},"47:457:107":{"crate_id":47,"path":["rustix","backend","io","epoll","Context"],"kind":"trait"},"48:5560:22385":{"crate_id":48,"path":["linux_raw_sys","general","prctl_mm_map"],"kind":"struct"},"1:6865:29967":{"crate_id":1,"path":["std","sys_common","backtrace","_print","DisplayBacktrace"],"kind":"struct"},"17:8979:38740":{"crate_id":17,"path":["object","read","any","FileInternal"],"kind":"enum"},"40:7366:16411":{"crate_id":40,"path":["gimli","read","op","EvaluationResult"],"kind":"enum"},"6:4629:13507":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Phdr"],"kind":"struct"},"33:4941:39581":{"crate_id":33,"path":["rustix","process","sched","CpuSet"],"kind":"struct"},"11:1843:3191":{"crate_id":11,"path":["hashbrown","set","IntoIter"],"kind":"struct"},"41:10993:16547":{"crate_id":41,"path":["object","read","ObjectMapEntry"],"kind":"struct"},"41:10804:128":{"crate_id":41,"path":["object","read","Error"],"kind":"struct"},"1:11887:936":{"crate_id":1,"path":["std","never"],"kind":"primitive"},"17:13411:20600":{"crate_id":17,"path":["object","pe","ImageResourceDirectoryEntry"],"kind":"struct"},"40:8180:16447":{"crate_id":40,"path":["gimli","read","value","ValueType"],"kind":"enum"},"1:2215:3308":{"crate_id":1,"path":["std","fs","read_to_string"],"kind":"function"},"16:5693:16354":{"crate_id":16,"path":["gimli","read","cfi","BaseAddresses"],"kind":"struct"},"2:4255:9002":{"crate_id":2,"path":["core","cell","BorrowError"],"kind":"struct"},"16:5630:16350":{"crate_id":16,"path":["gimli","read","cfi","EhHdrTableIter"],"kind":"struct"},"2:23037:3413":{"crate_id":2,"path":["core","num","saturating","Saturating"],"kind":"struct"},"0:10:1846":{"crate_id":0,"path":["clap","_cookbook","escaped_positional"],"kind":"module"},"33:3110:20829":{"crate_id":33,"path":["rustix","backend","io","types","EventfdFlags"],"kind":"struct"},"1:8226:3454":{"crate_id":1,"path":["std","os","unix","net","ancillary","SocketAncillary"],"kind":"struct"},"16:6254:16373":{"crate_id":16,"path":["gimli","read","endian_slice","EndianSlice"],"kind":"struct"},"42:766:20662":{"crate_id":42,"path":["memchr","memmem","SearcherRevKind"],"kind":"enum"},"12:0:2495":{"crate_id":12,"path":["rustc_std_workspace_alloc"],"kind":"module"},"48:4843:22357":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_1"],"kind":"enum"},"40:6061:15396":{"crate_id":40,"path":["gimli","read","cfi","CallFrameInstruction"],"kind":"enum"},"2:40116:101":{"crate_id":2,"path":["core","ffi","c_str","CStr"],"kind":"struct"},"17:13309:20590":{"crate_id":17,"path":["object","pe","ImageImportByName"],"kind":"struct"},"17:13678:20620":{"crate_id":17,"path":["object","pe","ImageAlphaRuntimeFunctionEntry"],"kind":"struct"},"41:184:16493":{"crate_id":41,"path":["object","read","read_ref","ReadRef"],"kind":"trait"},"41:11068:16498":{"crate_id":41,"path":["object","read","CodeView"],"kind":"struct"},"41:8915:16528":{"crate_id":41,"path":["object","endian","I64Bytes"],"kind":"struct"},"34:6227:22408":{"crate_id":34,"path":["linux_raw_sys","general","sigevent__bindgen_ty_1"],"kind":"union"},"40:2448:15431":{"crate_id":40,"path":["gimli","common","DebugArangesOffset"],"kind":"struct"},"34:7787:22484":{"crate_id":34,"path":["linux_raw_sys","general","__old_kernel_stat"],"kind":"struct"},"5:7338:8968":{"crate_id":5,"path":["alloc","vec","splice","Splice"],"kind":"struct"},"17:11011:16498":{"crate_id":17,"path":["object","read","CodeView"],"kind":"struct"},"17:8858:16528":{"crate_id":17,"path":["object","endian","I64Bytes"],"kind":"struct"},"17:9523:16574":{"crate_id":17,"path":["object","read","coff","section","CoffSegment"],"kind":"struct"},"2:20596:35004":{"crate_id":2,"path":["core","core_simd","swizzle","deinterleave","Odd"],"kind":"struct"},"2:21332:3635":{"crate_id":2,"path":["core","core_simd","ord","SimdPartialOrd"],"kind":"trait"},"20:4304:3167":{"crate_id":20,"path":["clap_builder","error","Backtrace"],"kind":"struct"},"2:45822:3699":{"crate_id":2,"path":["core","core_arch","simd","u32x4"],"kind":"struct"},"1:7571:3336":{"crate_id":1,"path":["std","sealed","Sealed"],"kind":"trait"},"2:20768:33332":{"crate_id":2,"path":["core","core_simd","elements","const_ptr","SimdConstPtr","with_addr"],"kind":"foreign_type"},"17:0:2499":{"crate_id":17,"path":["object"],"kind":"module"},"34:5610:22376":{"crate_id":34,"path":["linux_raw_sys","general","ipv6_opt_hdr"],"kind":"struct"},"34:5128:22354":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_sockaddr_storage"],"kind":"struct"},"41:11220:16757":{"crate_id":41,"path":["object","archive","AixHeader"],"kind":"struct"},"32:7246:14178":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","glob64_t"],"kind":"struct"},"48:6578:22432":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"34:6173:22402":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_3"],"kind":"struct"},"16:5346:16345":{"crate_id":16,"path":["gimli","constants","DwEhPe"],"kind":"struct"},"16:5724:16356":{"crate_id":16,"path":["gimli","read","cfi","CfiEntriesIter"],"kind":"struct"},"34:7049:22447":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_2"],"kind":"union"},"16:5797:37853":{"crate_id":16,"path":["gimli","read","cfi","AugmentationData"],"kind":"struct"},"34:5403:22369":{"crate_id":34,"path":["linux_raw_sys","general","ip_comp_hdr"],"kind":"struct"},"1:11888:419":{"crate_id":1,"path":["std","char"],"kind":"primitive"},"2:2691:2674":{"crate_id":2,"path":["core","marker","Sized"],"kind":"trait"},"6:4392:13482":{"crate_id":6,"path":["libc","unix","linux_like","linux","cpu_set_t"],"kind":"struct"},"17:9917:3061":{"crate_id":17,"path":["object","read","elf","version","Version"],"kind":"struct"},"2:42666:34244":{"crate_id":2,"path":["core","hash","sip","SipHasher24"],"kind":"struct"},"11:675:3197":{"crate_id":11,"path":["hashbrown","map","IntoKeys"],"kind":"struct"},"2:41671:91":{"crate_id":2,"path":["core","sync","atomic","AtomicU8"],"kind":"struct"},"6:4827:13528":{"crate_id":6,"path":["libc","unix","linux_like","linux","seccomp_data"],"kind":"struct"},"17:10721:16714":{"crate_id":17,"path":["object","read","pe","rich","RichHeaderInfo"],"kind":"struct"},"34:5289:22359":{"crate_id":34,"path":["linux_raw_sys","general","ip_msfilter__bindgen_ty_1__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"34:6103:22394":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_1"],"kind":"struct"},"48:5626:22392":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_sock_timeval"],"kind":"struct"},"33:3806:39565":{"crate_id":33,"path":["rustix","process","id","Uid"],"kind":"struct"},"2:42433:32742":{"crate_id":2,"path":["core","fmt","rt","Flag"],"kind":"enum"},"41:3001:15399":{"crate_id":41,"path":["object","read","macho","section","Section"],"kind":"trait"},"21:369:9015":{"crate_id":21,"path":["once_cell","imp","OnceCell"],"kind":"struct"},"41:11698:19322":{"crate_id":41,"path":["object","elf","HashHeader"],"kind":"struct"},"48:6686:22274":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_sqe"],"kind":"struct"},"42:671:20664":{"crate_id":42,"path":["memchr","memmem","FindRevIter"],"kind":"struct"},"33:4928:39602":{"crate_id":33,"path":["rustix","process","rlimit","Rlimit"],"kind":"struct"},"16:6201:16370":{"crate_id":16,"path":["gimli","read","dwarf","DwarfPackage"],"kind":"struct"},"6:4743:13517":{"crate_id":6,"path":["libc","unix","linux_like","linux","inotify_event"],"kind":"struct"},"34:6744:22424":{"crate_id":34,"path":["linux_raw_sys","general","termio"],"kind":"struct"},"2:46212:32748":{"crate_id":2,"path":["core","core_arch","simd","m64x2"],"kind":"struct"},"32:591:10031":{"crate_id":32,"path":["libc","unix","ipv6_mreq"],"kind":"struct"},"34:4807:22329":{"crate_id":34,"path":["linux_raw_sys","general","vfs_cap_data__bindgen_ty_1"],"kind":"struct"},"6:547:10034":{"crate_id":6,"path":["libc","unix","pollfd"],"kind":"struct"},"34:5149:22357":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_1"],"kind":"enum"},"2:7632:33681":{"crate_id":2,"path":["core","net","display_buffer","DisplayBuffer"],"kind":"struct"},"17:11193:16758":{"crate_id":17,"path":["object","archive","AixFileHeader"],"kind":"struct"},"17:11946:19814":{"crate_id":17,"path":["object","macho","Section32"],"kind":"struct"},"2:39358:16448":{"crate_id":2,"path":["core","any","tags","Value"],"kind":"struct"},"48:6298:22420":{"crate_id":48,"path":["linux_raw_sys","general","tcp_md5sig"],"kind":"struct"},"48:4996:22360":{"crate_id":48,"path":["linux_raw_sys","general","group_req"],"kind":"struct"},"41:386:16511":{"crate_id":41,"path":["object","read","any","Segment"],"kind":"struct"},"33:3206:39611":{"crate_id":33,"path":["rustix","backend","process","types","MembarrierCommand"],"kind":"enum"},"40:7557:16423":{"crate_id":40,"path":["gimli","read","rnglists","RangeLists"],"kind":"struct"},"2:39075:8996":{"crate_id":2,"path":["core","ops","control_flow","ControlFlow"],"kind":"enum"},"6:1609:10951":{"crate_id":6,"path":["libc","unix","linux_like","sched_param"],"kind":"struct"},"2:47648:3728":{"crate_id":2,"path":["core","core_arch","simd","f64x8"],"kind":"struct"},"32:6183:13539":{"crate_id":32,"path":["libc","unix","linux_like","linux","sctp_nxtinfo"],"kind":"struct"},"41:12892:20561":{"crate_id":41,"path":["object","pe","ImageVxdHeader"],"kind":"struct"},"2:43210:8871":{"crate_id":2,"path":["core","slice","iter","ArrayChunks"],"kind":"struct"},"40:3300:15457":{"crate_id":40,"path":["gimli","arch","LoongArch"],"kind":"struct"},"16:7803:16435":{"crate_id":16,"path":["gimli","read","unit","UnitHeader"],"kind":"struct"},"34:7546:22465":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_rsrc_update"],"kind":"struct"},"34:5898:22385":{"crate_id":34,"path":["linux_raw_sys","general","prctl_mm_map"],"kind":"struct"},"41:12445:19842":{"crate_id":41,"path":["object","macho","EncryptionInfoCommand32"],"kind":"struct"},"40:2357:15427":{"crate_id":40,"path":["gimli","common","Register"],"kind":"struct"},"1:11461:27445":{"crate_id":1,"path":["std","panicking","panic_count","MustAbort"],"kind":"enum"},"17:8667:15391":{"crate_id":17,"path":["object","endian","BigEndian"],"kind":"struct"},"5:5908:3347":{"crate_id":5,"path":["alloc","sync","from_iter_exact","Guard"],"kind":"struct"},"36:168:15381":{"crate_id":36,"path":["backtrace","backtrace","Frame"],"kind":"struct"},"47:5194:39581":{"crate_id":47,"path":["rustix","process","sched","CpuSet"],"kind":"struct"},"32:7754:14198":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","utmpx"],"kind":"struct"},"33:4957:39547":{"crate_id":33,"path":["rustix","process","wait","WaitOptions"],"kind":"struct"},"1:10826:25720":{"crate_id":1,"path":["std","sys","unix","os_str","Buf"],"kind":"struct"},"1:8103:3335":{"crate_id":1,"path":["std","io","SeekFrom"],"kind":"enum"},"47:2625:20863":{"crate_id":47,"path":["rustix","backend","io","epoll","CreateFlags"],"kind":"struct"},"17:12072:19822":{"crate_id":17,"path":["object","macho","SubUmbrellaCommand"],"kind":"struct"},"2:30466:32684":{"crate_id":2,"path":["core","ptr","alignment","AlignmentEnum64"],"kind":"enum"},"36:651:15381":{"crate_id":36,"path":["backtrace","capture","Frame"],"kind":"enum"},"34:6375:22413":{"crate_id":34,"path":["linux_raw_sys","general","tcp_repair_opt"],"kind":"struct"},"34:4921:22336":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_get_policy_ex_arg"],"kind":"struct"},"2:2822:9270":{"crate_id":2,"path":["core","ops","bit","BitXor"],"kind":"trait"},"41:9500:16563":{"crate_id":41,"path":["object","read","archive","ArchiveMemberIterator"],"kind":"struct"},"48:6749:22453":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_7"],"kind":"enum"},"41:13098:20571":{"crate_id":41,"path":["object","pe","Guid"],"kind":"struct"},"23:157:20731":{"crate_id":23,"path":["clap_lex","ShortFlags"],"kind":"struct"},"17:11282:19298":{"crate_id":17,"path":["object","elf","Ident"],"kind":"struct"},"34:7555:22466":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_rsrc_update2"],"kind":"struct"},"2:3234:8833":{"crate_id":2,"path":["core","ops","unsize","DispatchFromDyn"],"kind":"trait"},"40:6819:16399":{"crate_id":40,"path":["gimli","read","line","FileEntry"],"kind":"struct"},"6:6116:13389":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","sysinfo"],"kind":"struct"},"1:9098:27433":{"crate_id":1,"path":["std","sys","common","thread_local","fast_local","Key"],"kind":"struct"},"2:1756:9304":{"crate_id":2,"path":["core","ptr","metadata","DynMetadata"],"kind":"struct"},"17:13181:20580":{"crate_id":17,"path":["object","pe","ImageAuxSymbolFunction"],"kind":"struct"},"41:9028:129":{"crate_id":41,"path":["object","read","any","File"],"kind":"struct"},"47:4360:39543":{"crate_id":47,"path":["rustix","process","prctl","UnalignedAccessControl"],"kind":"struct"},"20:4394:20708":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","RawValues"],"kind":"struct"},"2:32056:25570":{"crate_id":2,"path":["core","error","private","Internal"],"kind":"struct"},"32:5797:13520":{"crate_id":32,"path":["libc","unix","linux_like","linux","regmatch_t"],"kind":"struct"},"32:4808:13475":{"crate_id":32,"path":["libc","unix","linux_like","linux","passwd"],"kind":"struct"},"1:3987:3432":{"crate_id":1,"path":["std","os","unix","fs","DirEntryExt2"],"kind":"trait"},"47:4145:39565":{"crate_id":47,"path":["rustix","process","id","Uid"],"kind":"struct"},"20:2927:2651":{"crate_id":20,"path":["clap_builder","builder","action","ArgAction"],"kind":"enum"},"1:11027:25849":{"crate_id":1,"path":["std","sys","unix","thread","cgroups","Cgroup"],"kind":"enum"},"2:10286:8895":{"crate_id":2,"path":["core","slice","iter","RSplitNMut"],"kind":"struct"},"1:6621:27447":{"crate_id":1,"path":["std","sync","rwlock","fmt","LockedPlaceholder"],"kind":"struct"},"36:646:3169":{"crate_id":36,"path":["backtrace","capture","BacktraceFrame"],"kind":"struct"},"47:0:2638":{"crate_id":47,"path":["rustix"],"kind":"module"},"34:6012:10030":{"crate_id":34,"path":["linux_raw_sys","general","rusage"],"kind":"struct"},"20:4821:20686":{"crate_id":20,"path":["clap_builder","output","fmt","Stream"],"kind":"enum"},"2:42393:32595":{"crate_id":2,"path":["core","fmt","rt","Placeholder"],"kind":"struct"},"32:8653:14611":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_regs_struct"],"kind":"struct"},"48:4510:20890":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_fd_set"],"kind":"struct"},"6:4865:13533":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_ifru_map"],"kind":"struct"},"41:9545:16580":{"crate_id":41,"path":["object","read","coff","file","CoffFile"],"kind":"struct"},"32:7519:14187":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","ntptimeval"],"kind":"struct"},"11:393:37597":{"crate_id":11,"path":["hashbrown","raw","RawIterHash"],"kind":"struct"},"6:4294:13474":{"crate_id":6,"path":["libc","unix","linux_like","linux","glob_t"],"kind":"struct"},"1:2867:210":{"crate_id":1,"path":["std","io","error","Result"],"kind":"typedef"},"1:361:3161":{"crate_id":1,"path":["std","thread","scoped","ScopedJoinHandle"],"kind":"struct"},"2:45699:3725":{"crate_id":2,"path":["core","core_arch","simd","f64x1"],"kind":"struct"},"48:5236:10946":{"crate_id":48,"path":["linux_raw_sys","general","sockaddr_in6"],"kind":"struct"},"48:5788:22397":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_4"],"kind":"struct"},"32:4830:13476":{"crate_id":32,"path":["libc","unix","linux_like","linux","spwd"],"kind":"struct"},"17:8753:16525":{"crate_id":17,"path":["object","endian","U64Bytes"],"kind":"struct"},"17:10712:16750":{"crate_id":17,"path":["object","read","pe","resource","ResourceNameOrId"],"kind":"enum"},"34:6163:22401":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"2:40034:8919":{"crate_id":2,"path":["core","char","EscapeUnicode"],"kind":"struct"},"48:5307:22378":{"crate_id":48,"path":["linux_raw_sys","general","ipv6_destopt_hao"],"kind":"struct"},"2:21561:3632":{"crate_id":2,"path":["core","core_simd","vector","SimdElement"],"kind":"trait"},"43:352:15239":{"crate_id":43,"path":["miniz_oxide","inflate","TINFLStatus"],"kind":"enum"},"41:10717:16551":{"crate_id":41,"path":["object","read","pe","relocation","Relocation"],"kind":"struct"},"40:2282:15399":{"crate_id":40,"path":["gimli","read","Section"],"kind":"trait"},"1:554:3143":{"crate_id":1,"path":["std","thread","JoinHandle"],"kind":"struct"},"1:936:3200":{"crate_id":1,"path":["std","collections","hash","map","RawEntryMut"],"kind":"enum"},"2:4042:8829":{"crate_id":2,"path":["core","async_iter","async_iter","AsyncIterator"],"kind":"trait"},"32:8858:14619":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ucontext_t"],"kind":"struct"},"17:13292:20589":{"crate_id":17,"path":["object","pe","ImageExportDirectory"],"kind":"struct"},"2:10244:8896":{"crate_id":2,"path":["core","slice","iter","SplitN"],"kind":"struct"},"1:911:3195":{"crate_id":1,"path":["std","collections","hash","map","DrainFilter"],"kind":"struct"},"2:41791:82":{"crate_id":2,"path":["core","sync","atomic","AtomicI32"],"kind":"struct"},"1:11393:3411":{"crate_id":1,"path":["std","sys_common","net","UdpSocket"],"kind":"struct"},"2:21787:34257":{"crate_id":2,"path":["core","num","dec2flt","decimal","Decimal"],"kind":"struct"},"47:3294:20833":{"crate_id":47,"path":["rustix","backend","io","types","DupFlags"],"kind":"struct"},"33:3305:39668":{"crate_id":33,"path":["rustix","backend","process","types","Signal"],"kind":"enum"},"17:8548:16522":{"crate_id":17,"path":["object","common","SegmentFlags"],"kind":"enum"},"1:3210:3384":{"crate_id":1,"path":["std","io","stdio","StdoutLock"],"kind":"struct"},"17:9822:16603":{"crate_id":17,"path":["object","read","elf","relocation","RelocationSections"],"kind":"struct"},"2:12295:136":{"crate_id":2,"path":["core","future","future","Future"],"kind":"trait"},"1:3170:3382":{"crate_id":1,"path":["std","io","stdio","StdinLock"],"kind":"struct"},"33:4557:39613":{"crate_id":33,"path":["rustix","process","prctl","PTracer"],"kind":"enum"},"17:12019:19818":{"crate_id":17,"path":["object","macho","Dylib"],"kind":"struct"},"48:6737:22449":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_4"],"kind":"union"},"17:9734:16592":{"crate_id":17,"path":["object","read","elf","section","ElfSection"],"kind":"struct"},"17:11163:16757":{"crate_id":17,"path":["object","archive","AixHeader"],"kind":"struct"},"32:2088:10958":{"crate_id":32,"path":["libc","unix","linux_like","arpreq_old"],"kind":"struct"},"1:7528:23961":{"crate_id":1,"path":["std","backtrace_rs","Bomb"],"kind":"struct"},"2:41581:3189":{"crate_id":2,"path":["core","result","Iter"],"kind":"struct"},"1:947:3201":{"crate_id":1,"path":["std","collections","hash","map","RawOccupiedEntryMut"],"kind":"struct"},"6:4509:13496":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_periodic_effect"],"kind":"struct"},"20:3882:2991":{"crate_id":20,"path":["clap_builder","builder","str","inner","Inner"],"kind":"enum"},"31:181:20814":{"crate_id":31,"path":["io_lifetimes","views","FilelikeViewType"],"kind":"trait"},"2:2788:3623":{"crate_id":2,"path":["core","ops","arith","SubAssign"],"kind":"trait"},"16:4757:16068":{"crate_id":16,"path":["gimli","constants","DwId"],"kind":"struct"},"21:377:20721":{"crate_id":21,"path":["once_cell","race","OnceNonZeroUsize"],"kind":"struct"},"1:5247:120":{"crate_id":1,"path":["std","path","Display"],"kind":"struct"},"32:8505:10881":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs64"],"kind":"struct"},"16:8109:16442":{"crate_id":16,"path":["gimli","read","unit","EntriesTree"],"kind":"struct"},"32:6003:13531":{"crate_id":32,"path":["libc","unix","linux_like","linux","nlattr"],"kind":"struct"},"2:21116:3634":{"crate_id":2,"path":["core","core_simd","masks","Mask"],"kind":"struct"},"34:6908:22430":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg"],"kind":"struct"},"41:13322:20588":{"crate_id":41,"path":["object","pe","ImageArchiveMemberHeader"],"kind":"struct"},"41:13158:20558":{"crate_id":41,"path":["object","pe","ImageSectionHeader"],"kind":"struct"},"40:7743:16432":{"crate_id":40,"path":["gimli","read","unit","DebugInfo"],"kind":"struct"},"32:1795:10945":{"crate_id":32,"path":["libc","unix","linux_like","sockaddr_in"],"kind":"struct"},"32:808:9709":{"crate_id":32,"path":["libc","unix","fpos_t"],"kind":"enum"},"17:10125:16673":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandData"],"kind":"struct"},"17:9469:16565":{"crate_id":17,"path":["object","read","archive","ArchiveMember"],"kind":"struct"},"41:12076:19818":{"crate_id":41,"path":["object","macho","Dylib"],"kind":"struct"},"41:9195:16532":{"crate_id":41,"path":["object","read","any","ComdatIterator"],"kind":"struct"},"47:2854:20831":{"crate_id":47,"path":["rustix","backend","io","poll_fd","PollFlags"],"kind":"struct"},"34:5048:22346":{"crate_id":34,"path":["linux_raw_sys","general","file_dedupe_range_info"],"kind":"struct"},"5:7014:3194":{"crate_id":5,"path":["alloc","collections","binary_heap","Drain"],"kind":"struct"},"41:11503:19308":{"crate_id":41,"path":["object","elf","Rela32"],"kind":"struct"},"2:2469:3336":{"crate_id":2,"path":["core","convert","num","private","Sealed"],"kind":"trait"},"6:4707:13513":{"crate_id":6,"path":["libc","unix","linux_like","linux","posix_spawnattr_t"],"kind":"struct"},"40:3640:15460":{"crate_id":40,"path":["gimli","arch","X86_64"],"kind":"struct"},"18:113:20648":{"crate_id":18,"path":["memchr","memchr","iter","Memchr3"],"kind":"struct"},"6:4318:13476":{"crate_id":6,"path":["libc","unix","linux_like","linux","spwd"],"kind":"struct"},"40:6943:16405":{"crate_id":40,"path":["gimli","read","loclists","RawLocListEntry"],"kind":"enum"},"41:12235:19829":{"crate_id":41,"path":["object","macho","SymtabCommand"],"kind":"struct"},"1:1583:3211":{"crate_id":1,"path":["std","collections","hash","set","Difference"],"kind":"struct"},"40:3030:15453":{"crate_id":40,"path":["gimli","common","DwoId"],"kind":"struct"},"1:7932:27442":{"crate_id":1,"path":["std","io","error","SimpleMessage"],"kind":"struct"},"41:10125:16695":{"crate_id":41,"path":["object","read","macho","file","MachOComdatIterator"],"kind":"struct"},"48:7126:22466":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_rsrc_update2"],"kind":"struct"},"2:12382:9058":{"crate_id":2,"path":["core","future","poll_fn","PollFn"],"kind":"struct"},"2:43561:8924":{"crate_id":2,"path":["core","str","iter","Matches"],"kind":"struct"},"2:46158:32744":{"crate_id":2,"path":["core","core_arch","simd","m16x8"],"kind":"struct"},"40:6868:37685":{"crate_id":40,"path":["gimli","read","lists","ListsHeader"],"kind":"struct"},"6:5809:14180":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","cmsghdr"],"kind":"struct"},"2:9107:3286":{"crate_id":2,"path":["core","fmt","Write"],"kind":"trait"},"40:6919:37679":{"crate_id":40,"path":["gimli","read","loclists","LocListsFormat"],"kind":"enum"},"32:7385:14182":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","nl_pktinfo"],"kind":"struct"},"2:40121:3290":{"crate_id":2,"path":["core","ffi","c_str","FromBytesWithNulError"],"kind":"struct"},"1:8776:3545":{"crate_id":1,"path":["std","process","ExitCode"],"kind":"struct"},"2:21879:32606":{"crate_id":2,"path":["core","num","flt2dec","decoder","FullDecoded"],"kind":"enum"},"2:40102:9030":{"crate_id":2,"path":["core","char","TryFromCharError"],"kind":"struct"},"2:45367:3650":{"crate_id":2,"path":["core","core_arch","simd","i8x2"],"kind":"struct"},"32:770:10041":{"crate_id":32,"path":["libc","unix","protoent"],"kind":"struct"},"32:7701:14196":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","ptrace_syscall_info"],"kind":"struct"},"41:10769:16750":{"crate_id":41,"path":["object","read","pe","resource","ResourceNameOrId"],"kind":"enum"},"11:1859:3210":{"crate_id":11,"path":["hashbrown","set","Intersection"],"kind":"struct"},"2:20982:3336":{"crate_id":2,"path":["core","core_simd","lane_count","sealed","Sealed"],"kind":"trait"},"16:7743:16432":{"crate_id":16,"path":["gimli","read","unit","DebugInfo"],"kind":"struct"},"6:4559:13502":{"crate_id":6,"path":["libc","unix","linux_like","linux","dl_phdr_info"],"kind":"struct"},"17:9826:16590":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdatIterator"],"kind":"struct"},"2:2506:75":{"crate_id":2,"path":["core","convert","AsRef"],"kind":"trait"},"41:11710:19323":{"crate_id":41,"path":["object","elf","GnuHashHeader"],"kind":"struct"},"6:5077:13555":{"crate_id":6,"path":["libc","unix","linux_like","linux","sockaddr_can"],"kind":"struct"},"5:780:96":{"crate_id":5,"path":["alloc","collections","binary_heap","BinaryHeap"],"kind":"struct"},"41:3142:16661":{"crate_id":41,"path":["object","read","macho","symbol","MachOSymbolIterator"],"kind":"struct"},"41:9896:16589":{"crate_id":41,"path":["object","read","elf","comdat","ElfComdat"],"kind":"struct"},"36:123:23969":{"crate_id":36,"path":["backtrace","print","BacktraceFrameFmt"],"kind":"struct"},"47:438:9009":{"crate_id":47,"path":["rustix","backend","io","epoll","Ref"],"kind":"struct"},"40:5367:15395":{"crate_id":40,"path":["gimli","endianity","RunTimeEndian"],"kind":"enum"},"2:44347:161":{"crate_id":2,"path":["core","alloc","layout","Layout"],"kind":"struct"},"32:8306:10076":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","sigaction"],"kind":"struct"},"41:9437:16560":{"crate_id":41,"path":["object","read","archive","ArchiveKind"],"kind":"enum"},"2:21916:32733":{"crate_id":2,"path":["core","num","fmt","Part"],"kind":"enum"},"34:5980:10027":{"crate_id":34,"path":["linux_raw_sys","general","timeval"],"kind":"struct"},"32:5201:13493":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_constant_effect"],"kind":"struct"},"6:1908:11107":{"crate_id":6,"path":["libc","unix","linux_like","linux","fpos64_t"],"kind":"enum"},"41:1843:16605":{"crate_id":41,"path":["object","read","elf","symbol","Sym"],"kind":"trait"},"48:4957:10942":{"crate_id":48,"path":["linux_raw_sys","general","ip_mreqn"],"kind":"struct"},"33:3543:39633":{"crate_id":33,"path":["rustix","backend","time","types","DynamicClockId"],"kind":"enum"},"34:7147:22454":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_op"],"kind":"enum"},"41:3871:16708":{"crate_id":41,"path":["object","read","pe","import","ImageThunkData"],"kind":"trait"},"2:2706:3151":{"crate_id":2,"path":["core","marker","PhantomData"],"kind":"struct"},"40:2862:15448":{"crate_id":40,"path":["gimli","common","DebugTypeSignature"],"kind":"struct"},"42:707:8905":{"crate_id":42,"path":["memchr","memmem","Searcher"],"kind":"struct"},"21:179:9015":{"crate_id":21,"path":["once_cell","sync","OnceCell"],"kind":"struct"},"1:643:3171":{"crate_id":1,"path":["std","backtrace","BytesOrWide"],"kind":"enum"},"6:4719:13514":{"crate_id":6,"path":["libc","unix","linux_like","linux","genlmsghdr"],"kind":"struct"},"20:2947:39020":{"crate_id":20,"path":["clap_builder","builder","app_settings","AppFlags"],"kind":"struct"},"34:7388:22460":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_params"],"kind":"struct"},"48:7261:22484":{"crate_id":48,"path":["linux_raw_sys","general","__old_kernel_stat"],"kind":"struct"},"1:1572:3195":{"crate_id":1,"path":["std","collections","hash","set","DrainFilter"],"kind":"struct"},"17:12522:19851":{"crate_id":17,"path":["object","macho","FvmfileCommand"],"kind":"struct"},"20:0:1707":{"crate_id":20,"path":["clap_builder"],"kind":"module"},"34:6119:22396":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_3"],"kind":"struct"},"17:13506:20611":{"crate_id":17,"path":["object","pe","ImageEpilogueDynamicRelocationHeader"],"kind":"struct"},"1:1565:3191":{"crate_id":1,"path":["std","collections","hash","set","IntoIter"],"kind":"struct"},"1:8147:3362":{"crate_id":1,"path":["std","io","Split"],"kind":"struct"},"32:7645:14193":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_entry"],"kind":"struct"},"34:5340:13517":{"crate_id":34,"path":["linux_raw_sys","general","inotify_event"],"kind":"struct"},"32:5853:13523":{"crate_id":32,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_j1939"],"kind":"struct"},"2:9813:222":{"crate_id":2,"path":["core","slice","index","SliceIndex"],"kind":"trait"},"2:45622:3658":{"crate_id":2,"path":["core","core_arch","simd","i16x4"],"kind":"struct"},"32:6220:13541":{"crate_id":32,"path":["libc","unix","linux_like","linux","sctp_authinfo"],"kind":"struct"},"34:7649:22476":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_buf_ring__bindgen_ty_1__bindgen_ty_2__bindgen_ty_1"],"kind":"struct"},"2:44112:9426":{"crate_id":2,"path":["core","time","Nanoseconds"],"kind":"struct"},"6:6700:14609":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_xmmreg"],"kind":"struct"},"48:5913:14114":{"crate_id":48,"path":["linux_raw_sys","general","statx"],"kind":"struct"},"32:9505:15149":{"crate_id":32,"path":["libc","unix","linux_like","linux","arch","generic","termios2"],"kind":"struct"},"34:6286:13389":{"crate_id":34,"path":["linux_raw_sys","general","sysinfo"],"kind":"struct"},"16:4445:15972":{"crate_id":16,"path":["gimli","constants","DwAte"],"kind":"struct"},"16:8047:16439":{"crate_id":16,"path":["gimli","read","unit","AttrsIter"],"kind":"struct"},"5:1612:35280":{"crate_id":5,"path":["alloc","collections","btree","map","drop","DropGuard"],"kind":"struct"},"1:3401:3332":{"crate_id":1,"path":["std","io","IoSliceMut"],"kind":"struct"},"11:1634:37589":{"crate_id":11,"path":["hashbrown","scopeguard","ScopeGuard"],"kind":"struct"},"40:6146:194":{"crate_id":40,"path":["gimli","read","cfi","Pointer"],"kind":"enum"},"2:22227:178":{"crate_id":2,"path":["core","num","nonzero","NonZeroU8"],"kind":"struct"},"1:11902:743":{"crate_id":1,"path":["std","i32"],"kind":"primitive"},"2:40277:9213":{"crate_id":2,"path":["core","iter","adapters","copied","Copied"],"kind":"struct"},"48:6660:22442":{"crate_id":48,"path":["linux_raw_sys","general","uffdio_zeropage"],"kind":"struct"},"20:4495:20711":{"crate_id":20,"path":["clap_builder","parser","matches","value_source","ValueSource"],"kind":"enum"},"41:13621:20613":{"crate_id":41,"path":["object","pe","ImageLoadConfigDirectory64"],"kind":"struct"},"2:8250:3511":{"crate_id":2,"path":["core","panic","unwind_safe","RefUnwindSafe"],"kind":"trait"},"17:10283:16658":{"crate_id":17,"path":["object","read","macho","segment","MachOSegmentInternal"],"kind":"struct"},"41:13682:20615":{"crate_id":41,"path":["object","pe","ImageHotPatchBase"],"kind":"struct"},"16:4728:16063":{"crate_id":16,"path":["gimli","constants","DwAddr"],"kind":"struct"},"16:5643:16351":{"crate_id":16,"path":["gimli","read","cfi","EhHdrTable"],"kind":"struct"},"1:7595:3149":{"crate_id":1,"path":["std","thread","ThreadId"],"kind":"struct"},"5:7060:35125":{"crate_id":5,"path":["alloc","collections","btree","set_val","SetValZST"],"kind":"struct"},"2:30266:8967":{"crate_id":2,"path":["core","mem","maybe_uninit","MaybeUninit"],"kind":"union"},"17:13763:20625":{"crate_id":17,"path":["object","pe","ImageDebugDirectory"],"kind":"struct"},"2:11672:3530":{"crate_id":2,"path":["core","str","traits","FromStr"],"kind":"trait"},"40:4757:16068":{"crate_id":40,"path":["gimli","constants","DwId"],"kind":"struct"},"41:11936:19810":{"crate_id":41,"path":["object","macho","LoadCommand"],"kind":"struct"},"27:0:2633":{"crate_id":27,"path":["anstyle_parse"],"kind":"module"},"2:30360:32757":{"crate_id":2,"path":["core","ptr","alignment","AlignmentEnum32"],"kind":"enum"},"40:7626:16426":{"crate_id":40,"path":["gimli","read","rnglists","RngListIter"],"kind":"struct"},"17:12224:19831":{"crate_id":17,"path":["object","macho","DylibTableOfContents"],"kind":"struct"},"6:5773:14176":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__exit_status"],"kind":"struct"},"2:4782:34274":{"crate_id":2,"path":["core","ffi","sealed_trait","VaArgSafe"],"kind":"trait"},"16:4789:16076":{"crate_id":16,"path":["gimli","constants","DwCc"],"kind":"struct"},"1:5334:3536":{"crate_id":1,"path":["std","process","ChildStdin"],"kind":"struct"},"40:4904:16095":{"crate_id":40,"path":["gimli","constants","DwIdx"],"kind":"struct"},"34:5088:22350":{"crate_id":34,"path":["linux_raw_sys","general","fsxattr"],"kind":"struct"},"48:5586:22387":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_timespec"],"kind":"struct"},"41:8477:16518":{"crate_id":41,"path":["object","common","SymbolScope"],"kind":"enum"},"41:9481:16562":{"crate_id":41,"path":["object","read","archive","ArchiveFile"],"kind":"struct"},"32:1859:10948":{"crate_id":32,"path":["libc","unix","linux_like","sockaddr_ll"],"kind":"struct"},"18:507:38764":{"crate_id":18,"path":["memchr","memmem","genericsimd","Forward"],"kind":"struct"},"6:5935:14187":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","ntptimeval"],"kind":"struct"},"16:7543:16422":{"crate_id":16,"path":["gimli","read","rnglists","DebugRngLists"],"kind":"struct"},"6:6651:10881":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs64"],"kind":"struct"},"16:2862:15448":{"crate_id":16,"path":["gimli","common","DebugTypeSignature"],"kind":"struct"},"41:9285:38757":{"crate_id":41,"path":["object","read","any","SymbolTableInternal"],"kind":"enum"},"17:11821:16699":{"crate_id":17,"path":["object","macho","FatArch32"],"kind":"struct"},"17:10989:16549":{"crate_id":17,"path":["object","read","Export"],"kind":"struct"},"49:0:2643":{"crate_id":49,"path":["unicode_width"],"kind":"module"},"18:491:20718":{"crate_id":18,"path":["memchr","cow","Imp"],"kind":"struct"},"2:7202:152":{"crate_id":2,"path":["core","iter","traits","collect","IntoIterator"],"kind":"trait"},"1:480:26940":{"crate_id":1,"path":["std","thread","spawn_unchecked_","MaybeDangling"],"kind":"struct"},"33:477:20862":{"crate_id":33,"path":["rustix","backend","io","epoll","EventVec"],"kind":"struct"},"17:13145:20577":{"crate_id":17,"path":["object","pe","ImageSymbolEx"],"kind":"struct"},"17:247:38730":{"crate_id":17,"path":["object","read","util","DebugLen"],"kind":"struct"},"41:8605:16522":{"crate_id":41,"path":["object","common","SegmentFlags"],"kind":"enum"},"31:137:20810":{"crate_id":31,"path":["io_lifetimes","raw","IntoRawFilelike"],"kind":"trait"},"17:8283:16514":{"crate_id":17,"path":["object","common","BinaryFormat"],"kind":"enum"},"32:6335:13551":{"crate_id":32,"path":["libc","unix","linux_like","linux","ifreq"],"kind":"struct"},"2:2264:105":{"crate_id":2,"path":["core","clone","Clone"],"kind":"trait"},"6:4845:13530":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlmsgerr"],"kind":"struct"},"24:232:20733":{"crate_id":24,"path":["unicase","Ascii"],"kind":"struct"},"32:5775:13519":{"crate_id":32,"path":["libc","unix","linux_like","linux","sockaddr_vm"],"kind":"struct"},"41:10411:16662":{"crate_id":41,"path":["object","read","macho","symbol","MachOSymbolTable"],"kind":"struct"},"1:8825:3581":{"crate_id":1,"path":["std","sync","mpsc","RecvError"],"kind":"struct"},"17:11090:16553":{"crate_id":17,"path":["object","read","CompressedFileRange"],"kind":"struct"},"17:9488:16580":{"crate_id":17,"path":["object","read","coff","file","CoffFile"],"kind":"struct"},"11:1050:15343":{"crate_id":11,"path":["hashbrown","map","EntryRef"],"kind":"enum"},"2:43223:8872":{"crate_id":2,"path":["core","slice","iter","ArrayChunksMut"],"kind":"struct"},"17:9498:16579":{"crate_id":17,"path":["object","read","coff","section","SectionTable"],"kind":"struct"},"2:40196:3305":{"crate_id":2,"path":["core","ffi","VaListImpl"],"kind":"struct"},"41:10434:16660":{"crate_id":41,"path":["object","read","macho","symbol","MachOSymbol"],"kind":"struct"},"6:6814:14616":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","seccomp_notif_sizes"],"kind":"struct"},"40:2426:15430":{"crate_id":40,"path":["gimli","common","DebugAddrIndex"],"kind":"struct"},"41:9740:16594":{"crate_id":41,"path":["object","read","elf","segment","ElfSegment"],"kind":"struct"},"32:6355:13554":{"crate_id":32,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_can_addr"],"kind":"union"},"17:10416:16738":{"crate_id":17,"path":["object","read","pe","file","PeComdatIterator"],"kind":"struct"},"48:4742:22346":{"crate_id":48,"path":["linux_raw_sys","general","file_dedupe_range_info"],"kind":"struct"},"34:5319:10954":{"crate_id":34,"path":["linux_raw_sys","general","in_pktinfo"],"kind":"struct"},"41:3205:16663":{"crate_id":41,"path":["object","read","macho","symbol","Nlist"],"kind":"trait"},"48:5880:10964":{"crate_id":48,"path":["linux_raw_sys","general","sigevent"],"kind":"struct"},"16:5998:16366":{"crate_id":16,"path":["gimli","read","cfi","CfaRule"],"kind":"enum"},"1:2344:3311":{"crate_id":1,"path":["std","fs","metadata"],"kind":"function"},"2:7591:3222":{"crate_id":2,"path":["core","iter","traits","marker","TrustedLen"],"kind":"trait"},"48:4588:22334":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_key"],"kind":"struct"},"32:5480:13506":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf64_Sym"],"kind":"struct"},"1:1768:610":{"crate_id":1,"path":["std","env"],"kind":"module"},"32:7824:14225":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","sigset_t"],"kind":"struct"},"16:6671:15370":{"crate_id":16,"path":["gimli","read","line","LineRow"],"kind":"struct"},"48:5618:22391":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_old_itimerval"],"kind":"struct"},"48:5079:22368":{"crate_id":48,"path":["linux_raw_sys","general","ip_esp_hdr"],"kind":"struct"},"34:6544:22419":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_6"],"kind":"enum"},"48:5610:22390":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_old_timespec"],"kind":"struct"},"17:9959:16645":{"crate_id":17,"path":["object","read","elf","version","VerdauxIterator"],"kind":"struct"},"32:7627:14192":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","ptrace_peeksiginfo_args"],"kind":"struct"},"17:12449:19846":{"crate_id":17,"path":["object","macho","BuildToolVersion"],"kind":"struct"},"2:2741:2675":{"crate_id":2,"path":["core","marker","Unpin"],"kind":"trait"},"6:573:10038":{"crate_id":6,"path":["libc","unix","itimerval"],"kind":"struct"},"20:59:2661":{"crate_id":20,"path":["clap_builder","derive","FromArgMatches"],"kind":"trait"},"32:5945:13528":{"crate_id":32,"path":["libc","unix","linux_like","linux","seccomp_data"],"kind":"struct"},"37:187:15362":{"crate_id":37,"path":["rustc_demangle","SizeLimitedFmtAdapter"],"kind":"struct"},"16:6520:16390":{"crate_id":16,"path":["gimli","read","index","UnitIndexSection"],"kind":"struct"},"41:3463:16724":{"crate_id":41,"path":["object","read","pe","file","ImageNtHeaders"],"kind":"trait"},"41:12316:19833":{"crate_id":41,"path":["object","macho","DylibModule64"],"kind":"struct"},"16:5741:16357":{"crate_id":16,"path":["gimli","read","cfi","CieOrFde"],"kind":"enum"},"48:6421:3451":{"crate_id":48,"path":["linux_raw_sys","general","sockaddr_un"],"kind":"struct"},"5:5191:35280":{"crate_id":5,"path":["alloc","slice","hack","to_vec","DropGuard"],"kind":"struct"},"32:4952:13481":{"crate_id":32,"path":["libc","unix","linux_like","linux","packet_mreq"],"kind":"struct"},"42:736:20661":{"crate_id":42,"path":["memchr","memmem","SearcherKind"],"kind":"enum"},"16:8269:128":{"crate_id":16,"path":["gimli","read","Error"],"kind":"enum"},"2:2749:9241":{"crate_id":2,"path":["core","marker","FnPtr"],"kind":"trait"},"28:23:15262":{"crate_id":28,"path":["utf8parse","types","Action"],"kind":"enum"},"17:2933:16656":{"crate_id":17,"path":["object","read","macho","section","MachOSectionIterator"],"kind":"struct"},"25:0:2631":{"crate_id":25,"path":["anstyle"],"kind":"module"},"17:13426:20602":{"crate_id":17,"path":["object","pe","ImageResourceDirStringU"],"kind":"struct"},"41:13545:20609":{"crate_id":41,"path":["object","pe","ImageDynamicRelocation64V2"],"kind":"struct"},"5:1995:3229":{"crate_id":5,"path":["alloc","collections","btree","map","CursorMut"],"kind":"struct"},"33:5053:39548":{"crate_id":33,"path":["rustix","process","wait","WaitidOptions"],"kind":"struct"},"42:507:38764":{"crate_id":42,"path":["memchr","memmem","genericsimd","Forward"],"kind":"struct"},"40:5811:16359":{"crate_id":40,"path":["gimli","read","cfi","CommonInformationEntry"],"kind":"struct"},"40:7488:16417":{"crate_id":40,"path":["gimli","read","pubnames","PubNamesEntryIter"],"kind":"struct"},"2:2929:2678":{"crate_id":2,"path":["core","ops","function","FnMut"],"kind":"trait"},"2:21718:32462":{"crate_id":2,"path":["core","num","bignum","tests","Big8x3"],"kind":"struct"},"39:281:3508":{"crate_id":39,"path":["addr2line","Location"],"kind":"struct"},"1:3973:3430":{"crate_id":1,"path":["std","os","unix","fs","FileTypeExt"],"kind":"trait"},"32:682:10036":{"crate_id":32,"path":["libc","unix","linger"],"kind":"struct"},"47:4810:39613":{"crate_id":47,"path":["rustix","process","prctl","PTracer"],"kind":"enum"},"17:8389:16517":{"crate_id":17,"path":["object","common","SymbolKind"],"kind":"enum"},"1:8264:3495":{"crate_id":1,"path":["std","os","linux","raw","arch","stat"],"kind":"struct"},"1:4074:31350":{"crate_id":1,"path":["std","os","unix","net","ancillary","AncillaryDataIter"],"kind":"struct"},"41:13081:20569":{"crate_id":41,"path":["object","pe","ImageNtHeaders32"],"kind":"struct"},"32:509:10027":{"crate_id":32,"path":["libc","unix","timeval"],"kind":"struct"},"2:44291:195":{"crate_id":2,"path":["core","task","poll","Poll"],"kind":"enum"},"41:10818:16539":{"crate_id":41,"path":["object","read","FileKind"],"kind":"enum"},"40:6717:15369":{"crate_id":40,"path":["gimli","read","line","LineSequence"],"kind":"struct"},"41:11577:19313":{"crate_id":41,"path":["object","elf","Dyn32"],"kind":"struct"},"2:41606:183":{"crate_id":2,"path":["core","sync","atomic","Ordering"],"kind":"enum"},"16:6819:16399":{"crate_id":16,"path":["gimli","read","line","FileEntry"],"kind":"struct"},"48:4660:22342":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_get_key_status_arg"],"kind":"struct"},"32:4878:13478":{"crate_id":32,"path":["libc","unix","linux_like","linux","signalfd_siginfo"],"kind":"struct"},"5:7030:35407":{"crate_id":5,"path":["alloc","collections","btree","merge_iter","Peeked"],"kind":"enum"},"41:13755:20622":{"crate_id":41,"path":["object","pe","ImageEnclaveConfig32"],"kind":"struct"},"40:2319:15425":{"crate_id":40,"path":["gimli","common","Encoding"],"kind":"struct"},"48:6325:22422":{"crate_id":48,"path":["linux_raw_sys","general","tcp_zerocopy_receive"],"kind":"struct"},"2:43245:8891":{"crate_id":2,"path":["core","slice","iter","RChunksMut"],"kind":"struct"},"34:7721:22481":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_file_index_range"],"kind":"struct"},"34:6323:22411":{"crate_id":34,"path":["linux_raw_sys","general","tcp_word_hdr"],"kind":"union"},"32:5524:13508":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf64_Phdr"],"kind":"struct"},"16:4932:16099":{"crate_id":16,"path":["gimli","constants","DwDefaulted"],"kind":"struct"},"34:7913:10960":{"crate_id":34,"path":["linux_raw_sys","general","mmsghdr"],"kind":"struct"},"40:2298:15397":{"crate_id":40,"path":["gimli","common","Format"],"kind":"enum"},"6:579:10039":{"crate_id":6,"path":["libc","unix","tms"],"kind":"struct"},"34:5112:22352":{"crate_id":34,"path":["linux_raw_sys","general","robust_list"],"kind":"struct"},"9:388:15224":{"crate_id":9,"path":["miniz_oxide","MZFlush"],"kind":"enum"},"17:8360:16516":{"crate_id":17,"path":["object","common","ComdatKind"],"kind":"enum"},"41:9791:16592":{"crate_id":41,"path":["object","read","elf","section","ElfSection"],"kind":"struct"},"5:1463:3227":{"crate_id":5,"path":["alloc","collections","btree","map","RangeMut"],"kind":"struct"},"41:4128:3336":{"crate_id":41,"path":["object","read","private","Sealed"],"kind":"trait"},"17:11484:19311":{"crate_id":17,"path":["object","elf","ProgramHeader32"],"kind":"struct"},"5:2077:3137":{"crate_id":5,"path":["alloc","collections","btree","mem","replace","PanicGuard"],"kind":"struct"},"32:5597:3423":{"crate_id":32,"path":["libc","unix","linux_like","linux","ucred"],"kind":"struct"},"48:5002:22361":{"crate_id":48,"path":["linux_raw_sys","general","group_source_req"],"kind":"struct"},"6:5900:14186":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","timex"],"kind":"struct"},"2:42498:73":{"crate_id":2,"path":["core","fmt","Arguments"],"kind":"struct"},"2:14:2609":{"crate_id":2,"path":["core","write"],"kind":"macro"},"2:25847:3414":{"crate_id":2,"path":["core","num","wrapping","Wrapping"],"kind":"struct"},"34:5996:10038":{"crate_id":34,"path":["linux_raw_sys","general","itimerval"],"kind":"struct"},"6:6785:14614":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ipc_perm"],"kind":"struct"},"32:6020:13532":{"crate_id":32,"path":["libc","unix","linux_like","linux","file_clone_range"],"kind":"struct"},"17:9721:16593":{"crate_id":17,"path":["object","read","elf","section","ElfSectionIterator"],"kind":"struct"},"41:12856:20560":{"crate_id":41,"path":["object","pe","ImageOs2Header"],"kind":"struct"},"2:42458:68":{"crate_id":2,"path":["core","fmt","Alignment"],"kind":"enum"},"1:8806:3583":{"crate_id":1,"path":["std","sync","mpsc","SendError"],"kind":"struct"},"26:301:20763":{"crate_id":26,"path":["anstream","adapter","strip","StripBytesIter"],"kind":"struct"},"17:12835:20561":{"crate_id":17,"path":["object","pe","ImageVxdHeader"],"kind":"struct"},"6:4571:13503":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf32_Ehdr"],"kind":"struct"},"48:4575:22333":{"crate_id":48,"path":["linux_raw_sys","general","fscrypt_policy_v1"],"kind":"struct"},"32:526:10028":{"crate_id":32,"path":["libc","unix","timespec"],"kind":"struct"},"2:2317:125":{"crate_id":2,"path":["core","cmp","Eq"],"kind":"trait"},"2:45347:3685":{"crate_id":2,"path":["core","core_arch","simd","u8x2"],"kind":"struct"},"9:0:2492":{"crate_id":9,"path":["miniz_oxide"],"kind":"module"},"47:5075:39537":{"crate_id":47,"path":["rustix","process","prctl","PointerAuthenticationKeys"],"kind":"struct"},"34:6926:22432":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"18:681:20665":{"crate_id":18,"path":["memchr","memmem","Finder"],"kind":"struct"},"40:5000:16119":{"crate_id":40,"path":["gimli","constants","DwLne"],"kind":"struct"},"41:11672:19320":{"crate_id":41,"path":["object","elf","NoteHeader32"],"kind":"struct"},"41:12026:19815":{"crate_id":41,"path":["object","macho","Section64"],"kind":"struct"},"48:6343:14181":{"crate_id":48,"path":["linux_raw_sys","general","termios"],"kind":"struct"},"2:43621:8921":{"crate_id":2,"path":["core","str","iter","LinesAny"],"kind":"struct"},"48:7318:22485":{"crate_id":48,"path":["linux_raw_sys","general","compat_statfs64"],"kind":"struct"},"32:5357:13501":{"crate_id":32,"path":["libc","unix","linux_like","linux","uinput_abs_setup"],"kind":"struct"},"11:2219:3187":{"crate_id":11,"path":["hashbrown","TryReserveError"],"kind":"enum"},"16:2594:15437":{"crate_id":16,"path":["gimli","common","DebugLocListsIndex"],"kind":"struct"},"16:6544:16391":{"crate_id":16,"path":["gimli","read","line","DebugLine"],"kind":"struct"},"1:6188:3577":{"crate_id":1,"path":["std","sync","mpmc","Sender"],"kind":"struct"},"2:43163:8882":{"crate_id":2,"path":["core","slice","iter","ChunksExact"],"kind":"struct"},"16:6728:16396":{"crate_id":16,"path":["gimli","read","line","LineProgramHeader"],"kind":"struct"},"1:8982:24355":{"crate_id":1,"path":["std","sync","mpmc","select","Selected"],"kind":"enum"},"32:6060:13534":{"crate_id":32,"path":["libc","unix","linux_like","linux","in6_ifreq"],"kind":"struct"},"32:715:10038":{"crate_id":32,"path":["libc","unix","itimerval"],"kind":"struct"},"41:13389:20593":{"crate_id":41,"path":["object","pe","ImageTlsDirectory64"],"kind":"struct"},"41:13433:20597":{"crate_id":41,"path":["object","pe","ImageBoundForwarderRef"],"kind":"struct"},"40:8129:16443":{"crate_id":40,"path":["gimli","read","unit","EntriesTreeNode"],"kind":"struct"},"20:1213:2982":{"crate_id":20,"path":["clap_builder","builder","value_parser","TypedValueParser"],"kind":"trait"},"33:3507:39619":{"crate_id":33,"path":["rustix","backend","time","types","ClockId"],"kind":"enum"},"48:5765:22394":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_1"],"kind":"struct"},"16:7293:16410":{"crate_id":16,"path":["gimli","read","op","Piece"],"kind":"struct"},"1:8762:3544":{"crate_id":1,"path":["std","process","ExitStatusError"],"kind":"struct"},"2:2932:2679":{"crate_id":2,"path":["core","ops","function","FnOnce"],"kind":"trait"},"2:45413:3691":{"crate_id":2,"path":["core","core_arch","simd","u16x2"],"kind":"struct"},"28:53:3524":{"crate_id":28,"path":["utf8parse","types","State"],"kind":"enum"},"32:5049:13485":{"crate_id":32,"path":["libc","unix","linux_like","linux","input_event"],"kind":"struct"},"32:4973:13482":{"crate_id":32,"path":["libc","unix","linux_like","linux","cpu_set_t"],"kind":"struct"},"2:43921:8944":{"crate_id":2,"path":["core","str","pattern","StrSearcher"],"kind":"struct"},"17:13367:20596":{"crate_id":17,"path":["object","pe","ImageBoundImportDescriptor"],"kind":"struct"},"34:7753:22483":{"crate_id":34,"path":["linux_raw_sys","general","linux_dirent64"],"kind":"struct"},"47:549:20862":{"crate_id":47,"path":["rustix","backend","io","epoll","EventVec"],"kind":"struct"},"47:2530:39689":{"crate_id":47,"path":["rustix","process","uname","Uname"],"kind":"struct"},"17:8256:16494":{"crate_id":17,"path":["object","common","AddressSize"],"kind":"enum"},"1:355:3160":{"crate_id":1,"path":["std","thread","scoped","Scope"],"kind":"struct"},"2:42160:8840":{"crate_id":2,"path":["core","fmt","num","Octal"],"kind":"struct"},"48:5674:10030":{"crate_id":48,"path":["linux_raw_sys","general","rusage"],"kind":"struct"},"41:8578:16521":{"crate_id":41,"path":["object","common","FileFlags"],"kind":"enum"},"40:3585:15459":{"crate_id":40,"path":["gimli","arch","X86"],"kind":"struct"},"48:6043:22414":{"crate_id":48,"path":["linux_raw_sys","general","tcp_repair_window"],"kind":"struct"},"17:13159:20578":{"crate_id":17,"path":["object","pe","ImageSymbolExBytes"],"kind":"struct"},"16:7669:16428":{"crate_id":16,"path":["gimli","read","str","DebugStr"],"kind":"struct"},"41:11685:19321":{"crate_id":41,"path":["object","elf","NoteHeader64"],"kind":"struct"},"11:1009:3205":{"crate_id":11,"path":["hashbrown","map","OccupiedEntry"],"kind":"struct"},"48:5666:10088":{"crate_id":48,"path":["linux_raw_sys","general","timezone"],"kind":"struct"},"17:242:38756":{"crate_id":17,"path":["object","read","util","DebugByte"],"kind":"struct"},"34:4780:22326":{"crate_id":34,"path":["linux_raw_sys","general","__user_cap_header_struct"],"kind":"struct"},"41:13456:20599":{"crate_id":41,"path":["object","pe","ImageResourceDirectory"],"kind":"struct"},"11:1540:15347":{"crate_id":11,"path":["hashbrown","rustc_entry","RustcOccupiedEntry"],"kind":"struct"},"2:2851:9277":{"crate_id":2,"path":["core","ops","bit","ShlAssign"],"kind":"trait"},"2:2151:589":{"crate_id":2,"path":["core","ptr","drop_in_place"],"kind":"function"},"6:4423:13485":{"crate_id":6,"path":["libc","unix","linux_like","linux","input_event"],"kind":"struct"},"17:9653:16609":{"crate_id":17,"path":["object","read","elf","file","ElfFile"],"kind":"struct"},"40:8047:16439":{"crate_id":40,"path":["gimli","read","unit","AttrsIter"],"kind":"struct"},"32:6244:13543":{"crate_id":32,"path":["libc","unix","linux_like","linux","dirent"],"kind":"struct"},"6:4398:13324":{"crate_id":6,"path":["libc","unix","linux_like","linux","if_nameindex"],"kind":"struct"},"1:8912:107":{"crate_id":1,"path":["std","sync","mpmc","context","Context"],"kind":"struct"},"17:8683:16499":{"crate_id":17,"path":["object","endian","U16Bytes"],"kind":"struct"},"1:7670:3209":{"crate_id":1,"path":["std","collections","hash","map","DefaultHasher"],"kind":"struct"},"2:9117:132":{"crate_id":2,"path":["core","fmt","Formatter"],"kind":"struct"},"1:11449:8816":{"crate_id":1,"path":["std","alloc","System"],"kind":"struct"},"6:5959:14189":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","Elf64_Chdr"],"kind":"struct"},"2:49668:3648":{"crate_id":2,"path":["core","core_simd","swizzle","Which"],"kind":"enum"},"47:4791:39677":{"crate_id":47,"path":["rustix","process","prctl","PrctlMmMap"],"kind":"struct"},"24:190:20735":{"crate_id":24,"path":["unicase","unicode","Unicode"],"kind":"struct"},"20:4484:20700":{"crate_id":20,"path":["clap_builder","parser","matches","matched_arg","MatchedArg"],"kind":"struct"},"16:7449:16414":{"crate_id":16,"path":["gimli","read","op","Evaluation"],"kind":"struct"},"47:3087:20837":{"crate_id":47,"path":["rustix","backend","io","types","ReadWriteFlags"],"kind":"struct"},"33:4454:39622":{"crate_id":33,"path":["rustix","process","prctl","TimeStampCounterReadability"],"kind":"enum"},"17:12158:19828":{"crate_id":17,"path":["object","macho","RoutinesCommand64"],"kind":"struct"},"42:599:38773":{"crate_id":42,"path":["memchr","memmem","twoway","Shift"],"kind":"enum"},"40:2830:15447":{"crate_id":40,"path":["gimli","common","DebugTypesOffset"],"kind":"struct"},"5:863:3216":{"crate_id":5,"path":["alloc","collections","binary_heap","Hole"],"kind":"struct"},"16:6022:16367":{"crate_id":16,"path":["gimli","read","cfi","RegisterRule"],"kind":"enum"},"11:783:15341":{"crate_id":11,"path":["hashbrown","map","ConsumeAllOnDrop"],"kind":"struct"},"41:10738:16747":{"crate_id":41,"path":["object","read","pe","resource","ResourceDirectoryTable"],"kind":"struct"},"42:113:20648":{"crate_id":42,"path":["memchr","memchr","iter","Memchr3"],"kind":"struct"},"41:10360:16654":{"crate_id":41,"path":["object","read","macho","section","MachOSection"],"kind":"struct"},"34:5859:22384":{"crate_id":34,"path":["linux_raw_sys","general","socket_state"],"kind":"enum"},"16:6890:16402":{"crate_id":16,"path":["gimli","read","loclists","DebugLocLists"],"kind":"struct"},"41:2834:16511":{"crate_id":41,"path":["object","read","macho","segment","Segment"],"kind":"trait"},"41:8810:16525":{"crate_id":41,"path":["object","endian","U64Bytes"],"kind":"struct"},"48:6054:22415":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_5"],"kind":"enum"},"9:445:15223":{"crate_id":9,"path":["miniz_oxide","MZError"],"kind":"enum"},"41:12476:19844":{"crate_id":41,"path":["object","macho","VersionMinCommand"],"kind":"struct"},"17:13651:20617":{"crate_id":17,"path":["object","pe","ImageArmRuntimeFunctionEntry"],"kind":"struct"},"48:7167:22472":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_restriction__bindgen_ty_1"],"kind":"union"},"5:4321:245":{"crate_id":5,"path":["alloc","collections","vec_deque","VecDeque"],"kind":"struct"},"37:160:15354":{"crate_id":37,"path":["rustc_demangle","Demangle"],"kind":"struct"},"41:12129:19822":{"crate_id":41,"path":["object","macho","SubUmbrellaCommand"],"kind":"struct"},"34:7577:22468":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_notification_register"],"kind":"struct"},"6:1519:10941":{"crate_id":6,"path":["libc","unix","linux_like","ip_mreq"],"kind":"struct"},"41:975:16577":{"crate_id":41,"path":["object","read","coff","symbol","CoffSymbolIterator"],"kind":"struct"},"1:11162:24648":{"crate_id":1,"path":["std","sys_common","process","CommandEnv"],"kind":"struct"},"20:4946:2657":{"crate_id":20,"path":["clap_builder","util","color","ColorChoice"],"kind":"enum"},"48:5521:22384":{"crate_id":48,"path":["linux_raw_sys","general","socket_state"],"kind":"enum"},"17:8718:16500":{"crate_id":17,"path":["object","endian","U32Bytes"],"kind":"struct"},"2:43184:8873":{"crate_id":2,"path":["core","slice","iter","ArrayWindows"],"kind":"struct"},"40:5104:16151":{"crate_id":40,"path":["gimli","constants","DwRle"],"kind":"struct"},"18:707:8905":{"crate_id":18,"path":["memchr","memmem","Searcher"],"kind":"struct"},"6:4667:13510":{"crate_id":6,"path":["libc","unix","linux_like","linux","Elf64_Shdr"],"kind":"struct"},"40:6990:16407":{"crate_id":40,"path":["gimli","read","loclists","LocationListEntry"],"kind":"struct"},"6:587:10040":{"crate_id":6,"path":["libc","unix","servent"],"kind":"struct"},"17:9772:16598":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbolTable"],"kind":"struct"},"32:9701:15177":{"crate_id":32,"path":["libc","unix","linux_like","linux","non_exhaustive","open_how"],"kind":"struct"},"41:13037:20567":{"crate_id":41,"path":["object","pe","ImageOptionalHeader64"],"kind":"struct"},"41:13914:20632":{"crate_id":41,"path":["object","pe","ImageArchitectureEntry"],"kind":"struct"},"48:6717:22448":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_3"],"kind":"union"},"1:6236:206":{"crate_id":1,"path":["std","sync","mpmc","Receiver"],"kind":"struct"},"2:43989:8929":{"crate_id":2,"path":["core","str","lossy","Utf8Chunks"],"kind":"struct"},"48:5896:22409":{"crate_id":48,"path":["linux_raw_sys","general","sigevent__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"18:521:20670":{"crate_id":18,"path":["memchr","memmem","prefilter","Prefilter"],"kind":"enum"},"40:6442:16385":{"crate_id":40,"path":["gimli","read","aranges","ArangeEntry"],"kind":"struct"},"20:4611:39069":{"crate_id":20,"path":["clap_builder","parser","parser","ParseResult"],"kind":"enum"},"16:6876:16401":{"crate_id":16,"path":["gimli","read","loclists","DebugLoc"],"kind":"struct"},"17:12419:19844":{"crate_id":17,"path":["object","macho","VersionMinCommand"],"kind":"struct"},"34:4934:22338":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_key_specifier"],"kind":"struct"},"41:13746:20621":{"crate_id":41,"path":["object","pe","ImageRuntimeFunctionEntry"],"kind":"struct"},"1:9877:26099":{"crate_id":1,"path":["std","sys","unix","net","Socket"],"kind":"struct"},"32:5165:13491":{"crate_id":32,"path":["libc","unix","linux_like","linux","ff_trigger"],"kind":"struct"},"17:9839:16589":{"crate_id":17,"path":["object","read","elf","comdat","ElfComdat"],"kind":"struct"},"16:6236:16372":{"crate_id":16,"path":["gimli","read","dwarf","RangeIter"],"kind":"struct"},"32:9688:13709":{"crate_id":32,"path":["libc","unix","linux_like","linux","canfd_frame"],"kind":"struct"},"17:8788:16526":{"crate_id":17,"path":["object","endian","I16Bytes"],"kind":"struct"},"20:4072:2975":{"crate_id":20,"path":["clap_builder","builder","value_parser","NonEmptyStringValueParser"],"kind":"struct"},"2:5586:9214":{"crate_id":2,"path":["core","iter","adapters","flatten","Flatten"],"kind":"struct"},"34:4753:22324":{"crate_id":34,"path":["linux_raw_sys","general","__IncompleteArrayField"],"kind":"struct"},"2:11279:8911":{"crate_id":2,"path":["core","str","converts","from_utf8"],"kind":"function"},"33:3874:39545":{"crate_id":33,"path":["rustix","process","membarrier","MembarrierQuery"],"kind":"struct"},"33:5167:39584":{"crate_id":33,"path":["rustix","process","wait","WaitidStatus"],"kind":"struct"},"48:5946:13389":{"crate_id":48,"path":["linux_raw_sys","general","sysinfo"],"kind":"struct"},"16:5616:16349":{"crate_id":16,"path":["gimli","read","cfi","ParsedEhFrameHdr"],"kind":"struct"},"48:7369:14180":{"crate_id":48,"path":["linux_raw_sys","general","cmsghdr"],"kind":"struct"},"40:6164:37696":{"crate_id":40,"path":["gimli","read","cfi","PointerEncodingParameters"],"kind":"struct"},"48:7106:22464":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_rsrc_register"],"kind":"struct"},"26:163:20756":{"crate_id":26,"path":["anstream","raw","RawStream"],"kind":"trait"},"2:42174:8849":{"crate_id":2,"path":["core","fmt","num","UpperHex"],"kind":"struct"},"2:39379:8993":{"crate_id":2,"path":["core","array","TryFromSliceError"],"kind":"struct"},"40:6671:15370":{"crate_id":40,"path":["gimli","read","line","LineRow"],"kind":"struct"},"34:7078:22449":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_4"],"kind":"union"},"2:43956:8947":{"crate_id":2,"path":["core","str","pattern","TwoWaySearcher"],"kind":"struct"},"15:0:2497":{"crate_id":15,"path":["addr2line"],"kind":"module"},"48:7338:22486":{"crate_id":48,"path":["linux_raw_sys","general","user_desc"],"kind":"struct"},"2:47526:3722":{"crate_id":2,"path":["core","core_arch","simd","f32x16"],"kind":"struct"},"34:5618:22377":{"crate_id":34,"path":["linux_raw_sys","general","rt2_hdr"],"kind":"struct"},"34:7567:22467":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_notification_slot"],"kind":"struct"},"6:506:10030":{"crate_id":6,"path":["libc","unix","rusage"],"kind":"struct"},"16:2319:15425":{"crate_id":16,"path":["gimli","common","Encoding"],"kind":"struct"},"16:6767:16397":{"crate_id":16,"path":["gimli","read","line","IncompleteLineProgram"],"kind":"struct"},"2:45792:3693":{"crate_id":2,"path":["core","core_arch","simd","u16x8"],"kind":"struct"},"34:5275:10943":{"crate_id":34,"path":["linux_raw_sys","general","ip_mreq_source"],"kind":"struct"},"1:8485:3528":{"crate_id":1,"path":["std","path","Ancestors"],"kind":"struct"},"6:5755:14175":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","aiocb"],"kind":"struct"},"6:4836:13529":{"crate_id":6,"path":["libc","unix","linux_like","linux","nlmsghdr"],"kind":"struct"},"11:1035:3206":{"crate_id":11,"path":["hashbrown","map","VacantEntry"],"kind":"struct"},"2:4808:795":{"crate_id":2,"path":["core","iter"],"kind":"module"},"1:4737:3445":{"crate_id":1,"path":["std","os","fd","owned","OwnedFd"],"kind":"struct"},"2:10092:8885":{"crate_id":2,"path":["core","slice","iter","SplitMut"],"kind":"struct"},"32:5836:13522":{"crate_id":32,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_tp"],"kind":"struct"},"11:60:37593":{"crate_id":11,"path":["hashbrown","raw","bitmask","BitMaskIter"],"kind":"struct"},"41:12951:20562":{"crate_id":41,"path":["object","pe","MaskedRichHeaderEntry"],"kind":"struct"},"0:24:1712":{"crate_id":0,"path":["clap","_features"],"kind":"module"},"32:5758:13518":{"crate_id":32,"path":["libc","unix","linux_like","linux","fanotify_response"],"kind":"struct"},"6:7520:13704":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_cond_t"],"kind":"struct"},"2:22359:174":{"crate_id":2,"path":["core","num","nonzero","NonZeroU128"],"kind":"struct"},"40:6236:16372":{"crate_id":40,"path":["gimli","read","dwarf","RangeIter"],"kind":"struct"},"16:5104:16151":{"crate_id":16,"path":["gimli","constants","DwRle"],"kind":"struct"},"2:40399:9228":{"crate_id":2,"path":["core","iter","adapters","rev","Rev"],"kind":"struct"},"2:20869:3637":{"crate_id":2,"path":["core","core_simd","elements","mut_ptr","SimdMutPtr"],"kind":"trait"},"2:40149:9346":{"crate_id":2,"path":["core","ffi","c_str","FromBytesUntilNulError"],"kind":"struct"},"47:4847:39626":{"crate_id":47,"path":["rustix","process","prctl","SpeculationFeature"],"kind":"enum"},"41:12375:19837":{"crate_id":41,"path":["object","macho","PrebindCksumCommand"],"kind":"struct"},"42:481:20671":{"crate_id":42,"path":["memchr","cow","CowBytes"],"kind":"struct"},"17:10580:16743":{"crate_id":17,"path":["object","read","pe","import","ImportDescriptorIterator"],"kind":"struct"},"20:4641:20703":{"crate_id":20,"path":["clap_builder","parser","parser","PendingArg"],"kind":"struct"},"41:13500:20604":{"crate_id":41,"path":["object","pe","ImageLoadConfigCodeIntegrity"],"kind":"struct"},"34:6126:22397":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_4"],"kind":"struct"},"42:521:20670":{"crate_id":42,"path":["memchr","memmem","prefilter","Prefilter"],"kind":"enum"},"40:3063:15455":{"crate_id":40,"path":["gimli","arch","Arm"],"kind":"struct"},"17:13443:20604":{"crate_id":17,"path":["object","pe","ImageLoadConfigCodeIntegrity"],"kind":"struct"},"41:9155:16531":{"crate_id":41,"path":["object","read","any","SectionIterator"],"kind":"struct"},"2:41589:3190":{"crate_id":2,"path":["core","result","IterMut"],"kind":"struct"},"41:13534:20608":{"crate_id":41,"path":["object","pe","ImageDynamicRelocation32V2"],"kind":"struct"},"1:10712:3331":{"crate_id":1,"path":["std","sys","unix","io","IoSlice"],"kind":"struct"},"16:3446:15458":{"crate_id":16,"path":["gimli","arch","RiscV"],"kind":"struct"},"17:12345:19839":{"crate_id":17,"path":["object","macho","RpathCommand"],"kind":"struct"},"34:7588:22469":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_probe_op"],"kind":"struct"},"32:5739:13517":{"crate_id":32,"path":["libc","unix","linux_like","linux","inotify_event"],"kind":"struct"},"16:3899:15522":{"crate_id":16,"path":["gimli","constants","DwChildren"],"kind":"struct"},"40:7596:16425":{"crate_id":40,"path":["gimli","read","rnglists","RawRngListEntry"],"kind":"enum"},"34:5039:22345":{"crate_id":34,"path":["linux_raw_sys","general","fstrim_range"],"kind":"struct"},"34:6797:22426":{"crate_id":34,"path":["linux_raw_sys","general","old_utsname"],"kind":"struct"},"18:699:20667":{"crate_id":18,"path":["memchr","memmem","FinderBuilder"],"kind":"struct"},"2:45561:3704":{"crate_id":2,"path":["core","core_arch","simd","u64x1"],"kind":"struct"},"16:6662:16394":{"crate_id":16,"path":["gimli","read","line","LineInstructions"],"kind":"struct"},"41:9674:16571":{"crate_id":41,"path":["object","read","coff","comdat","CoffComdatIterator"],"kind":"struct"},"32:5986:13530":{"crate_id":32,"path":["libc","unix","linux_like","linux","nlmsgerr"],"kind":"struct"},"17:10840:16542":{"crate_id":17,"path":["object","read","SymbolIndex"],"kind":"struct"},"34:7730:22482":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_recvmsg_out"],"kind":"struct"},"32:2150:3451":{"crate_id":32,"path":["libc","unix","linux_like","sockaddr_un"],"kind":"struct"},"6:5862:14183":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_req"],"kind":"struct"},"34:5308:22362":{"crate_id":34,"path":["linux_raw_sys","general","group_filter__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"6:4773:13521":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_extended_err"],"kind":"struct"},"32:1701:10088":{"crate_id":32,"path":["libc","unix","linux_like","timezone"],"kind":"enum"},"2:46866:3655":{"crate_id":2,"path":["core","core_arch","simd","i8x64"],"kind":"struct"},"32:543:10029":{"crate_id":32,"path":["libc","unix","rlimit"],"kind":"struct"},"40:2594:15437":{"crate_id":40,"path":["gimli","common","DebugLocListsIndex"],"kind":"struct"},"37:7:15354":{"crate_id":37,"path":["rustc_demangle","legacy","Demangle"],"kind":"struct"},"47:5306:39676":{"crate_id":47,"path":["rustix","process","wait","WaitStatus"],"kind":"struct"},"41:12649:19856":{"crate_id":41,"path":["object","macho","Nlist32"],"kind":"struct"},"41:2001:16601":{"crate_id":41,"path":["object","read","elf","relocation","Rel"],"kind":"trait"},"5:1058:35194":{"crate_id":5,"path":["alloc","collections","btree","borrow","DormantMutRef"],"kind":"struct"},"40:6218:16371":{"crate_id":40,"path":["gimli","read","dwarf","Unit"],"kind":"struct"},"48:6743:22450":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_5"],"kind":"union"},"40:6935:16404":{"crate_id":40,"path":["gimli","read","loclists","RawLocListIter"],"kind":"struct"},"2:42153:8839":{"crate_id":2,"path":["core","fmt","num","Binary"],"kind":"struct"},"41:4159:16503":{"crate_id":41,"path":["object","read","SymbolMapEntry"],"kind":"trait"},"1:1985:184":{"crate_id":1,"path":["std","ffi","os_str","OsStr"],"kind":"struct"},"17:12046:19820":{"crate_id":17,"path":["object","macho","SubFrameworkCommand"],"kind":"struct"},"40:4624:16007":{"crate_id":40,"path":["gimli","constants","DwVirtuality"],"kind":"struct"},"26:208:20767":{"crate_id":26,"path":["anstream","adapter","strip","StrippedStr"],"kind":"struct"},"17:9138:16532":{"crate_id":17,"path":["object","read","any","ComdatIterator"],"kind":"struct"},"1:2208:3306":{"crate_id":1,"path":["std","fs","DirEntry"],"kind":"struct"},"2:43656:8918":{"crate_id":2,"path":["core","str","iter","EscapeDebug"],"kind":"struct"},"2:44080:9409":{"crate_id":2,"path":["core","str","CharEscapeDebugContinue"],"kind":"struct"},"48:6669:22443":{"crate_id":48,"path":["linux_raw_sys","general","uffdio_writeprotect"],"kind":"struct"},"40:5976:16365":{"crate_id":40,"path":["gimli","read","cfi","UnwindTableRow"],"kind":"struct"},"17:9796:16596":{"crate_id":17,"path":["object","read","elf","symbol","ElfSymbol"],"kind":"struct"},"5:3975:3194":{"crate_id":5,"path":["alloc","collections","vec_deque","drain","Drain"],"kind":"struct"},"32:8802:14616":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","seccomp_notif_sizes"],"kind":"struct"},"2:6674:9218":{"crate_id":2,"path":["core","iter","adapters","zip","TrustedRandomAccessNoCoerce"],"kind":"trait"},"5:7089:3191":{"crate_id":5,"path":["alloc","collections","vec_deque","into_iter","IntoIter"],"kind":"struct"},"0:23:1711":{"crate_id":0,"path":["clap","_faq"],"kind":"module"},"48:5251:22373":{"crate_id":48,"path":["linux_raw_sys","general","in6_flowlabel_req"],"kind":"struct"},"6:6569:9910":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","flock"],"kind":"struct"},"26:402:20758":{"crate_id":26,"path":["anstream","buffer","Buffer"],"kind":"struct"},"17:13625:20615":{"crate_id":17,"path":["object","pe","ImageHotPatchBase"],"kind":"struct"},"40:7411:16412":{"crate_id":40,"path":["gimli","read","op","Expression"],"kind":"struct"},"34:7017:22443":{"crate_id":34,"path":["linux_raw_sys","general","uffdio_writeprotect"],"kind":"struct"},"41:11479:19306":{"crate_id":41,"path":["object","elf","Syminfo64"],"kind":"struct"},"2:40459:3360":{"crate_id":2,"path":["core","iter","adapters","take","Take"],"kind":"struct"},"20:3828:2965":{"crate_id":20,"path":["clap_builder","builder","resettable","Resettable"],"kind":"enum"},"20:3787:2991":{"crate_id":20,"path":["clap_builder","builder","os_str","inner","Inner"],"kind":"enum"},"16:7572:37733":{"crate_id":16,"path":["gimli","read","rnglists","RangeListsFormat"],"kind":"enum"},"40:4037:15636":{"crate_id":40,"path":["gimli","constants","DwTag"],"kind":"struct"},"48:4733:22345":{"crate_id":48,"path":["linux_raw_sys","general","fstrim_range"],"kind":"struct"},"40:5886:16361":{"crate_id":40,"path":["gimli","read","cfi","FrameDescriptionEntry"],"kind":"struct"},"6:4890:13535":{"crate_id":6,"path":["libc","unix","linux_like","linux","sctp_initmsg"],"kind":"struct"},"20:3988:2972":{"crate_id":20,"path":["clap_builder","builder","value_parser","EnumValueParser"],"kind":"struct"},"0:18:1854":{"crate_id":0,"path":["clap","_cookbook","repl"],"kind":"module"},"16:6904:16403":{"crate_id":16,"path":["gimli","read","loclists","LocationLists"],"kind":"struct"},"16:6558:16392":{"crate_id":16,"path":["gimli","read","line","LineRows"],"kind":"struct"},"17:13240:20585":{"crate_id":17,"path":["object","pe","ImageRelocation"],"kind":"struct"},"34:4980:22343":{"crate_id":34,"path":["linux_raw_sys","general","fsconfig_command"],"kind":"enum"},"41:10954:16545":{"crate_id":41,"path":["object","read","SymbolMapName"],"kind":"struct"},"17:10589:16744":{"crate_id":17,"path":["object","read","pe","import","ImportThunkList"],"kind":"struct"},"2:39961:9000":{"crate_id":2,"path":["core","async_iter","from_iter","FromIter"],"kind":"struct"},"41:10072:16693":{"crate_id":41,"path":["object","read","macho","dyld_cache","DyldSubCache"],"kind":"struct"},"17:8953:16529":{"crate_id":17,"path":["object","read","util","StringTable"],"kind":"struct"},"17:10516:16706":{"crate_id":17,"path":["object","read","pe","data_directory","DataDirectories"],"kind":"struct"},"2:30302:32750":{"crate_id":2,"path":["core","ptr","alignment","AlignmentEnum16"],"kind":"enum"},"20:3032:39034":{"crate_id":20,"path":["clap_builder","builder","app_settings","Flags"],"kind":"struct"},"1:2387:2507":{"crate_id":1,"path":["std","io"],"kind":"module"},"1:10000:25268":{"crate_id":1,"path":["std","sys","unix","os","Env"],"kind":"struct"},"16:154:15402":{"crate_id":16,"path":["gimli","read","util","ArrayVec"],"kind":"struct"},"32:1943:10952":{"crate_id":32,"path":["libc","unix","linux_like","Dl_info"],"kind":"struct"},"48:5773:22395":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_2"],"kind":"struct"},"41:10137:16696":{"crate_id":41,"path":["object","read","macho","file","MachOComdat"],"kind":"struct"},"48:5872:22407":{"crate_id":48,"path":["linux_raw_sys","general","siginfo__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"16:6179:16369":{"crate_id":16,"path":["gimli","read","dwarf","Dwarf"],"kind":"struct"},"34:5649:22380":{"crate_id":34,"path":["linux_raw_sys","general","ipv6hdr__bindgen_ty_1"],"kind":"union"},"33:3456:20871":{"crate_id":33,"path":["rustix","backend","termios","types","QueueSelector"],"kind":"enum"},"34:5328:10945":{"crate_id":34,"path":["linux_raw_sys","general","sockaddr_in"],"kind":"struct"},"2:12501:107":{"crate_id":2,"path":["core","task","wake","Context"],"kind":"struct"},"17:9478:16582":{"crate_id":17,"path":["object","read","coff","file","CoffCommon"],"kind":"struct"},"41:13526:20607":{"crate_id":41,"path":["object","pe","ImageDynamicRelocation64"],"kind":"struct"},"2:3370:8976":{"crate_id":2,"path":["core","any","Provider"],"kind":"trait"},"1:3680:3409":{"crate_id":1,"path":["std","net","tcp","TcpListener"],"kind":"struct"},"17:12510:19850":{"crate_id":17,"path":["object","macho","IdentCommand"],"kind":"struct"},"2:2354:189":{"crate_id":2,"path":["core","cmp","PartialOrd"],"kind":"trait"},"2:40163:3291":{"crate_id":2,"path":["core","ffi","c_char"],"kind":"typedef"},"41:13366:20590":{"crate_id":41,"path":["object","pe","ImageImportByName"],"kind":"struct"},"1:7693:3273":{"crate_id":1,"path":["std","env","JoinPathsError"],"kind":"struct"},"41:12103:19820":{"crate_id":41,"path":["object","macho","SubFrameworkCommand"],"kind":"struct"},"31:0:2637":{"crate_id":31,"path":["io_lifetimes"],"kind":"module"},"20:4362:20707":{"crate_id":20,"path":["clap_builder","parser","matches","arg_matches","IdsRef"],"kind":"struct"},"34:6077:13398":{"crate_id":34,"path":["linux_raw_sys","general","sigaltstack"],"kind":"struct"},"1:8215:3462":{"crate_id":1,"path":["std","os","unix","net","ancillary","SocketCred"],"kind":"struct"},"48:5300:22377":{"crate_id":48,"path":["linux_raw_sys","general","rt2_hdr"],"kind":"struct"},"16:2426:15430":{"crate_id":16,"path":["gimli","common","DebugAddrIndex"],"kind":"struct"},"41:9555:16579":{"crate_id":41,"path":["object","read","coff","section","SectionTable"],"kind":"struct"},"5:1432:3197":{"crate_id":5,"path":["alloc","collections","btree","map","IntoKeys"],"kind":"struct"},"41:10535:16711":{"crate_id":41,"path":["object","read","pe","section","PeSectionIterator"],"kind":"struct"},"42:531:20674":{"crate_id":42,"path":["memchr","memmem","prefilter","PrefilterState"],"kind":"struct"},"41:12664:19857":{"crate_id":41,"path":["object","macho","Nlist64"],"kind":"struct"},"17:11993:19816":{"crate_id":17,"path":["object","macho","Fvmlib"],"kind":"struct"},"17:9946:16618":{"crate_id":17,"path":["object","read","elf","version","VerdefIterator"],"kind":"struct"},"40:3225:15456":{"crate_id":40,"path":["gimli","arch","AArch64"],"kind":"struct"},"49:22:24114":{"crate_id":49,"path":["unicode_width","UnicodeWidthChar"],"kind":"trait"},"17:12607:19857":{"crate_id":17,"path":["object","macho","Nlist64"],"kind":"struct"},"41:12567:19850":{"crate_id":41,"path":["object","macho","IdentCommand"],"kind":"struct"},"5:3775:35280":{"crate_id":5,"path":["alloc","collections","linked_list","drop","DropGuard"],"kind":"struct"},"2:2792:9266":{"crate_id":2,"path":["core","ops","arith","MulAssign"],"kind":"trait"},"41:10562:16741":{"crate_id":41,"path":["object","read","pe","section","PeRelocationIterator"],"kind":"struct"},"48:5650:13479":{"crate_id":48,"path":["linux_raw_sys","general","itimerspec"],"kind":"struct"},"48:5226:22372":{"crate_id":48,"path":["linux_raw_sys","general","in6_addr__bindgen_ty_1"],"kind":"union"},"5:2905:8824":{"crate_id":5,"path":["alloc","collections","btree","node","marker","Owned"],"kind":"enum"},"1:9033:218":{"crate_id":1,"path":["std","sync","rwlock","RwLockReadGuard"],"kind":"struct"},"34:6980:22439":{"crate_id":34,"path":["linux_raw_sys","general","uffdio_range"],"kind":"struct"},"2:2833:9273":{"crate_id":2,"path":["core","ops","bit","Shr"],"kind":"trait"},"48:7298:10881":{"crate_id":48,"path":["linux_raw_sys","general","statfs64"],"kind":"struct"},"2:44076:9406":{"crate_id":2,"path":["core","str","LinesMap"],"kind":"struct"},"2:2753:3620":{"crate_id":2,"path":["core","ops","arith","Add"],"kind":"trait"},"31:182:20815":{"crate_id":31,"path":["io_lifetimes","views","SocketlikeViewType"],"kind":"trait"},"47:3798:20870":{"crate_id":47,"path":["rustix","backend","termios","types","OptionalActions"],"kind":"enum"},"40:2524:15434":{"crate_id":40,"path":["gimli","common","DebugLineStrOffset"],"kind":"struct"},"17:8909:3361":{"crate_id":17,"path":["object","read","util","Bytes"],"kind":"struct"},"11:2060:3204":{"crate_id":11,"path":["hashbrown","set","Entry"],"kind":"enum"},"40:5418:37854":{"crate_id":40,"path":["gimli","read","util","sealed","CapacityFull"],"kind":"struct"},"41:10149:16697":{"crate_id":41,"path":["object","read","macho","file","MachOComdatSectionIterator"],"kind":"struct"},"32:5031:13484":{"crate_id":32,"path":["libc","unix","linux_like","linux","sembuf"],"kind":"struct"},"6:4732:13516":{"crate_id":6,"path":["libc","unix","linux_like","linux","arpd_request"],"kind":"struct"},"34:4815:22330":{"crate_id":34,"path":["linux_raw_sys","general","vfs_ns_cap_data"],"kind":"struct"},"34:7373:22459":{"crate_id":34,"path":["linux_raw_sys","general","io_cqring_offsets"],"kind":"struct"},"16:6321:16376":{"crate_id":16,"path":["gimli","read","abbrev","AbbreviationsCache"],"kind":"struct"},"2:40255:3359":{"crate_id":2,"path":["core","iter","adapters","chain","Chain"],"kind":"struct"},"41:12293:19832":{"crate_id":41,"path":["object","macho","DylibModule32"],"kind":"struct"},"11:816:3196":{"crate_id":11,"path":["hashbrown","map","ValuesMut"],"kind":"struct"},"1:3782:3411":{"crate_id":1,"path":["std","net","udp","UdpSocket"],"kind":"struct"},"40:4702:16061":{"crate_id":40,"path":["gimli","constants","DwLang"],"kind":"struct"},"48:5263:13515":{"crate_id":48,"path":["linux_raw_sys","general","in6_pktinfo"],"kind":"struct"},"17:9545:16572":{"crate_id":17,"path":["object","read","coff","section","CoffSection"],"kind":"struct"},"41:9923:16610":{"crate_id":41,"path":["object","read","elf","note","NoteIterator"],"kind":"struct"},"41:1034:16581":{"crate_id":41,"path":["object","read","coff","relocation","CoffRelocationIterator"],"kind":"struct"},"34:5554:10946":{"crate_id":34,"path":["linux_raw_sys","general","sockaddr_in6"],"kind":"struct"},"41:9853:16596":{"crate_id":41,"path":["object","read","elf","symbol","ElfSymbol"],"kind":"struct"},"41:9829:16598":{"crate_id":41,"path":["object","read","elf","symbol","ElfSymbolTable"],"kind":"struct"},"42:614:38769":{"crate_id":42,"path":["memchr","memmem","twoway","SuffixKind"],"kind":"enum"},"2:7165:9209":{"crate_id":2,"path":["core","iter","traits","accum","Product"],"kind":"trait"},"17:13419:20601":{"crate_id":17,"path":["object","pe","ImageResourceDirectoryString"],"kind":"struct"},"6:6151:14227":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","semid_ds"],"kind":"struct"},"41:9623:16535":{"crate_id":41,"path":["object","read","coff","symbol","SymbolIterator"],"kind":"struct"},"2:40069:9032":{"crate_id":2,"path":["core","char","ToLowercase"],"kind":"struct"},"2:3931:3347":{"crate_id":2,"path":["core","array","Guard"],"kind":"struct"},"6:494:10028":{"crate_id":6,"path":["libc","unix","timespec"],"kind":"struct"},"16:5811:16359":{"crate_id":16,"path":["gimli","read","cfi","CommonInformationEntry"],"kind":"struct"},"41:12090:19819":{"crate_id":41,"path":["object","macho","DylibCommand"],"kind":"struct"},"34:7358:22458":{"crate_id":34,"path":["linux_raw_sys","general","io_sqring_offsets"],"kind":"struct"},"2:2692:8831":{"crate_id":2,"path":["core","marker","Unsize"],"kind":"trait"},"17:10316:16655":{"crate_id":17,"path":["object","read","macho","section","MachOSectionInternal"],"kind":"struct"},"2:44108:9408":{"crate_id":2,"path":["core","str","UnsafeBytesToStr"],"kind":"struct"},"17:9617:16571":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdatIterator"],"kind":"struct"},"47:3822:20871":{"crate_id":47,"path":["rustix","backend","termios","types","QueueSelector"],"kind":"enum"},"41:9510:16564":{"crate_id":41,"path":["object","read","archive","MemberHeader"],"kind":"enum"},"20:4309:20699":{"crate_id":20,"path":["clap_builder","parser","arg_matcher","ArgMatcher"],"kind":"struct"},"2:3382:8980":{"crate_id":2,"path":["core","any","Demand"],"kind":"struct"},"39:0:2497":{"crate_id":39,"path":["addr2line"],"kind":"module"},"1:4903:3500":{"crate_id":1,"path":["std","panic","always_abort"],"kind":"function"},"41:10083:16694":{"crate_id":41,"path":["object","read","macho","dyld_cache","DyldCacheImageIterator"],"kind":"struct"},"1:2211:3307":{"crate_id":1,"path":["std","fs","read"],"kind":"function"},"2:2839:9274":{"crate_id":2,"path":["core","ops","bit","BitAndAssign"],"kind":"trait"},"17:10303:16654":{"crate_id":17,"path":["object","read","macho","section","MachOSection"],"kind":"struct"},"40:2694:15441":{"crate_id":40,"path":["gimli","common","RangeListsOffset"],"kind":"struct"},"40:6981:16406":{"crate_id":40,"path":["gimli","read","loclists","LocListIter"],"kind":"struct"},"1:11237:29728":{"crate_id":1,"path":["std","sys_common","wtf8","Wtf8CodePoints"],"kind":"struct"},"17:12194:19830":{"crate_id":17,"path":["object","macho","DysymtabCommand"],"kind":"struct"},"20:27:2668":{"crate_id":20,"path":["clap_builder","command"],"kind":"macro"},"48:4966:10943":{"crate_id":48,"path":["linux_raw_sys","general","ip_mreq_source"],"kind":"struct"},"2:39365:32895":{"crate_id":2,"path":["core","any","tags","MaybeSizedValue"],"kind":"struct"},"40:5557:16346":{"crate_id":40,"path":["gimli","read","addr","DebugAddr"],"kind":"struct"},"6:6024:37470":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","sifields_sigchld"],"kind":"struct"},"16:6327:16377":{"crate_id":16,"path":["gimli","read","abbrev","Abbreviations"],"kind":"struct"},"42:624:38776":{"crate_id":42,"path":["memchr","memmem","twoway","SuffixOrdering"],"kind":"enum"},"41:11429:19303":{"crate_id":41,"path":["object","elf","Sym32"],"kind":"struct"},"47:4746:39564":{"crate_id":47,"path":["rustix","process","prctl","VirtualMemoryMapAddress"],"kind":"enum"},"48:5634:10028":{"crate_id":48,"path":["linux_raw_sys","general","timespec"],"kind":"struct"},"5:3547:3190":{"crate_id":5,"path":["alloc","collections","linked_list","IterMut"],"kind":"struct"},"2:21839:33748":{"crate_id":2,"path":["core","num","dec2flt","FloatErrorKind"],"kind":"enum"},"16:6146:194":{"crate_id":16,"path":["gimli","read","cfi","Pointer"],"kind":"enum"},"32:5871:13524":{"crate_id":32,"path":["libc","unix","linux_like","linux","can_filter"],"kind":"struct"},"17:10747:128":{"crate_id":17,"path":["object","read","Error"],"kind":"struct"},"1:11003:3543":{"crate_id":1,"path":["std","sys","unix","process","process_inner","ExitStatus"],"kind":"struct"},"48:5799:22398":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5"],"kind":"struct"},"5:3088:95":{"crate_id":5,"path":["alloc","collections","btree","set","BTreeSet"],"kind":"struct"},"2:22590:3419":{"crate_id":2,"path":["core","num","nonzero","NonZeroIsize"],"kind":"struct"},"17:11319:19300":{"crate_id":17,"path":["object","elf","SectionHeader64"],"kind":"struct"},"6:4499:13495":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_condition_effect"],"kind":"struct"},"6:4521:13497":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_rumble_effect"],"kind":"struct"},"18:574:38764":{"crate_id":18,"path":["memchr","memmem","twoway","Forward"],"kind":"struct"},"1:2360:3316":{"crate_id":1,"path":["std","fs","read_link"],"kind":"function"},"17:11573:19317":{"crate_id":17,"path":["object","elf","Verdaux"],"kind":"struct"},"41:9698:16583":{"crate_id":41,"path":["object","read","coff","comdat","CoffComdatSectionIterator"],"kind":"struct"},"1:11886:371":{"crate_id":1,"path":["std","bool"],"kind":"primitive"},"2:43969:8928":{"crate_id":2,"path":["core","str","lossy","Utf8Chunk"],"kind":"struct"},"32:9671:13707":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_barrier_t"],"kind":"struct"},"1:11859:3175":{"crate_id":1,"path":["std","backtrace_rs","types","BytesOrWideString"],"kind":"enum"},"2:40306:9221":{"crate_id":2,"path":["core","iter","adapters","filter","Filter"],"kind":"struct"},"5:1422:3196":{"crate_id":5,"path":["alloc","collections","btree","map","ValuesMut"],"kind":"struct"},"42:660:20663":{"crate_id":42,"path":["memchr","memmem","FindIter"],"kind":"struct"},"32:1883:10949":{"crate_id":32,"path":["libc","unix","linux_like","fd_set"],"kind":"struct"},"47:2990:20830":{"crate_id":47,"path":["rustix","backend","io","poll_fd","PollFd"],"kind":"struct"},"47:4162:39597":{"crate_id":47,"path":["rustix","process","id","Gid"],"kind":"struct"},"17:9512:16575":{"crate_id":17,"path":["object","read","coff","section","CoffSegmentIterator"],"kind":"struct"},"34:7617:22472":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_restriction__bindgen_ty_1"],"kind":"union"},"17:9380:16560":{"crate_id":17,"path":["object","read","archive","ArchiveKind"],"kind":"enum"},"17:12033:19819":{"crate_id":17,"path":["object","macho","DylibCommand"],"kind":"struct"},"41:9879:16603":{"crate_id":41,"path":["object","read","elf","relocation","RelocationSections"],"kind":"struct"},"16:4872:16087":{"crate_id":16,"path":["gimli","constants","DwDsc"],"kind":"struct"},"36:0:2503":{"crate_id":36,"path":["backtrace"],"kind":"module"},"32:8695:14612":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user"],"kind":"struct"},"34:6111:22395":{"crate_id":34,"path":["linux_raw_sys","general","__sifields__bindgen_ty_2"],"kind":"struct"},"2:3510:3194":{"crate_id":2,"path":["core","array","drain","Drain"],"kind":"struct"},"17:10428:16739":{"crate_id":17,"path":["object","read","pe","file","PeComdat"],"kind":"struct"},"1:8948:27461":{"crate_id":1,"path":["std","sync","mpmc","list","Position"],"kind":"struct"},"1:5499:3540":{"crate_id":1,"path":["std","process","exit"],"kind":"function"},"40:2786:15445":{"crate_id":40,"path":["gimli","common","DebugStrOffsetsBase"],"kind":"struct"},"26:348:20769":{"crate_id":26,"path":["anstream","adapter","wincon","WinconBytesIter"],"kind":"struct"},"6:1700:10959":{"crate_id":6,"path":["libc","unix","linux_like","arphdr"],"kind":"struct"},"2:20579:35001":{"crate_id":2,"path":["core","core_simd","swizzle","interleave","Hi"],"kind":"struct"},"16:6361:16380":{"crate_id":16,"path":["gimli","read","abbrev","AttributeSpecification"],"kind":"struct"},"41:13016:20566":{"crate_id":41,"path":["object","pe","ImageRomOptionalHeader"],"kind":"struct"},"41:13373:20591":{"crate_id":41,"path":["object","pe","ImageThunkData64"],"kind":"struct"},"32:8820:14617":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","ptrace_rseq_configuration"],"kind":"struct"},"23:112:20729":{"crate_id":23,"path":["clap_lex","ArgCursor"],"kind":"struct"},"20:1395:2662":{"crate_id":20,"path":["clap_builder","builder","value_parser","ValueParserFactory","Parser"],"kind":"foreign_type"},"6:1752:10964":{"crate_id":6,"path":["libc","unix","linux_like","sigevent"],"kind":"struct"},"40:4596:16003":{"crate_id":40,"path":["gimli","constants","DwVis"],"kind":"struct"},"40:6293:16374":{"crate_id":40,"path":["gimli","read","reader","ReaderOffsetId"],"kind":"struct"},"36:175:15381":{"crate_id":36,"path":["backtrace","backtrace","libunwind","Frame"],"kind":"enum"},"1:6586:217":{"crate_id":1,"path":["std","sync","rwlock","RwLock"],"kind":"struct"},"33:4000:39542":{"crate_id":33,"path":["rustix","process","pidfd","PidfdFlags"],"kind":"struct"},"48:5739:13398":{"crate_id":48,"path":["linux_raw_sys","general","sigaltstack"],"kind":"struct"},"48:5104:22371":{"crate_id":48,"path":["linux_raw_sys","general","_bindgen_ty_2"],"kind":"enum"},"17:11832:16700":{"crate_id":17,"path":["object","macho","FatArch64"],"kind":"struct"},"1:8171:3399":{"crate_id":1,"path":["std","net","Shutdown"],"kind":"enum"},"17:9577:16578":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbolTable"],"kind":"struct"},"20:3413:2989":{"crate_id":20,"path":["clap_builder","builder","arg_settings","ArgSettings"],"kind":"enum"},"2:43144:8880":{"crate_id":2,"path":["core","slice","iter","Chunks"],"kind":"struct"},"1:8496:3529":{"crate_id":1,"path":["std","path","StripPrefixError"],"kind":"struct"},"2:20564:34656":{"crate_id":2,"path":["core","core_simd","swizzle","rotate_lanes_right","Rotate"],"kind":"struct"},"2:40050:8918":{"crate_id":2,"path":["core","char","EscapeDebug"],"kind":"struct"},"41:9591:16573":{"crate_id":41,"path":["object","read","coff","section","CoffSectionIterator"],"kind":"struct"},"29:41:20790":{"crate_id":29,"path":["colorchoice","AtomicChoice"],"kind":"struct"},"2:1821:3232":{"crate_id":2,"path":["core","ptr","non_null","NonNull"],"kind":"struct"},"6:474:10025":{"crate_id":6,"path":["libc","unix","group"],"kind":"struct"},"21:84:9015":{"crate_id":21,"path":["once_cell","unsync","OnceCell"],"kind":"struct"},"41:10096:16652":{"crate_id":41,"path":["object","read","macho","dyld_cache","DyldCacheImage"],"kind":"struct"},"2:10010:3362":{"crate_id":2,"path":["core","slice","iter","Split"],"kind":"struct"},"16:2668:15440":{"crate_id":16,"path":["gimli","common","RawRangeListsOffset"],"kind":"struct"},"1:3911:3426":{"crate_id":1,"path":["std","os","unix","fs","FileExt"],"kind":"trait"},"2:22557:169":{"crate_id":2,"path":["core","num","nonzero","NonZeroI128"],"kind":"struct"},"2:43425:8926":{"crate_id":2,"path":["core","str","iter","RSplitTerminator"],"kind":"struct"},"41:13238:20580":{"crate_id":41,"path":["object","pe","ImageAuxSymbolFunction"],"kind":"struct"},"5:7044:3191":{"crate_id":5,"path":["alloc","collections","btree","set","IntoIter"],"kind":"struct"},"1:5719:3565":{"crate_id":1,"path":["std","sync","condvar","Condvar"],"kind":"struct"},"40:5402:15391":{"crate_id":40,"path":["gimli","endianity","BigEndian"],"kind":"struct"},"11:399:37594":{"crate_id":11,"path":["hashbrown","raw","RawIterHashInner"],"kind":"struct"},"17:9596:16576":{"crate_id":17,"path":["object","read","coff","symbol","CoffSymbol"],"kind":"struct"},"48:6560:22430":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg"],"kind":"struct"},"2:39552:28312":{"crate_id":2,"path":["core","ascii","ascii_char","AsciiChar"],"kind":"enum"},"40:7669:16428":{"crate_id":40,"path":["gimli","read","str","DebugStr"],"kind":"struct"},"1:8918:2991":{"crate_id":1,"path":["std","sync","mpmc","context","Inner"],"kind":"struct"},"17:10569:16709":{"crate_id":17,"path":["object","read","pe","import","ImportTable"],"kind":"struct"},"2:44273:205":{"crate_id":2,"path":["core","future","ready","Ready"],"kind":"struct"},"2:9142:112":{"crate_id":2,"path":["core","fmt","Debug"],"kind":"trait"},"1:11145:27081":{"crate_id":1,"path":["std","sys_common","once","futex","CompletionGuard"],"kind":"struct"},"47:3909:39633":{"crate_id":47,"path":["rustix","backend","time","types","DynamicClockId"],"kind":"enum"},"17:12372:19841":{"crate_id":17,"path":["object","macho","FilesetEntryCommand"],"kind":"struct"},"16:2742:15443":{"crate_id":16,"path":["gimli","common","DebugRngListsIndex"],"kind":"struct"},"18:515:20673":{"crate_id":18,"path":["memchr","memmem","prefilter","PrefilterFn"],"kind":"struct"},"17:10142:16698":{"crate_id":17,"path":["object","read","macho","load_command","LoadCommandVariant"],"kind":"enum"},"6:5988:14192":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","ptrace_peeksiginfo_args"],"kind":"struct"},"1:2614:3374":{"crate_id":1,"path":["std","io","buffered","linewriter","LineWriter"],"kind":"struct"},"6:6724:14611":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","user_regs_struct"],"kind":"struct"},"17:13194:20581":{"crate_id":17,"path":["object","pe","ImageAuxSymbolFunctionBeginEnd"],"kind":"struct"},"34:7333:22456":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_cqe"],"kind":"struct"},"5:1351:3189":{"crate_id":5,"path":["alloc","collections","btree","map","Iter"],"kind":"struct"},"1:2540:3372":{"crate_id":1,"path":["std","io","buffered","bufwriter","BufWriter"],"kind":"struct"},"17:11299:19299":{"crate_id":17,"path":["object","elf","SectionHeader32"],"kind":"struct"},"5:6695:244":{"crate_id":5,"path":["alloc","vec","Vec"],"kind":"struct"},"41:4099:16510":{"crate_id":41,"path":["object","read","traits","ObjectSymbolTable"],"kind":"trait"},"14:40:19298":{"crate_id":14,"path":["rustc_demangle","v0","Ident"],"kind":"struct"},"23:32:3362":{"crate_id":23,"path":["clap_lex","ext","Split"],"kind":"struct"},"17:11136:16756":{"crate_id":17,"path":["object","archive","Header"],"kind":"struct"},"1:4845:3490":{"crate_id":1,"path":["std","os","net","linux_ext","addr","SocketAddrExt"],"kind":"trait"},"32:5657:13513":{"crate_id":32,"path":["libc","unix","linux_like","linux","posix_spawnattr_t"],"kind":"struct"},"40:5944:16363":{"crate_id":40,"path":["gimli","read","cfi","UnwindTable"],"kind":"struct"},"16:7498:16418":{"crate_id":16,"path":["gimli","read","pubtypes","PubTypesEntry"],"kind":"struct"},"6:1614:10952":{"crate_id":6,"path":["libc","unix","linux_like","Dl_info"],"kind":"struct"},"37:0:2496":{"crate_id":37,"path":["rustc_demangle"],"kind":"module"},"34:6758:10033":{"crate_id":34,"path":["linux_raw_sys","general","iovec"],"kind":"struct"},"40:134:3336":{"crate_id":40,"path":["gimli","read","util","sealed","Sealed"],"kind":"trait"},"33:4289:39539":{"crate_id":33,"path":["rustix","process","prctl","FloatingPointExceptionMode"],"kind":"struct"},"1:9386:25269":{"crate_id":1,"path":["std","sys","unix","fs","Dir"],"kind":"struct"},"41:9569:16575":{"crate_id":41,"path":["object","read","coff","section","CoffSegmentIterator"],"kind":"struct"},"31:189:20817":{"crate_id":31,"path":["io_lifetimes","views","SocketlikeView"],"kind":"struct"},"41:13848:20627":{"crate_id":41,"path":["object","pe","ImageDebugMisc"],"kind":"struct"},"2:2744:8830":{"crate_id":2,"path":["core","marker","Tuple"],"kind":"trait"},"32:8603:14609":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_xmmreg"],"kind":"struct"},"2:20984:3631":{"crate_id":2,"path":["core","core_simd","lane_count","LaneCount"],"kind":"struct"},"5:880:3189":{"crate_id":5,"path":["alloc","collections","binary_heap","Iter"],"kind":"struct"},"6:5051:13551":{"crate_id":6,"path":["libc","unix","linux_like","linux","ifreq"],"kind":"struct"},"32:2165:10963":{"crate_id":32,"path":["libc","unix","linux_like","utsname"],"kind":"struct"},"22:0:2628":{"crate_id":22,"path":["bitflags"],"kind":"module"},"11:0:2494":{"crate_id":11,"path":["hashbrown"],"kind":"module"},"2:42713:34239":{"crate_id":2,"path":["core","hash","sip","Sip24Rounds"],"kind":"struct"},"17:10660:16551":{"crate_id":17,"path":["object","read","pe","relocation","Relocation"],"kind":"struct"},"17:12980:20567":{"crate_id":17,"path":["object","pe","ImageOptionalHeader64"],"kind":"struct"},"41:10626:16709":{"crate_id":41,"path":["object","read","pe","import","ImportTable"],"kind":"struct"},"1:4576:29742":{"crate_id":1,"path":["std","os","linux","fs","MetadataExt","st_mtime"],"kind":"foreign_type"},"20:4124:32742":{"crate_id":20,"path":["clap_builder","builder","debug_asserts","Flag"],"kind":"enum"},"33:3432:20870":{"crate_id":33,"path":["rustix","backend","termios","types","OptionalActions"],"kind":"enum"},"2:2856:9278":{"crate_id":2,"path":["core","ops","bit","ShrAssign"],"kind":"trait"},"32:4991:13324":{"crate_id":32,"path":["libc","unix","linux_like","linux","if_nameindex"],"kind":"struct"},"32:5909:13526":{"crate_id":32,"path":["libc","unix","linux_like","linux","sock_filter"],"kind":"struct"},"2:39372:9009":{"crate_id":2,"path":["core","any","tags","Ref"],"kind":"struct"},"20:64:2659":{"crate_id":20,"path":["clap_builder","derive","Args"],"kind":"trait"},"6:7485:13699":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_mutexattr_t"],"kind":"struct"},"41:13483:20602":{"crate_id":41,"path":["object","pe","ImageResourceDirStringU"],"kind":"struct"},"40:6558:16392":{"crate_id":40,"path":["gimli","read","line","LineRows"],"kind":"struct"},"41:9602:16572":{"crate_id":41,"path":["object","read","coff","section","CoffSection"],"kind":"struct"},"18:614:38769":{"crate_id":18,"path":["memchr","memmem","twoway","SuffixKind"],"kind":"enum"},"1:3292:3368":{"crate_id":1,"path":["std","io","stdio","IsTerminal"],"kind":"trait"},"1:953:3202":{"crate_id":1,"path":["std","collections","hash","map","RawVacantEntryMut"],"kind":"struct"},"16:8129:16443":{"crate_id":16,"path":["gimli","read","unit","EntriesTreeNode"],"kind":"struct"},"17:9641:16583":{"crate_id":17,"path":["object","read","coff","comdat","CoffComdatSectionIterator"],"kind":"struct"},"41:12281:19831":{"crate_id":41,"path":["object","macho","DylibTableOfContents"],"kind":"struct"},"40:8072:16440":{"crate_id":40,"path":["gimli","read","unit","EntriesRaw"],"kind":"struct"},"1:4508:3483":{"crate_id":1,"path":["std","os","unix","thread","JoinHandleExt"],"kind":"trait"},"32:2127:10960":{"crate_id":32,"path":["libc","unix","linux_like","mmsghdr"],"kind":"struct"},"1:11906:1496":{"crate_id":1,"path":["std","u16"],"kind":"primitive"},"1:5686:3563":{"crate_id":1,"path":["std","sync","barrier","Barrier"],"kind":"struct"},"16:0:2498":{"crate_id":16,"path":["gimli"],"kind":"module"},"2:3644:3191":{"crate_id":2,"path":["core","array","iter","IntoIter"],"kind":"struct"},"17:11628:19321":{"crate_id":17,"path":["object","elf","NoteHeader64"],"kind":"struct"},"1:1568:3194":{"crate_id":1,"path":["std","collections","hash","set","Drain"],"kind":"struct"},"40:4510:15989":{"crate_id":40,"path":["gimli","constants","DwDs"],"kind":"struct"},"32:1723:10941":{"crate_id":32,"path":["libc","unix","linux_like","ip_mreq"],"kind":"struct"},"6:4797:13524":{"crate_id":6,"path":["libc","unix","linux_like","linux","can_filter"],"kind":"struct"},"17:10505:16741":{"crate_id":17,"path":["object","read","pe","section","PeRelocationIterator"],"kind":"struct"},"32:7401:14183":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","nl_mmap_req"],"kind":"struct"},"6:4932:13539":{"crate_id":6,"path":["libc","unix","linux_like","linux","sctp_nxtinfo"],"kind":"struct"},"17:9973:16619":{"crate_id":17,"path":["object","read","elf","version","VerneedIterator"],"kind":"struct"},"16:7259:3508":{"crate_id":16,"path":["gimli","read","op","Location"],"kind":"enum"},"11:452:142":{"crate_id":11,"path":["hashbrown","map","HashMap"],"kind":"struct"},"16:7557:16423":{"crate_id":16,"path":["gimli","read","rnglists","RangeLists"],"kind":"struct"},"41:12460:19843":{"crate_id":41,"path":["object","macho","EncryptionInfoCommand64"],"kind":"struct"},"6:1657:10955":{"crate_id":6,"path":["libc","unix","linux_like","ifaddrs"],"kind":"struct"},"34:6842:22428":{"crate_id":34,"path":["linux_raw_sys","general","membarrier_cmd"],"kind":"enum"},"36:641:3167":{"crate_id":36,"path":["backtrace","capture","Backtrace"],"kind":"struct"},"1:2574:3364":{"crate_id":1,"path":["std","io","buffered","bufwriter","WriterPanicked"],"kind":"struct"},"2:21431:3626":{"crate_id":2,"path":["core","core_simd","vector","Simd"],"kind":"struct"},"32:1707:10940":{"crate_id":32,"path":["libc","unix","linux_like","in_addr"],"kind":"struct"},"20:4232:3375":{"crate_id":20,"path":["clap_builder","error","kind","ErrorKind"],"kind":"enum"},"2:4761:389":{"crate_id":2,"path":["core","ffi","c_void"],"kind":"enum"},"1:8075:3388":{"crate_id":1,"path":["std","io","util","Empty"],"kind":"struct"},"17:10334:16534":{"crate_id":17,"path":["object","read","macho","symbol","SymbolTable"],"kind":"struct"},"48:5094:22370":{"crate_id":48,"path":["linux_raw_sys","general","ip_beet_phdr"],"kind":"struct"},"32:7721:37470":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","sifields_sigchld"],"kind":"struct"},"27:255:2662":{"crate_id":27,"path":["anstyle_parse","Parser"],"kind":"struct"},"6:7503:13702":{"crate_id":6,"path":["libc","unix","linux_like","linux","pthread_barrierattr_t"],"kind":"struct"},"2:8251:3510":{"crate_id":2,"path":["core","panic","unwind_safe","AssertUnwindSafe"],"kind":"struct"},"17:8490:16520":{"crate_id":17,"path":["object","common","RelocationEncoding"],"kind":"enum"},"16:7837:16436":{"crate_id":16,"path":["gimli","read","unit","DebuggingInformationEntry"],"kind":"struct"},"41:10043:16646":{"crate_id":41,"path":["object","read","elf","version","VernauxIterator"],"kind":"struct"},"1:2550:26937":{"crate_id":1,"path":["std","io","buffered","bufwriter","flush_buf","BufGuard"],"kind":"struct"},"48:4753:22347":{"crate_id":48,"path":["linux_raw_sys","general","file_dedupe_range"],"kind":"struct"},"32:7292:14180":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","cmsghdr"],"kind":"struct"},"6:4767:13520":{"crate_id":6,"path":["libc","unix","linux_like","linux","regmatch_t"],"kind":"struct"},"41:13290:20584":{"crate_id":41,"path":["object","pe","ImageAuxSymbolCrc"],"kind":"struct"},"17:10923:16546":{"crate_id":17,"path":["object","read","ObjectMap"],"kind":"struct"},"1:10419:3383":{"crate_id":1,"path":["std","sys","unix","stdio","Stdout"],"kind":"struct"},"44:36:37573":{"crate_id":44,"path":["adler","algo","U32X4"],"kind":"struct"},"40:8025:16438":{"crate_id":40,"path":["gimli","read","unit","Attribute"],"kind":"struct"},"32:9631:13703":{"crate_id":32,"path":["libc","unix","linux_like","linux","fanotify_event_metadata"],"kind":"struct"},"2:12330:32295":{"crate_id":2,"path":["core","future","join","MaybeDone"],"kind":"enum"},"5:4047:3190":{"crate_id":5,"path":["alloc","collections","vec_deque","iter_mut","IterMut"],"kind":"struct"},"32:5814:13521":{"crate_id":32,"path":["libc","unix","linux_like","linux","sock_extended_err"],"kind":"struct"},"32:7602:14191":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","seminfo"],"kind":"struct"},"40:7767:16434":{"crate_id":40,"path":["gimli","read","unit","UnitType"],"kind":"enum"},"6:4790:13523":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_j1939"],"kind":"struct"},"2:42403:68":{"crate_id":2,"path":["core","fmt","rt","Alignment"],"kind":"enum"},"48:6614:22437":{"crate_id":48,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_5"],"kind":"struct"},"6:5779:14177":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__timeval"],"kind":"struct"},"6:4821:13527":{"crate_id":6,"path":["libc","unix","linux_like","linux","sock_fprog"],"kind":"struct"},"34:6938:22434":{"crate_id":34,"path":["linux_raw_sys","general","uffd_msg__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"40:5616:16349":{"crate_id":40,"path":["gimli","read","cfi","ParsedEhFrameHdr"],"kind":"struct"},"34:6211:22407":{"crate_id":34,"path":["linux_raw_sys","general","siginfo__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"40:7335:37891":{"crate_id":40,"path":["gimli","read","op","EvaluationWaiting"],"kind":"enum"},"2:40699:3389":{"crate_id":2,"path":["core","iter","sources","repeat","Repeat"],"kind":"struct"},"41:11948:19811":{"crate_id":41,"path":["object","macho","LcStr"],"kind":"struct"},"43:445:15223":{"crate_id":43,"path":["miniz_oxide","MZError"],"kind":"enum"},"40:6535:37744":{"crate_id":40,"path":["gimli","read","lazy","imp","LazyArc"],"kind":"struct"},"33:4198:39540":{"crate_id":33,"path":["rustix","process","prctl","FloatingPointEmulationControl"],"kind":"struct"},"2:44152:3624":{"crate_id":2,"path":["core","time","TryFromFloatSecsError"],"kind":"struct"},"2:40487:9233":{"crate_id":2,"path":["core","iter","adapters","zip","Zip"],"kind":"struct"},"17:12403:19843":{"crate_id":17,"path":["object","macho","EncryptionInfoCommand64"],"kind":"struct"},"34:7535:22464":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_rsrc_register"],"kind":"struct"},"1:11468:27319":{"crate_id":1,"path":["std","personality","dwarf","eh","EHContext"],"kind":"struct"},"40:4568:15999":{"crate_id":40,"path":["gimli","constants","DwAccess"],"kind":"struct"},"6:4472:13491":{"crate_id":6,"path":["libc","unix","linux_like","linux","ff_trigger"],"kind":"struct"},"23:98:20728":{"crate_id":23,"path":["clap_lex","RawArgs"],"kind":"struct"},"1:10357:27093":{"crate_id":1,"path":["std","sys","unix","stack_overflow","Handler"],"kind":"struct"},"40:2470:15432":{"crate_id":40,"path":["gimli","common","DebugInfoOffset"],"kind":"struct"},"16:7335:37891":{"crate_id":16,"path":["gimli","read","op","EvaluationWaiting"],"kind":"enum"},"2:43611:3358":{"crate_id":2,"path":["core","str","iter","Lines"],"kind":"struct"},"2:21862:32751":{"crate_id":2,"path":["core","num","flt2dec","decoder","Decoded"],"kind":"struct"},"2:20909:3644":{"crate_id":2,"path":["core","core_simd","elements","uint","SimdUint"],"kind":"trait"},"2:40083:9034":{"crate_id":2,"path":["core","char","CaseMappingIter"],"kind":"enum"},"40:4872:16087":{"crate_id":40,"path":["gimli","constants","DwDsc"],"kind":"struct"},"41:11356:19299":{"crate_id":41,"path":["object","elf","SectionHeader32"],"kind":"struct"},"1:3249:3380":{"crate_id":1,"path":["std","io","stdio","StderrLock"],"kind":"struct"},"1:6373:3567":{"crate_id":1,"path":["std","sync","once","OnceState"],"kind":"struct"},"41:11642:19318":{"crate_id":41,"path":["object","elf","Verneed"],"kind":"struct"},"2:0:497":{"crate_id":2,"path":["core"],"kind":"module"},"6:488:10027":{"crate_id":6,"path":["libc","unix","timeval"],"kind":"struct"},"2:11461:9420":{"crate_id":2,"path":["core","str","iter","SplitNInternal"],"kind":"struct"},"18:690:20666":{"crate_id":18,"path":["memchr","memmem","FinderRev"],"kind":"struct"},"2:45892:3653":{"crate_id":2,"path":["core","core_arch","simd","i8x16"],"kind":"struct"},"2:2245:98":{"crate_id":2,"path":["core","borrow","BorrowMut"],"kind":"trait"},"37:40:19298":{"crate_id":37,"path":["rustc_demangle","v0","Ident"],"kind":"struct"},"41:11117:16551":{"crate_id":41,"path":["object","read","Relocation"],"kind":"struct"},"32:7875:14226":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","msqid_ds"],"kind":"struct"},"34:7804:10880":{"crate_id":34,"path":["linux_raw_sys","general","statfs"],"kind":"struct"},"18:481:20671":{"crate_id":18,"path":["memchr","cow","CowBytes"],"kind":"struct"},"2:20742:3640":{"crate_id":2,"path":["core","core_simd","cast","SimdCastPtr"],"kind":"trait"},"48:6965:22459":{"crate_id":48,"path":["linux_raw_sys","general","io_cqring_offsets"],"kind":"struct"},"2:40347:9225":{"crate_id":2,"path":["core","iter","adapters","inspect","Inspect"],"kind":"struct"},"16:7077:16408":{"crate_id":16,"path":["gimli","read","op","DieReference"],"kind":"enum"},"40:7103:16409":{"crate_id":40,"path":["gimli","read","op","Operation"],"kind":"enum"},"45:0:2641":{"crate_id":45,"path":["strsim"],"kind":"module"},"32:5615:13511":{"crate_id":32,"path":["libc","unix","linux_like","linux","mntent"],"kind":"struct"},"43:388:15224":{"crate_id":43,"path":["miniz_oxide","MZFlush"],"kind":"enum"},"1:4096:3456":{"crate_id":1,"path":["std","os","unix","net","ancillary","ScmRights"],"kind":"struct"},"5:6180:35296":{"crate_id":5,"path":["alloc","vec","drain_filter","drop","BackshiftOnDrop"],"kind":"struct"},"32:2181:10964":{"crate_id":32,"path":["libc","unix","linux_like","sigevent"],"kind":"struct"},"48:5594:22388":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_itimerspec"],"kind":"struct"},"2:47214:3661":{"crate_id":2,"path":["core","core_arch","simd","i16x32"],"kind":"struct"},"32:7162:14174":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","statx_timestamp"],"kind":"struct"},"34:7844:22485":{"crate_id":34,"path":["linux_raw_sys","general","compat_statfs64"],"kind":"struct"},"20:4108:2968":{"crate_id":20,"path":["clap_builder","builder","value_parser","_AutoValueParser"],"kind":"struct"},"1:10138:3548":{"crate_id":1,"path":["std","sys","unix","pipe","AnonPipe"],"kind":"struct"},"16:7437:16413":{"crate_id":16,"path":["gimli","read","op","OperationIter"],"kind":"struct"},"2:41454:3189":{"crate_id":2,"path":["core","option","Iter"],"kind":"struct"},"2:45990:3671":{"crate_id":2,"path":["core","core_arch","simd","i64x2"],"kind":"struct"},"6:4288:13473":{"crate_id":6,"path":["libc","unix","linux_like","linux","rlimit64"],"kind":"struct"},"34:7624:22473":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_buf"],"kind":"struct"},"1:11015:3544":{"crate_id":1,"path":["std","sys","unix","process","process_inner","ExitStatusError"],"kind":"struct"},"17:9098:16531":{"crate_id":17,"path":["object","read","any","SectionIterator"],"kind":"struct"},"36:540:3175":{"crate_id":36,"path":["backtrace","types","BytesOrWideString"],"kind":"enum"},"20:4859:39076":{"crate_id":20,"path":["clap_builder","util","any_value","AnyValueId"],"kind":"struct"},"41:11589:19314":{"crate_id":41,"path":["object","elf","Dyn64"],"kind":"struct"},"2:2684:220":{"crate_id":2,"path":["core","marker","Send"],"kind":"trait"},"40:7317:37729":{"crate_id":40,"path":["gimli","read","op","EvaluationState"],"kind":"enum"},"41:12607:19853":{"crate_id":41,"path":["object","macho","SourceVersionCommand"],"kind":"struct"},"2:10771:8886":{"crate_id":2,"path":["core","slice","iter","GroupBy"],"kind":"struct"},"32:608:10032":{"crate_id":32,"path":["libc","unix","hostent"],"kind":"struct"},"34:5133:22355":{"crate_id":34,"path":["linux_raw_sys","general","__kernel_sockaddr_storage__bindgen_ty_1"],"kind":"union"},"48:7117:22465":{"crate_id":48,"path":["linux_raw_sys","general","io_uring_rsrc_update"],"kind":"struct"},"33:2721:20837":{"crate_id":33,"path":["rustix","backend","io","types","ReadWriteFlags"],"kind":"struct"},"2:6917:3388":{"crate_id":2,"path":["core","iter","sources","empty","Empty"],"kind":"struct"},"41:8547:16520":{"crate_id":41,"path":["object","common","RelocationEncoding"],"kind":"enum"},"34:5077:22349":{"crate_id":34,"path":["linux_raw_sys","general","inodes_stat_t"],"kind":"struct"},"48:6081:22416":{"crate_id":48,"path":["linux_raw_sys","general","tcp_fastopen_client_fail"],"kind":"enum"},"6:1692:10958":{"crate_id":6,"path":["libc","unix","linux_like","arpreq_old"],"kind":"struct"},"32:8563:14607":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","pthread_attr_t"],"kind":"struct"},"17:10761:16539":{"crate_id":17,"path":["object","read","FileKind"],"kind":"enum"},"48:5020:10954":{"crate_id":48,"path":["linux_raw_sys","general","in_pktinfo"],"kind":"struct"},"25:173:39335":{"crate_id":25,"path":["anstyle","style","StyleDisplay"],"kind":"struct"},"20:3796:2949":{"crate_id":20,"path":["clap_builder","builder","possible_value","PossibleValue"],"kind":"struct"},"41:11046:16549":{"crate_id":41,"path":["object","read","Export"],"kind":"struct"},"34:6243:14174":{"crate_id":34,"path":["linux_raw_sys","general","statx_timestamp"],"kind":"struct"},"5:7266:8950":{"crate_id":5,"path":["alloc","string","FromUtf16Error"],"kind":"struct"},"11:744:3193":{"crate_id":11,"path":["hashbrown","map","Values"],"kind":"struct"},"17:9265:16535":{"crate_id":17,"path":["object","read","any","SymbolIterator"],"kind":"struct"},"2:10804:8887":{"crate_id":2,"path":["core","slice","iter","GroupByMut"],"kind":"struct"},"18:755:20669":{"crate_id":18,"path":["memchr","memmem","SearcherRev"],"kind":"struct"},"1:7808:3326":{"crate_id":1,"path":["std","fs","Permissions"],"kind":"struct"},"41:12402:19839":{"crate_id":41,"path":["object","macho","RpathCommand"],"kind":"struct"},"16:8072:16440":{"crate_id":16,"path":["gimli","read","unit","EntriesRaw"],"kind":"struct"},"1:11908:1498":{"crate_id":1,"path":["std","u64"],"kind":"primitive"},"17:12085:19823":{"crate_id":17,"path":["object","macho","SubLibraryCommand"],"kind":"struct"},"41:11277:16759":{"crate_id":41,"path":["object","archive","AixMemberOffset"],"kind":"struct"},"17:12496:19849":{"crate_id":17,"path":["object","macho","SymsegCommand"],"kind":"struct"},"42:727:20668":{"crate_id":42,"path":["memchr","memmem","SearcherConfig"],"kind":"struct"},"1:501:3137":{"crate_id":1,"path":["std","thread","PanicGuard"],"kind":"struct"},"6:5785:14178":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","glob64_t"],"kind":"struct"},"20:4092:38871":{"crate_id":20,"path":["clap_builder","builder","value_parser","TryMapValueParser"],"kind":"struct"},"41:11315:19297":{"crate_id":41,"path":["object","elf","FileHeader64"],"kind":"struct"},"32:7901:14227":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","semid_ds"],"kind":"struct"},"5:211:8838":{"crate_id":5,"path":["alloc","boxed","thin","ThinBox"],"kind":"struct"},"17:12770:20559":{"crate_id":17,"path":["object","pe","ImageDosHeader"],"kind":"struct"},"17:12318:19837":{"crate_id":17,"path":["object","macho","PrebindCksumCommand"],"kind":"struct"},"2:9161:8847":{"crate_id":2,"path":["core","fmt","UpperExp"],"kind":"trait"},"34:4881:22333":{"crate_id":34,"path":["linux_raw_sys","general","fscrypt_policy_v1"],"kind":"struct"},"50:0:1708":{"crate_id":50,"path":["clap_derive"],"kind":"module"},"18:599:38773":{"crate_id":18,"path":["memchr","memmem","twoway","Shift"],"kind":"enum"},"41:1978:16615":{"crate_id":41,"path":["object","read","elf","relocation","ElfSectionRelocationIterator"],"kind":"struct"},"1:5764:3573":{"crate_id":1,"path":["std","sync","lazy_lock","LazyLock"],"kind":"struct"},"5:633:35205":{"crate_id":5,"path":["alloc","boxed","from","StringError"],"kind":"struct"},"1:3925:3427":{"crate_id":1,"path":["std","os","unix","fs","PermissionsExt"],"kind":"trait"},"40:325:15404":{"crate_id":40,"path":["gimli","read","cfi","UnwindOffset"],"kind":"trait"},"40:8109:16442":{"crate_id":40,"path":["gimli","read","unit","EntriesTree"],"kind":"struct"},"1:10702:119":{"crate_id":1,"path":["std","sys","unix","fs","DirBuilder"],"kind":"struct"},"32:7842:13389":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","sysinfo"],"kind":"struct"},"5:1443:3198":{"crate_id":5,"path":["alloc","collections","btree","map","IntoValues"],"kind":"struct"},"32:9297:14989":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","align","clone_args"],"kind":"struct"},"2:10165:8892":{"crate_id":2,"path":["core","slice","iter","RSplit"],"kind":"struct"},"32:8581:14608":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","_libc_fpxreg"],"kind":"struct"},"0:20:1710":{"crate_id":0,"path":["clap","_derive"],"kind":"module"},"17:10015:16693":{"crate_id":17,"path":["object","read","macho","dyld_cache","DyldSubCache"],"kind":"struct"},"5:3622:35280":{"crate_id":5,"path":["alloc","collections","linked_list","drop","DropGuard"],"kind":"struct"},"17:13516:20612":{"crate_id":17,"path":["object","pe","ImageLoadConfigDirectory32"],"kind":"struct"},"16:5418:37854":{"crate_id":16,"path":["gimli","read","util","sealed","CapacityFull"],"kind":"struct"},"2:2701:228":{"crate_id":2,"path":["core","marker","Sync"],"kind":"trait"},"1:4642:3465":{"crate_id":1,"path":["std","os","linux","process","CommandExt"],"kind":"trait"},"41:9275:16534":{"crate_id":41,"path":["object","read","any","SymbolTable"],"kind":"struct"},"32:2107:10959":{"crate_id":32,"path":["libc","unix","linux_like","arphdr"],"kind":"struct"},"40:6520:16390":{"crate_id":40,"path":["gimli","read","index","UnitIndexSection"],"kind":"struct"},"2:39998:9035":{"crate_id":2,"path":["core","char","convert","CharTryFromError"],"kind":"struct"},"6:500:10029":{"crate_id":6,"path":["libc","unix","rlimit"],"kind":"struct"},"16:7103:16409":{"crate_id":16,"path":["gimli","read","op","Operation"],"kind":"enum"},"1:5556:206":{"crate_id":1,"path":["std","sync","mpsc","Receiver"],"kind":"struct"},"2:2603:128":{"crate_id":2,"path":["core","error","Error"],"kind":"trait"},"48:5825:22401":{"crate_id":48,"path":["linux_raw_sys","general","__sifields__bindgen_ty_5__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"1:6757:3625":{"crate_id":1,"path":["std","std_float","StdFloat"],"kind":"trait"},"41:9379:38759":{"crate_id":41,"path":["object","read","any","DynamicRelocationIteratorInternal"],"kind":"enum"},"48:6399:22424":{"crate_id":48,"path":["linux_raw_sys","general","termio"],"kind":"struct"},"41:10692:16736":{"crate_id":41,"path":["object","read","pe","relocation","RelocationBlockIterator"],"kind":"struct"},"40:7529:16421":{"crate_id":40,"path":["gimli","read","rnglists","DebugRanges"],"kind":"struct"},"41:1596:16604":{"crate_id":41,"path":["object","read","elf","section","SectionHeader"],"kind":"trait"},"16:6442:16385":{"crate_id":16,"path":["gimli","read","aranges","ArangeEntry"],"kind":"struct"},"34:7505:22462":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_11"],"kind":"enum"},"20:4926:2658":{"crate_id":20,"path":["clap_builder","util","id","Id"],"kind":"struct"},"41:10485:16739":{"crate_id":41,"path":["object","read","pe","file","PeComdat"],"kind":"struct"},"32:5397:13503":{"crate_id":32,"path":["libc","unix","linux_like","linux","Elf32_Ehdr"],"kind":"struct"},"41:13178:20575":{"crate_id":41,"path":["object","pe","ImageSymbol"],"kind":"struct"},"17:13842:20631":{"crate_id":17,"path":["object","pe","NonPagedDebugInfo"],"kind":"struct"},"41:10522:16712":{"crate_id":41,"path":["object","read","pe","section","PeSegment"],"kind":"struct"},"6:4898:13536":{"crate_id":6,"path":["libc","unix","linux_like","linux","sctp_sndrcvinfo"],"kind":"struct"},"16:6535:37744":{"crate_id":16,"path":["gimli","read","lazy","imp","LazyArc"],"kind":"struct"},"48:5292:22376":{"crate_id":48,"path":["linux_raw_sys","general","ipv6_opt_hdr"],"kind":"struct"},"1:3129:24578":{"crate_id":1,"path":["std","io","stdio","StdinRaw"],"kind":"struct"},"23:0:2629":{"crate_id":23,"path":["clap_lex"],"kind":"module"},"41:4071:16507":{"crate_id":41,"path":["object","read","traits","ObjectSection"],"kind":"trait"},"32:1962:10953":{"crate_id":32,"path":["libc","unix","linux_like","lconv"],"kind":"struct"},"8:0:2491":{"crate_id":8,"path":["cfg_if"],"kind":"module"},"32:9665:13706":{"crate_id":32,"path":["libc","unix","linux_like","linux","pthread_rwlock_t"],"kind":"struct"},"34:5563:10031":{"crate_id":34,"path":["linux_raw_sys","general","ipv6_mreq"],"kind":"struct"},"5:3150:3212":{"crate_id":5,"path":["alloc","collections","btree","set","SymmetricDifference"],"kind":"struct"},"34:5655:22381":{"crate_id":34,"path":["linux_raw_sys","general","ipv6hdr__bindgen_ty_1__bindgen_ty_1"],"kind":"struct"},"32:2019:10955":{"crate_id":32,"path":["libc","unix","linux_like","ifaddrs"],"kind":"struct"},"2:41951:85":{"crate_id":2,"path":["core","sync","atomic","AtomicIsize"],"kind":"struct"},"41:12003:19814":{"crate_id":41,"path":["object","macho","Section32"],"kind":"struct"},"2:46682:3672":{"crate_id":2,"path":["core","core_arch","simd","i64x4"],"kind":"struct"},"41:11601:19315":{"crate_id":41,"path":["object","elf","Versym"],"kind":"struct"},"1:8166:3407":{"crate_id":1,"path":["std","net","tcp","IntoIncoming"],"kind":"struct"},"48:5658:10038":{"crate_id":48,"path":["linux_raw_sys","general","itimerval"],"kind":"struct"},"45:72:24047":{"crate_id":45,"path":["strsim","StrSimError"],"kind":"enum"},"2:20990:3633":{"crate_id":2,"path":["core","core_simd","lane_count","SupportedLaneCount"],"kind":"trait"},"26:434:20757":{"crate_id":26,"path":["anstream","strip","StripStream"],"kind":"struct"},"16:5920:16362":{"crate_id":16,"path":["gimli","read","cfi","UnwindContext"],"kind":"struct"},"6:1564:10947":{"crate_id":6,"path":["libc","unix","linux_like","addrinfo"],"kind":"struct"},"6:6008:14195":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","__c_anonymous_ptrace_syscall_info_seccomp"],"kind":"struct"},"34:6988:22440":{"crate_id":34,"path":["linux_raw_sys","general","uffdio_register"],"kind":"struct"},"20:112:2645":{"crate_id":20,"path":["clap_builder","builder"],"kind":"module"},"11:305:37591":{"crate_id":11,"path":["hashbrown","raw","RawIter"],"kind":"struct"},"17:9028:16530":{"crate_id":17,"path":["object","read","any","SegmentIterator"],"kind":"struct"},"1:11372:3409":{"crate_id":1,"path":["std","sys_common","net","TcpListener"],"kind":"struct"},"32:8325:10880":{"crate_id":32,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statfs"],"kind":"struct"},"18:727:20668":{"crate_id":18,"path":["memchr","memmem","SearcherConfig"],"kind":"struct"},"34:7055:22448":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_sqe__bindgen_ty_3"],"kind":"union"},"20:56:2660":{"crate_id":20,"path":["clap_builder","derive","CommandFactory"],"kind":"trait"},"6:7252:14988":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","align","max_align_t"],"kind":"struct"},"16:6868:37685":{"crate_id":16,"path":["gimli","read","lists","ListsHeader"],"kind":"struct"},"1:8208:3403":{"crate_id":1,"path":["std","os","unix","net","addr","SocketAddr"],"kind":"struct"},"2:5987:9235":{"crate_id":2,"path":["core","iter","adapters","intersperse","IntersperseWith"],"kind":"struct"},"17:12358:19840":{"crate_id":17,"path":["object","macho","LinkeditDataCommand"],"kind":"struct"},"41:11412:19302":{"crate_id":41,"path":["object","elf","CompressionHeader64"],"kind":"struct"},"2:1637:9190":{"crate_id":2,"path":["core","mem","Discriminant"],"kind":"struct"},"2:46446:3706":{"crate_id":2,"path":["core","core_arch","simd","u64x4"],"kind":"struct"},"2:47732:8804":{"crate_id":2,"path":["core","core_arch","x86","__m512i"],"kind":"struct"},"41:11250:16758":{"crate_id":41,"path":["object","archive","AixFileHeader"],"kind":"struct"},"20:3982:2977":{"crate_id":20,"path":["clap_builder","builder","value_parser","PathBufValueParser"],"kind":"struct"},"0:19:1855":{"crate_id":0,"path":["clap","_cookbook","typed_derive"],"kind":"module"},"16:8256:16449":{"crate_id":16,"path":["gimli","read","StoreOnHeap"],"kind":"struct"},"41:10880:16541":{"crate_id":41,"path":["object","read","SectionIndex"],"kind":"struct"},"1:1846:3270":{"crate_id":1,"path":["std","env","ArgsOs"],"kind":"struct"},"2:47862:8810":{"crate_id":2,"path":["core","core_arch","x86","cpuid","CpuidResult"],"kind":"struct"},"17:10897:16545":{"crate_id":17,"path":["object","read","SymbolMapName"],"kind":"struct"},"6:4999:13547":{"crate_id":6,"path":["libc","unix","linux_like","linux","uinput_user_dev"],"kind":"struct"},"34:7745:10036":{"crate_id":34,"path":["linux_raw_sys","general","linger"],"kind":"struct"},"1:3247:3379":{"crate_id":1,"path":["std","io","stdio","Stderr"],"kind":"struct"},"5:2169:36386":{"crate_id":5,"path":["alloc","collections","btree","navigate","LazyLeafHandle"],"kind":"enum"},"2:2161:9293":{"crate_id":2,"path":["core","ptr","from_exposed_addr"],"kind":"function"},"27:113:20780":{"crate_id":27,"path":["anstyle_parse","params","Params"],"kind":"struct"},"2:9985:3190":{"crate_id":2,"path":["core","slice","iter","IterMut"],"kind":"struct"},"48:4949:10941":{"crate_id":48,"path":["linux_raw_sys","general","ip_mreq"],"kind":"struct"},"6:1682:10957":{"crate_id":6,"path":["libc","unix","linux_like","arpreq"],"kind":"struct"},"48:4519:22325":{"crate_id":48,"path":["linux_raw_sys","general","__kernel_fsid_t"],"kind":"struct"},"20:4003:2978":{"crate_id":20,"path":["clap_builder","builder","value_parser","PossibleValuesParser"],"kind":"struct"},"2:47785:8807":{"crate_id":2,"path":["core","core_arch","x86","__m128bh"],"kind":"struct"},"34:5422:22371":{"crate_id":34,"path":["linux_raw_sys","general","_bindgen_ty_2"],"kind":"enum"},"34:5366:22364":{"crate_id":34,"path":["linux_raw_sys","general","iphdr__bindgen_ty_1"],"kind":"union"},"6:6668:10884":{"crate_id":6,"path":["libc","unix","linux_like","linux","gnu","b64","x86_64","statvfs64"],"kind":"struct"},"2:8675:86":{"crate_id":2,"path":["core","sync","atomic","AtomicPtr"],"kind":"struct"},"20:1483:2671":{"crate_id":20,"path":["clap_builder","value_parser"],"kind":"macro"},"34:7644:22475":{"crate_id":34,"path":["linux_raw_sys","general","io_uring_buf_ring__bindgen_ty_1__bindgen_ty_2"],"kind":"struct"},"7:32:15194":{"crate_id":7,"path":["unwind","libunwind","_Unwind_Reason_Code"],"kind":"enum"},"34:5569:22373":{"crate_id":34,"path":["linux_raw_sys","general","in6_flowlabel_req"],"kind":"struct"},"1:10722:25869":{"crate_id":1,"path":["std","sys","unix","kernel_copy","SpliceMode"],"kind":"enum"},"5:3534:3189":{"crate_id":5,"path":["alloc","collections","linked_list","Iter"],"kind":"struct"},"16:6431:16384":{"crate_id":16,"path":["gimli","read","aranges","ArangeEntryIter"],"kind":"struct"},"2:43640:8909":{"crate_id":2,"path":["core","str","iter","SplitAsciiWhitespace"],"kind":"struct"},"2:9153:8848":{"crate_id":2,"path":["core","fmt","LowerHex"],"kind":"trait"},"2:2774:9264":{"crate_id":2,"path":["core","ops","arith","Rem"],"kind":"trait"},"11:757:3194":{"crate_id":11,"path":["hashbrown","map","Drain"],"kind":"struct"},"6:532:10032":{"crate_id":6,"path":["libc","unix","hostent"],"kind":"struct"},"6:653:10088":{"crate_id":6,"path":["libc","unix","linux_like","timezone"],"kind":"enum"},"2:40268:9212":{"crate_id":2,"path":["core","iter","adapters","cloned","Cloned"],"kind":"struct"},"20:3891:2966":{"crate_id":20,"path":["clap_builder","builder","styled_str","StyledStr"],"kind":"struct"},"1:4104:3457":{"crate_id":1,"path":["std","os","unix","net","ancillary","ScmCredentials"],"kind":"struct"},"2:47324:3695":{"crate_id":2,"path":["core","core_arch","simd","u16x32"],"kind":"struct"},"32:732:10039":{"crate_id":32,"path":["libc","unix","tms"],"kind":"struct"},"2:47675:8799":{"crate_id":2,"path":["core","core_arch","x86","__m128"],"kind":"struct"},"36:70:23966":{"crate_id":36,"path":["backtrace","symbolize","SymbolName"],"kind":"struct"},"2:7240:121":{"crate_id":2,"path":["core","iter","traits","double_ended","DoubleEndedIterator"],"kind":"trait"},"48:4713:22344":{"crate_id":48,"path":["linux_raw_sys","general","mount_attr"],"kind":"struct"},"2:9295:35014":{"crate_id":2,"path":["core","fmt","fmt","BorrowedPlaceholder"],"kind":"struct"},"1:1844:2659":{"crate_id":1,"path":["std","env","Args"],"kind":"struct"},"41:13563:20611":{"crate_id":41,"path":["object","pe","ImageEpilogueDynamicRelocationHeader"],"kind":"struct"},"1:7862:3228":{"crate_id":1,"path":["std","io","cursor","Cursor"],"kind":"struct"},"10:36:37573":{"crate_id":10,"path":["adler","algo","U32X4"],"kind":"struct"},"17:11060:16551":{"crate_id":17,"path":["object","read","Relocation"],"kind":"struct"},"17:9424:16562":{"crate_id":17,"path":["object","read","archive","ArchiveFile"],"kind":"struct"},"41:420:15399":{"crate_id":41,"path":["object","read","any","Section"],"kind":"struct"},"6:5071:13554":{"crate_id":6,"path":["libc","unix","linux_like","linux","__c_anonymous_sockaddr_can_can_addr"],"kind":"union"},"16:2357:15427":{"crate_id":16,"path":["gimli","common","Register"],"kind":"struct"},"33:393:39691":{"crate_id":33,"path":["rustix","backend","reg","ArgReg"],"kind":"struct"},"17:13865:20633":{"crate_id":17,"path":["object","pe","ImportObjectHeader"],"kind":"struct"},"41:10548:16710":{"crate_id":41,"path":["object","read","pe","section","PeSection"],"kind":"struct"},"1:5385:2652":{"crate_id":1,"path":["std","process","Command"],"kind":"struct"}},"external_crates":{"49":{"name":"unicode_width","html_root_url":null},"46":{"name":"terminal_size","html_root_url":null},"43":{"name":"miniz_oxide","html_root_url":null},"40":{"name":"gimli","html_root_url":null},"37":{"name":"rustc_demangle","html_root_url":null},"34":{"name":"linux_raw_sys","html_root_url":null},"31":{"name":"io_lifetimes","html_root_url":null},"28":{"name":"utf8parse","html_root_url":null},"25":{"name":"anstyle","html_root_url":null},"22":{"name":"bitflags","html_root_url":"https://docs.rs/bitflags/1.3.2/"},"19":{"name":"panic_unwind","html_root_url":"https://doc.rust-lang.org/nightly/"},"16":{"name":"gimli","html_root_url":"https://doc.rust-lang.org/nightly/"},"13":{"name":"std_detect","html_root_url":"https://doc.rust-lang.org/nightly/"},"10":{"name":"adler","html_root_url":"https://docs.rs/adler/1.0.2/"},"7":{"name":"unwind","html_root_url":"https://doc.rust-lang.org/nightly/"},"4":{"name":"rustc_std_workspace_core","html_root_url":"https://doc.rust-lang.org/nightly/"},"1":{"name":"std","html_root_url":"https://doc.rust-lang.org/nightly/"},"50":{"name":"clap_derive","html_root_url":null},"47":{"name":"rustix","html_root_url":null},"44":{"name":"adler","html_root_url":"https://docs.rs/adler/1.0.2/"},"41":{"name":"object","html_root_url":null},"38":{"name":"cfg_if","html_root_url":"https://docs.rs/cfg-if/"},"35":{"name":"anstyle_query","html_root_url":null},"32":{"name":"libc","html_root_url":null},"29":{"name":"colorchoice","html_root_url":null},"26":{"name":"anstream","html_root_url":null},"23":{"name":"clap_lex","html_root_url":null},"20":{"name":"clap_builder","html_root_url":null},"17":{"name":"object","html_root_url":"https://doc.rust-lang.org/nightly/"},"14":{"name":"rustc_demangle","html_root_url":"https://doc.rust-lang.org/nightly/"},"11":{"name":"hashbrown","html_root_url":"https://doc.rust-lang.org/nightly/"},"8":{"name":"cfg_if","html_root_url":"https://docs.rs/cfg-if/"},"5":{"name":"alloc","html_root_url":"https://doc.rust-lang.org/nightly/"},"2":{"name":"core","html_root_url":"https://doc.rust-lang.org/nightly/"},"48":{"name":"linux_raw_sys","html_root_url":null},"45":{"name":"strsim","html_root_url":null},"42":{"name":"memchr","html_root_url":null},"39":{"name":"addr2line","html_root_url":null},"36":{"name":"backtrace","html_root_url":"https://docs.rs/backtrace/"},"33":{"name":"rustix","html_root_url":null},"30":{"name":"is_terminal","html_root_url":null},"27":{"name":"anstyle_parse","html_root_url":null},"24":{"name":"unicase","html_root_url":"https://docs.rs/unicase/2.6.0/"},"21":{"name":"once_cell","html_root_url":null},"18":{"name":"memchr","html_root_url":"https://doc.rust-lang.org/nightly/"},"15":{"name":"addr2line","html_root_url":"https://doc.rust-lang.org/nightly/"},"12":{"name":"rustc_std_workspace_alloc","html_root_url":"https://doc.rust-lang.org/nightly/"},"9":{"name":"miniz_oxide","html_root_url":"https://doc.rust-lang.org/nightly/"},"6":{"name":"libc","html_root_url":"https://doc.rust-lang.org/nightly/"},"3":{"name":"compiler_builtins","html_root_url":"https://doc.rust-lang.org/nightly/"}},"format_version":26}